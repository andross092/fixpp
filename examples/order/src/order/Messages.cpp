// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <vector>
#include <set>

#include <order/Messages.h>

namespace order
{

// start of Messages.cxx

// Generated

// -------------------------- getMessageName getMessageType -------------------------

const std::string EMPTY_STRING;

const char * MessageHeader::getMessageName(){
     return "Header";
}

const std::string & MessageHeader::getMessageType(){
     return EMPTY_STRING;
}


const char * MessageNewOrderSingle::getMessageName(){
     return "NewOrderSingle";
}

const std::string & MessageNewOrderSingle::getMessageType(){
     return MsgTypeEnums::NEW_ORDER_SINGLE.str;
}


const char * MessageExecutionReport::getMessageName(){
     return "ExecutionReport";
}

const std::string & MessageExecutionReport::getMessageType(){
     return MsgTypeEnums::EXECUTION_REPORT.str;
}


// -------------------------------------- scan ----------------------------------------

offset_t MessageHeader::scan( const char * fix, unsigned len ){
buf = fix; 
offset_t prev = 0, pos = 0; 
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldBeginString::RAW_TAG :
     FIXPP_PRINT_FIELD(BeginString) 
     fieldBeginString.offset = pos;
     break;

   case FieldBodyLength::RAW_TAG :
     FIXPP_PRINT_FIELD(BodyLength) 
     fieldBodyLength.offset = pos;
     break;

   case FieldMsgType::RAW_TAG :
     FIXPP_PRINT_FIELD(MsgType) 
     fieldMsgType.offset = pos;
     break;

   case FieldSenderCompID::RAW_TAG :
     FIXPP_PRINT_FIELD(SenderCompID) 
     fieldSenderCompID.offset = pos;
     break;

   case FieldTargetCompID::RAW_TAG :
     FIXPP_PRINT_FIELD(TargetCompID) 
     fieldTargetCompID.offset = pos;
     break;

   case FieldMsgSeqNum::RAW_TAG :
     FIXPP_PRINT_FIELD(MsgSeqNum) 
     fieldMsgSeqNum.offset = pos;
     break;

   case FieldSendingTime::RAW_TAG :
     FIXPP_PRINT_FIELD(SendingTime) 
     fieldSendingTime.offset = pos;
     break;

   case FieldCheckSum::RAW_TAG :
     FIXPP_PRINT_FIELD(CheckSum) 
     fieldCheckSum.offset = pos;
     gotoNextField( fix, pos );
     return pos; 

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t MessageNewOrderSingle::scan( const char * fix, unsigned len ){
buf = fix; 
offset_t prev = 0, pos = 0; 
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdID) 
     fieldClOrdID.offset = pos;
     break;

   case FieldAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(Account) 
     fieldAccount.offset = pos;
     break;

   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol) 
     fieldSymbol.offset = pos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID) 
     fieldSecurityID.offset = pos;
     break;

   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side) 
     fieldSide.offset = pos;
     break;

   case FieldQtyType::RAW_TAG :
     FIXPP_PRINT_FIELD(QtyType) 
     fieldQtyType.offset = pos;
     break;

   case FieldOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderQty) 
     fieldOrderQty.offset = pos;
     break;

   case FieldOrdType::RAW_TAG :
     FIXPP_PRINT_FIELD(OrdType) 
     fieldOrdType.offset = pos;
     break;

   case FieldPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(Price) 
     fieldPrice.offset = pos;
     break;

   case FieldStopPx::RAW_TAG :
     FIXPP_PRINT_FIELD(StopPx) 
     fieldStopPx.offset = pos;
     break;

   case FieldTransactTime::RAW_TAG :
     FIXPP_PRINT_FIELD(TransactTime) 
     fieldTransactTime.offset = pos;
     break;

   case FieldCheckSum::RAW_TAG :
     FIXPP_PRINT_FIELD(CheckSum) 
     fieldCheckSum.offset = pos;
     gotoNextField( fix, pos );
     return pos; 

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t MessageExecutionReport::scan( const char * fix, unsigned len ){
buf = fix; 
offset_t prev = 0, pos = 0; 
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldOrderID::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderID) 
     fieldOrderID.offset = pos;
     break;

   case FieldClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdID) 
     fieldClOrdID.offset = pos;
     break;

   case FieldOrigClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(OrigClOrdID) 
     fieldOrigClOrdID.offset = pos;
     break;

   case FieldExecID::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecID) 
     fieldExecID.offset = pos;
     break;

   case FieldExecType::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecType) 
     fieldExecType.offset = pos;
     break;

   case FieldOrdStatus::RAW_TAG :
     FIXPP_PRINT_FIELD(OrdStatus) 
     fieldOrdStatus.offset = pos;
     break;

   case FieldOrdRejReason::RAW_TAG :
     FIXPP_PRINT_FIELD(OrdRejReason) 
     fieldOrdRejReason.offset = pos;
     break;

   case FieldAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(Account) 
     fieldAccount.offset = pos;
     break;

   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol) 
     fieldSymbol.offset = pos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID) 
     fieldSecurityID.offset = pos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType) 
     fieldSecurityType.offset = pos;
     break;

   case FieldText::RAW_TAG :
     FIXPP_PRINT_FIELD(Text) 
     fieldText.offset = pos;
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product) 
     fieldProduct.offset = pos;
     break;

   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side) 
     fieldSide.offset = pos;
     break;

   case FieldQtyType::RAW_TAG :
     FIXPP_PRINT_FIELD(QtyType) 
     fieldQtyType.offset = pos;
     break;

   case FieldOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderQty) 
     fieldOrderQty.offset = pos;
     break;

   case FieldOrdType::RAW_TAG :
     FIXPP_PRINT_FIELD(OrdType) 
     fieldOrdType.offset = pos;
     break;

   case FieldPriceType::RAW_TAG :
     FIXPP_PRINT_FIELD(PriceType) 
     fieldPriceType.offset = pos;
     break;

   case FieldPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(Price) 
     fieldPrice.offset = pos;
     break;

   case FieldStopPx::RAW_TAG :
     FIXPP_PRINT_FIELD(StopPx) 
     fieldStopPx.offset = pos;
     break;

   case FieldCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(Currency) 
     fieldCurrency.offset = pos;
     break;

   case FieldTimeInForce::RAW_TAG :
     FIXPP_PRINT_FIELD(TimeInForce) 
     fieldTimeInForce.offset = pos;
     break;

   case FieldExecInst::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecInst) 
     fieldExecInst.offset = pos;
     break;

   case FieldLastQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LastQty) 
     fieldLastQty.offset = pos;
     break;

   case FieldLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LastPx) 
     fieldLastPx.offset = pos;
     break;

   case FieldLeavesQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LeavesQty) 
     fieldLeavesQty.offset = pos;
     break;

   case FieldAvgPx::RAW_TAG :
     FIXPP_PRINT_FIELD(AvgPx) 
     fieldAvgPx.offset = pos;
     break;

   case FieldCumQty::RAW_TAG :
     FIXPP_PRINT_FIELD(CumQty) 
     fieldCumQty.offset = pos;
     break;

   case FieldNoLegs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegs) 
     fieldNoLegs.offset = pos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::scan( groupsLegs, fix+pos, len - pos );
     break;

   case FieldCheckSum::RAW_TAG :
     FIXPP_PRINT_FIELD(CheckSum) 
     fieldCheckSum.offset = pos;
     gotoNextField( fix, pos );
     return pos; 

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}


// -------------------------------------- skip ----------------------------------------

offset_t MessageHeader::skip( const char * fix, unsigned len ) const
{
offset_t prev = 0, pos = 0; 
gotoNextField( fix, pos );
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldBeginString::RAW_TAG :
     break;

   case FieldBodyLength::RAW_TAG :
     break;

   case FieldMsgType::RAW_TAG :
     break;

   case FieldSenderCompID::RAW_TAG :
     break;

   case FieldTargetCompID::RAW_TAG :
     break;

   case FieldMsgSeqNum::RAW_TAG :
     break;

   case FieldSendingTime::RAW_TAG :
     break;

   case FieldCheckSum::RAW_TAG :
     gotoNextField( fix, pos );
     return pos;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t MessageNewOrderSingle::skip( const char * fix, unsigned len ) const
{
offset_t prev = 0, pos = 0; 
gotoNextField( fix, pos );
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldClOrdID::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldSymbol::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldQtyType::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldOrdType::RAW_TAG :
     break;

   case FieldPrice::RAW_TAG :
     break;

   case FieldStopPx::RAW_TAG :
     break;

   case FieldTransactTime::RAW_TAG :
     break;

   case FieldCheckSum::RAW_TAG :
     gotoNextField( fix, pos );
     return pos;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t MessageExecutionReport::skip( const char * fix, unsigned len ) const
{
offset_t prev = 0, pos = 0; 
gotoNextField( fix, pos );
while( pos < (int)len ) {
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){

   case FieldOrderID::RAW_TAG :
     break;

   case FieldClOrdID::RAW_TAG :
     break;

   case FieldOrigClOrdID::RAW_TAG :
     break;

   case FieldExecID::RAW_TAG :
     break;

   case FieldExecType::RAW_TAG :
     break;

   case FieldOrdStatus::RAW_TAG :
     break;

   case FieldOrdRejReason::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldSymbol::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldQtyType::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldOrdType::RAW_TAG :
     break;

   case FieldPriceType::RAW_TAG :
     break;

   case FieldPrice::RAW_TAG :
     break;

   case FieldStopPx::RAW_TAG :
     break;

   case FieldCurrency::RAW_TAG :
     break;

   case FieldTimeInForce::RAW_TAG :
     break;

   case FieldExecInst::RAW_TAG :
     break;

   case FieldLastQty::RAW_TAG :
     break;

   case FieldLastPx::RAW_TAG :
     break;

   case FieldLeavesQty::RAW_TAG :
     break;

   case FieldAvgPx::RAW_TAG :
     break;

   case FieldCumQty::RAW_TAG :
     break;

   case FieldNoLegs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::skip( fix+pos, len - pos );
     break;

   case FieldCheckSum::RAW_TAG :
     gotoNextField( fix, pos );
     return pos;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}


// ---------------------------------- fields ---------------------------------

GetDepthMethod MessageHeader::groupGetDepthMethods[] = {
  nullptr };

GetDepthMethod MessageNewOrderSingle::groupGetDepthMethods[] = {
  nullptr };

GetDepthMethod MessageExecutionReport::groupGetDepthMethods[] = {
  GroupLegs::getFieldDepth,
  nullptr };


FieldDepth MessageHeader::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldBeginString::RAW_TAG :
     case FieldBodyLength::RAW_TAG :
     case FieldMsgType::RAW_TAG :
     case FieldSenderCompID::RAW_TAG :
     case FieldTargetCompID::RAW_TAG :
     case FieldMsgSeqNum::RAW_TAG :
     case FieldSendingTime::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth MessageNewOrderSingle::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldClOrdID::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldSymbol::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldQtyType::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldOrdType::RAW_TAG :
     case FieldPrice::RAW_TAG :
     case FieldStopPx::RAW_TAG :
     case FieldTransactTime::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth MessageExecutionReport::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldOrderID::RAW_TAG :
     case FieldClOrdID::RAW_TAG :
     case FieldOrigClOrdID::RAW_TAG :
     case FieldExecID::RAW_TAG :
     case FieldExecType::RAW_TAG :
     case FieldOrdStatus::RAW_TAG :
     case FieldOrdRejReason::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldSymbol::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldText::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldQtyType::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldOrdType::RAW_TAG :
     case FieldPriceType::RAW_TAG :
     case FieldPrice::RAW_TAG :
     case FieldStopPx::RAW_TAG :
     case FieldCurrency::RAW_TAG :
     case FieldTimeInForce::RAW_TAG :
     case FieldExecInst::RAW_TAG :
     case FieldLastQty::RAW_TAG :
     case FieldLastPx::RAW_TAG :
     case FieldLeavesQty::RAW_TAG :
     case FieldAvgPx::RAW_TAG :
     case FieldCumQty::RAW_TAG :
     case FieldNoLegs::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}


const char * MessageHeader::getFieldValue( unsigned tag ) const {
   if( buf == nullptr ) return nullptr;
   switch( tag ){
     case FieldBeginString::TAG : return fieldBeginString.offset >= 0 ? buf + fieldBeginString.offset : nullptr;
     case FieldBodyLength::TAG : return fieldBodyLength.offset >= 0 ? buf + fieldBodyLength.offset : nullptr;
     case FieldMsgType::TAG : return fieldMsgType.offset >= 0 ? buf + fieldMsgType.offset : nullptr;
     case FieldSenderCompID::TAG : return fieldSenderCompID.offset >= 0 ? buf + fieldSenderCompID.offset : nullptr;
     case FieldTargetCompID::TAG : return fieldTargetCompID.offset >= 0 ? buf + fieldTargetCompID.offset : nullptr;
     case FieldMsgSeqNum::TAG : return fieldMsgSeqNum.offset >= 0 ? buf + fieldMsgSeqNum.offset : nullptr;
     case FieldSendingTime::TAG : return fieldSendingTime.offset >= 0 ? buf + fieldSendingTime.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset >= 0 ? buf + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}

const char * MessageNewOrderSingle::getFieldValue( unsigned tag ) const {
   if( buf == nullptr ) return nullptr;
   switch( tag ){
     case FieldClOrdID::TAG : return fieldClOrdID.offset >= 0 ? buf + fieldClOrdID.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset >= 0 ? buf + fieldAccount.offset : nullptr;
     case FieldSymbol::TAG : return fieldSymbol.offset >= 0 ? buf + fieldSymbol.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset >= 0 ? buf + fieldSecurityID.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset >= 0 ? buf + fieldSide.offset : nullptr;
     case FieldQtyType::TAG : return fieldQtyType.offset >= 0 ? buf + fieldQtyType.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset >= 0 ? buf + fieldOrderQty.offset : nullptr;
     case FieldOrdType::TAG : return fieldOrdType.offset >= 0 ? buf + fieldOrdType.offset : nullptr;
     case FieldPrice::TAG : return fieldPrice.offset >= 0 ? buf + fieldPrice.offset : nullptr;
     case FieldStopPx::TAG : return fieldStopPx.offset >= 0 ? buf + fieldStopPx.offset : nullptr;
     case FieldTransactTime::TAG : return fieldTransactTime.offset >= 0 ? buf + fieldTransactTime.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset >= 0 ? buf + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}

const char * MessageExecutionReport::getFieldValue( unsigned tag ) const {
   if( buf == nullptr ) return nullptr;
   switch( tag ){
     case FieldOrderID::TAG : return fieldOrderID.offset >= 0 ? buf + fieldOrderID.offset : nullptr;
     case FieldClOrdID::TAG : return fieldClOrdID.offset >= 0 ? buf + fieldClOrdID.offset : nullptr;
     case FieldOrigClOrdID::TAG : return fieldOrigClOrdID.offset >= 0 ? buf + fieldOrigClOrdID.offset : nullptr;
     case FieldExecID::TAG : return fieldExecID.offset >= 0 ? buf + fieldExecID.offset : nullptr;
     case FieldExecType::TAG : return fieldExecType.offset >= 0 ? buf + fieldExecType.offset : nullptr;
     case FieldOrdStatus::TAG : return fieldOrdStatus.offset >= 0 ? buf + fieldOrdStatus.offset : nullptr;
     case FieldOrdRejReason::TAG : return fieldOrdRejReason.offset >= 0 ? buf + fieldOrdRejReason.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset >= 0 ? buf + fieldAccount.offset : nullptr;
     case FieldSymbol::TAG : return fieldSymbol.offset >= 0 ? buf + fieldSymbol.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset >= 0 ? buf + fieldSecurityID.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset >= 0 ? buf + fieldSecurityType.offset : nullptr;
     case FieldText::TAG : return fieldText.offset >= 0 ? buf + fieldText.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset >= 0 ? buf + fieldProduct.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset >= 0 ? buf + fieldSide.offset : nullptr;
     case FieldQtyType::TAG : return fieldQtyType.offset >= 0 ? buf + fieldQtyType.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset >= 0 ? buf + fieldOrderQty.offset : nullptr;
     case FieldOrdType::TAG : return fieldOrdType.offset >= 0 ? buf + fieldOrdType.offset : nullptr;
     case FieldPriceType::TAG : return fieldPriceType.offset >= 0 ? buf + fieldPriceType.offset : nullptr;
     case FieldPrice::TAG : return fieldPrice.offset >= 0 ? buf + fieldPrice.offset : nullptr;
     case FieldStopPx::TAG : return fieldStopPx.offset >= 0 ? buf + fieldStopPx.offset : nullptr;
     case FieldCurrency::TAG : return fieldCurrency.offset >= 0 ? buf + fieldCurrency.offset : nullptr;
     case FieldTimeInForce::TAG : return fieldTimeInForce.offset >= 0 ? buf + fieldTimeInForce.offset : nullptr;
     case FieldExecInst::TAG : return fieldExecInst.offset >= 0 ? buf + fieldExecInst.offset : nullptr;
     case FieldLastQty::TAG : return fieldLastQty.offset >= 0 ? buf + fieldLastQty.offset : nullptr;
     case FieldLastPx::TAG : return fieldLastPx.offset >= 0 ? buf + fieldLastPx.offset : nullptr;
     case FieldLeavesQty::TAG : return fieldLeavesQty.offset >= 0 ? buf + fieldLeavesQty.offset : nullptr;
     case FieldAvgPx::TAG : return fieldAvgPx.offset >= 0 ? buf + fieldAvgPx.offset : nullptr;
     case FieldCumQty::TAG : return fieldCumQty.offset >= 0 ? buf + fieldCumQty.offset : nullptr;
     case FieldNoLegs::TAG : return fieldNoLegs.offset >= 0 ? buf + fieldNoLegs.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset >= 0 ? buf + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}


namespace {

const std::vector<tag_t> Header_knownFields = {
FieldBeginString::TAG,
FieldBodyLength::TAG,
FieldMsgType::TAG,
FieldSenderCompID::TAG,
FieldTargetCompID::TAG,
FieldMsgSeqNum::TAG,
FieldSendingTime::TAG,
FieldCheckSum::TAG };

const std::vector<tag_t> NewOrderSingle_knownFields = {
FieldClOrdID::TAG,
FieldAccount::TAG,
FieldSymbol::TAG,
FieldSecurityID::TAG,
FieldSide::TAG,
FieldQtyType::TAG,
FieldOrderQty::TAG,
FieldOrdType::TAG,
FieldPrice::TAG,
FieldStopPx::TAG,
FieldTransactTime::TAG,
FieldCheckSum::TAG };

const std::vector<tag_t> ExecutionReport_knownFields = {
FieldOrderID::TAG,
FieldClOrdID::TAG,
FieldOrigClOrdID::TAG,
FieldExecID::TAG,
FieldExecType::TAG,
FieldOrdStatus::TAG,
FieldOrdRejReason::TAG,
FieldAccount::TAG,
FieldSymbol::TAG,
FieldSecurityID::TAG,
FieldSecurityType::TAG,
FieldText::TAG,
FieldProduct::TAG,
FieldSide::TAG,
FieldQtyType::TAG,
FieldOrderQty::TAG,
FieldOrdType::TAG,
FieldPriceType::TAG,
FieldPrice::TAG,
FieldStopPx::TAG,
FieldCurrency::TAG,
FieldTimeInForce::TAG,
FieldExecInst::TAG,
FieldLastQty::TAG,
FieldLastPx::TAG,
FieldLeavesQty::TAG,
FieldAvgPx::TAG,
FieldCumQty::TAG,
FieldNoLegs::TAG,
FieldCheckSum::TAG };

}


const std::vector<tag_t> & MessageHeader::getKnownFields(){ return Header_knownFields; }

const std::vector<tag_t> & MessageNewOrderSingle::getKnownFields(){ return NewOrderSingle_knownFields; }

const std::vector<tag_t> & MessageExecutionReport::getKnownFields(){ return ExecutionReport_knownFields; }


GetDepthMethod getTagDepthMethodByRawMsgType( raw_enum_t rawMsgType ){
  switch( rawMsgType ){

   case MsgTypeRaw__ :
     return MessageHeader::getFieldDepth;

   case MsgTypeRaw_NEW_ORDER_SINGLE :
     return MessageNewOrderSingle::getFieldDepth;

   case MsgTypeRaw_EXECUTION_REPORT :
     return MessageExecutionReport::getFieldDepth;
  }
  return nullptr;
}


// -------------------------------------- reset ----------------------------------------

void MessageHeader::reset(){
     buf = nullptr;
     fieldBeginString.offset = -1;
     fieldBodyLength.offset = -1;
     fieldMsgType.offset = -1;
     fieldSenderCompID.offset = -1;
     fieldTargetCompID.offset = -1;
     fieldMsgSeqNum.offset = -1;
     fieldSendingTime.offset = -1;
     fieldCheckSum.offset = -1;
}

void MessageNewOrderSingle::reset(){
     buf = nullptr;
     fieldClOrdID.offset = -1;
     fieldAccount.offset = -1;
     fieldSymbol.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSide.offset = -1;
     fieldQtyType.offset = -1;
     fieldOrderQty.offset = -1;
     fieldOrdType.offset = -1;
     fieldPrice.offset = -1;
     fieldStopPx.offset = -1;
     fieldTransactTime.offset = -1;
     fieldCheckSum.offset = -1;
}

void MessageExecutionReport::reset(){
     buf = nullptr;
     fieldOrderID.offset = -1;
     fieldClOrdID.offset = -1;
     fieldOrigClOrdID.offset = -1;
     fieldExecID.offset = -1;
     fieldExecType.offset = -1;
     fieldOrdStatus.offset = -1;
     fieldOrdRejReason.offset = -1;
     fieldAccount.offset = -1;
     fieldSymbol.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityType.offset = -1;
     fieldText.offset = -1;
     fieldProduct.offset = -1;
     fieldSide.offset = -1;
     fieldQtyType.offset = -1;
     fieldOrderQty.offset = -1;
     fieldOrdType.offset = -1;
     fieldPriceType.offset = -1;
     fieldPrice.offset = -1;
     fieldStopPx.offset = -1;
     fieldCurrency.offset = -1;
     fieldTimeInForce.offset = -1;
     fieldExecInst.offset = -1;
     fieldLastQty.offset = -1;
     fieldLastPx.offset = -1;
     fieldLeavesQty.offset = -1;
     fieldAvgPx.offset = -1;
     fieldCumQty.offset = -1;
     for( auto g = groupsLegs.begin(); g != groupsLegs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldCheckSum.offset = -1;
}


// -------------------------------------- ParserDispatcher ----------------------------------------


const char * ParserDispatcher::parseAndDipatch( const char * buf, unsigned len, bool resetMessage )
{
    if( resetMessage )
    {
        _msgHeader.reset();
    }
    offset_t pos = _msgHeader.scan( buf, len );

    unsigned bodyLength = _msgHeader.getBodyLength();
    const char * endOfMessage = _msgHeader.ptrToMsgType() + bodyLength + 4; // 7 for checkSum - 3 for msg type tag
    if( endOfMessage - buf > len )
    {
        return nullptr;
    }

    const raw_enum_t msgType = toRawEnum( _msgHeader.ptrToMsgType() );
    if( ignoreMessage( msgType ) )
    {
      return endOfMessage;
    }

    buf += pos;
    switch( msgType )
    {


// case-begin-_
// After generation one can sed this out if _ is not incoming message
      case MsgTypeRaw__ : {
       if( resetMessage ) _msgHeader.reset();
       pos = _msgHeader.scan( buf, len - pos );
       onMessage( _msgHeader );
       break;
      }
// case-end-_


// case-begin-NEW_ORDER_SINGLE
// After generation one can sed this out if NEW_ORDER_SINGLE is not incoming message
      case MsgTypeRaw_NEW_ORDER_SINGLE : {
       if( resetMessage ) _msgNewOrderSingle.reset();
       pos = _msgNewOrderSingle.scan( buf, len - pos );
       onMessage( _msgNewOrderSingle );
       break;
      }
// case-end-NEW_ORDER_SINGLE


// case-begin-EXECUTION_REPORT
// After generation one can sed this out if EXECUTION_REPORT is not incoming message
      case MsgTypeRaw_EXECUTION_REPORT : {
       if( resetMessage ) _msgExecutionReport.reset();
       pos = _msgExecutionReport.scan( buf, len - pos );
       onMessage( _msgExecutionReport );
       break;
      }
// case-end-EXECUTION_REPORT


      default:
        onUnknownMessage( msgType );
        return endOfMessage;
    }
    return buf + pos;
}

void ParserDispatcher::onMessage( MessageHeader & msg )
{
   unprocessedMessage( MsgTypeRaw__, msg ); 
   msg.reset(); 
}


void ParserDispatcher::onMessage( MessageNewOrderSingle & msg )
{
   unprocessedMessage( MsgTypeRaw_NEW_ORDER_SINGLE, msg ); 
   msg.reset(); 
}


void ParserDispatcher::onMessage( MessageExecutionReport & msg )
{
   unprocessedMessage( MsgTypeRaw_EXECUTION_REPORT, msg ); 
   msg.reset(); 
}


// end of Messages.cxx


ParserDispatcher::ParserDispatcher()
{
}

ParserDispatcher::~ParserDispatcher()
{
}

void ParserDispatcher::onUnknownMessage( raw_enum_t msgType )
{
}

bool ParserDispatcher::ignoreMessage( raw_enum_t msgType ) const
{
    return false;
}

void ParserDispatcher::unprocessedMessage( raw_enum_t msgType, MessageBase & msg )
{
}

std::set< raw_tag_t > headerRawTags =
{
// start of HeaderRaw.cxx
 FieldBeginString::RAW_TAG,
 FieldBodyLength::RAW_TAG,
 FieldMsgType::RAW_TAG,
 FieldSenderCompID::RAW_TAG,
 FieldTargetCompID::RAW_TAG,
 FieldMsgSeqNum::RAW_TAG,
 FieldSendingTime::RAW_TAG,
// end of HeaderRaw.cxx
};

const FixFormatStyle defaultStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = " ",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "",
    .tagNameStop        = "",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "",
    .unknownStop        = ""
};

const FixFormatStyle defaultVerticalStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " *",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "",
    .tagNameStop        = "",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "",
    .unknownStop        = ""
};

const FixFormatStyle ttyStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " \u2022",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "\e[1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

const FixFormatStyle ttyRgbStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " \u2022",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "\e[33m",
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = "\e[33;1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "(\e[37;1m",
    .tagValueStop       = "\e[0m)",
    .equal              = " = ",
    .valueStart         = "\e[34;1m",
    .valueStop          = "\e[0m",
    .enumStart          = " \e[32m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

const FixFormatStyle ttyRgbSingleLineStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = "  ",
    .headerTagNameStart = "\e[33m",
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = "\e[33;1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "<\e[37;1m",
    .tagValueStop       = "\e[0m>",
    .equal              = "=",
    .valueStart         = "\e[34;1m",
    .valueStop          = "\e[0m",
    .enumStart          = "/\e[32m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

// no tag names
const FixFormatStyle ttyRgbRawStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = " ",
    .headerTagNameStart = nullptr,
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = nullptr,
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "\e[93;1m",
    .tagValueStop       = "\e[0m",
    .equal              = "=",
    .valueStart         = "\e[37;1m",
    .valueStop          = "\e[0m",
    .enumStart          = "/\e[92m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

// msgTypePos = offset of 35=
unsigned parseMessageLength( const char * fix, unsigned & msgTypePos )
{
    unsigned bodyLengthPos = msgTypePos = FixBeginStringValue.size() + 5; // 8=| + 9=|
    return parseUInt( fix + bodyLengthPos, ++msgTypePos );
}


unsigned computeChecksum( const char * begin, const char * end )
{
    unsigned sum = 0;
    while( begin < end )
    {
        sum += (unsigned)*begin++;
    }
    return sum & 0xff;
}

const char * getEnumName( const char * fix, int valueOffset )
{
    if( valueOffset < 0 )
    {
        return nullptr;
    }

    offset_t pos = (offset_t)valueOffset;
    while( pos > 0 and fix[pos-1] != FIXPP_SOH )
    {
        --pos;
    }

    const raw_tag_t tag = loadRawTag( fix+pos, pos );
    if( tag == 0 )
    {
        return nullptr;
    }

    auto eit = RAW_TO_ENUM.find( tag );
    if( eit == RAW_TO_ENUM.end() )
    {
        return nullptr;
    }
    const FieldEnumsBase * enums = eit->second;
    raw_enum_t rawEnum = toRawEnum( fix + valueOffset );
    const char * enumName = enums->getEnumNameByRaw( rawEnum );
    return enumName;
}

std::ostream & fixToHuman( const char * fix, offset_t & pos, std::ostream & os, const FixFormatStyle & style, GetDepthMethod indentator )
{
    os << style.messageBegin;

    while( fix[pos] )
    {
        offset_t prev = pos;
        const raw_tag_t tag = loadRawTag( fix+pos, pos );

        if( tag == 0 )
        {
            os << style.unknownStart << "[bad tag at " << pos << "]" << style.unknownStop << style.messageEnd;
            return os;
        }

        os << style.fieldBegin;

        auto it = RAW_TAG_TO_NAME.find( tag );
        const FieldEnumsBase * enums = nullptr;
        if( it != RAW_TAG_TO_NAME.end() )
        {
            if( headerRawTags.find( tag ) != headerRawTags.end() )
            {
                if( style.headerTagNameStart )
                {
                    os << style.headerTagNameStart << it->second << style.headerTagNameStop;
                }
            }
            else
            {
                if( indentator and indentator != autoIndentFields )
                {
                    FieldDepth fd = (*indentator)( tag );
                    if( fd.isFirstInGroup )
                    {
                        for( int d = 1; d < fd.depth; ++d ) os << style.indent;
                        os << style.groupFirstField;
                    }
                    else
                    {
                        for( int d = 0; d < fd.depth; ++d ) os << style.indent;
                    }
                }
                if( style.tagNameStart )
                {
                    os << style.tagNameStart << it->second << style.tagNameStop;
                }
            }

            auto eit = RAW_TO_ENUM.find( tag );
            if( eit != RAW_TO_ENUM.end() )
            {
                enums = eit->second;
            }
        }
        else
        {
            os << style.unknownStart << " ?" << style.unknownStop;
        }

        // tag
        os << style.tagValueStart;
        while( fix[prev] != '=' )
        {
            os << fix[prev++];
        }
        os << style.tagValueStop << style.equal << style.valueStart;

        raw_enum_t rawEnum = toRawEnum( fix + pos );

        // value as is
        while( fix[pos] and fix[pos] != FIXPP_SOH )
        {
            os << fix[pos++];
        }

        os << style.valueStop;

        // enum
        if( enums and style.enumStart )
        {
            const char * enumName = enums->getEnumNameByRaw( rawEnum );
            if( enumName )
            {
                os << style.enumStart << enumName << style.enumStop;
            }
            else
            {
                os << style.unknownStart << " UNKNOWN" << style.unknownStop;
            }

            if( tag == FieldMsgType::RAW_TAG and indentator == autoIndentFields )
            {
                indentator = getTagDepthMethodByRawMsgType( rawEnum );
            }

        }

        os << style.fieldEnd;
        os.flush();

        ++pos;
        if( tag == FieldCheckSum::RAW_TAG )
        {
            break;
        }

    }
    os << style.messageEnd;
    return os;
}

} // namespace order

// gdb helper
extern "C" const char * fixppGetEnumName( const char * fix, int valueOffset )
{
    return order::getEnumName( fix, valueOffset );
}
