
// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <order/Groups.h>

namespace order
{

// start of Groups.cxx

// Generated

// -------------------------------------- getMessageName -------------------------------
const char * GroupLegStipulations::getMessageName(){
     return "LegStipulations";
}


const char * GroupNestedPartySubIDs::getMessageName(){
     return "NestedPartySubIDs";
}


const char * GroupNestedPartyIDs::getMessageName(){
     return "NestedPartyIDs";
}


const char * GroupLegs::getMessageName(){
     return "Legs";
}


// -------------------------------------- constructor ----------------------------------------
GroupLegStipulations::GroupLegStipulations(){

}

GroupNestedPartySubIDs::GroupNestedPartySubIDs(){

}

GroupNestedPartyIDs::GroupNestedPartyIDs(){

     groupsNestedPartySubIDs.assign( 10, {} );

}

GroupLegs::GroupLegs(){

     groupsLegStipulations.assign( 10, {} );

     groupsNestedPartyIDs.assign( 10, {} );

}


// -------------------------------------- scan ----------------------------------------
offset_t GroupLegStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationValue)
     group->fieldLegStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     group->fieldNestedPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     group->fieldNestedPartyIDSource.offset = gpos;
     break;

   case FieldNestedPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyRole)
     group->fieldNestedPartyRole.offset = gpos;
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs)
     group->fieldNoNestedPartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::scan( group->groupsNestedPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSide::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSide)
     group->fieldLegSide.offset = gpos;
     break;

   case FieldLegQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegQty)
     group->fieldLegQty.offset = gpos;
     break;

   case FieldNoLegStipulations::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegStipulations)
     group->fieldNoLegStipulations.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::scan( group->groupsLegStipulations, fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPositionEffect)
     group->fieldLegPositionEffect.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRefID)
     group->fieldLegRefID.offset = gpos;
     break;

   case FieldLegPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPrice)
     group->fieldLegPrice.offset = gpos;
     break;

   case FieldLegLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LegLastPx)
     group->fieldLegLastPx.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}


// -------------------------------------- skip ----------------------------------------
offset_t GroupLegStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     break;

   case FieldLegStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     break;

   case FieldNestedPartyRole::RAW_TAG :
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     break;

   case FieldLegSide::RAW_TAG :
     break;

   case FieldLegQty::RAW_TAG :
     break;

   case FieldNoLegStipulations::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::skip( fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     break;

   case FieldLegPrice::RAW_TAG :
     break;

   case FieldLegLastPx::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}


// ---------------------------------- getFieldDepth ---------------------------------
GetDepthMethod GroupLegStipulations::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartyIDs::groupGetDepthMethods[] = {
   GroupNestedPartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupLegs::groupGetDepthMethods[] = {
   GroupLegStipulations::getFieldDepth,
   GroupNestedPartyIDs::getFieldDepth,
   nullptr };


FieldDepth GroupLegStipulations::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegStipulationType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegStipulationValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartyIDSource::RAW_TAG :
     case FieldNestedPartyRole::RAW_TAG :
     case FieldNoNestedPartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLegs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegSide::RAW_TAG :
     case FieldLegQty::RAW_TAG :
     case FieldNoLegStipulations::RAW_TAG :
     case FieldLegPositionEffect::RAW_TAG :
     case FieldNoNestedPartyIDs::RAW_TAG :
     case FieldLegRefID::RAW_TAG :
     case FieldLegPrice::RAW_TAG :
     case FieldLegLastPx::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}


// ---------------------------------- getFieldValue ---------------------------------
const char * GroupLegStipulations::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegStipulationType::TAG : return fieldLegStipulationType.offset > 0 ? _fixPtr + fieldLegStipulationType.offset : nullptr;
     case FieldLegStipulationValue::TAG : return fieldLegStipulationValue.offset > 0 ? _fixPtr + fieldLegStipulationValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartySubID::TAG : return fieldNestedPartySubID.offset > 0 ? _fixPtr + fieldNestedPartySubID.offset : nullptr;
     case FieldNestedPartySubIDType::TAG : return fieldNestedPartySubIDType.offset > 0 ? _fixPtr + fieldNestedPartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartyID::TAG : return fieldNestedPartyID.offset > 0 ? _fixPtr + fieldNestedPartyID.offset : nullptr;
     case FieldNestedPartyIDSource::TAG : return fieldNestedPartyIDSource.offset > 0 ? _fixPtr + fieldNestedPartyIDSource.offset : nullptr;
     case FieldNestedPartyRole::TAG : return fieldNestedPartyRole.offset > 0 ? _fixPtr + fieldNestedPartyRole.offset : nullptr;
     case FieldNoNestedPartySubIDs::TAG : return fieldNoNestedPartySubIDs.offset > 0 ? _fixPtr + fieldNoNestedPartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLegs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegSymbol::TAG : return fieldLegSymbol.offset > 0 ? _fixPtr + fieldLegSymbol.offset : nullptr;
     case FieldLegSide::TAG : return fieldLegSide.offset > 0 ? _fixPtr + fieldLegSide.offset : nullptr;
     case FieldLegQty::TAG : return fieldLegQty.offset > 0 ? _fixPtr + fieldLegQty.offset : nullptr;
     case FieldNoLegStipulations::TAG : return fieldNoLegStipulations.offset > 0 ? _fixPtr + fieldNoLegStipulations.offset : nullptr;
     case FieldLegPositionEffect::TAG : return fieldLegPositionEffect.offset > 0 ? _fixPtr + fieldLegPositionEffect.offset : nullptr;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0 ? _fixPtr + fieldNoNestedPartyIDs.offset : nullptr;
     case FieldLegRefID::TAG : return fieldLegRefID.offset > 0 ? _fixPtr + fieldLegRefID.offset : nullptr;
     case FieldLegPrice::TAG : return fieldLegPrice.offset > 0 ? _fixPtr + fieldLegPrice.offset : nullptr;
     case FieldLegLastPx::TAG : return fieldLegLastPx.offset > 0 ? _fixPtr + fieldLegLastPx.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}


// ---------------------------------- findBadGroup ---------------------------------
const char * GroupLegStipulations::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupLegs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoLegStipulations.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoLegStipulations.offset );
     unsigned received = 0;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth(); }
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth(); }
   }
   return nullptr;
}


// ---------------------------------- findBadField ---------------------------------
const char * GroupLegStipulations::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegStipulationValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStipulationValue.offset - 1 - FieldLegStipulationValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStipulationValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartySubIDType.offset - 1 - FieldNestedPartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyIDSource.offset - 1 - FieldNestedPartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNestedPartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyRole.offset - 1 - FieldNestedPartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupLegs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSide.offset - 1 - FieldLegSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSide.offset] == 1 ) return tagPtr;
   }
   if( fieldLegQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegQty.offset - 1 - FieldLegQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegQty.offset] == 1 ) return tagPtr;
   }
   if( fieldNoLegStipulations.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoLegStipulations.offset] == 1 ) return tagPtr;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegPositionEffect.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPositionEffect.offset - 1 - FieldLegPositionEffect::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPositionEffect.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRefID.offset - 1 - FieldLegRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRefID.offset] == 1 ) return tagPtr;
   }
   if( fieldLegPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPrice.offset - 1 - FieldLegPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldLegLastPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegLastPx.offset - 1 - FieldLegLastPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegLastPx.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}


// ---------------------------------- getKnownFields ---------------------------------
namespace {
const std::vector<unsigned> LegStipulations_knownFields = { FieldLegStipulationType::TAG
, FieldLegStipulationValue::TAG
};

const std::vector<unsigned> NestedPartySubIDs_knownFields = { FieldNestedPartySubID::TAG
, FieldNestedPartySubIDType::TAG
};

const std::vector<unsigned> NestedPartyIDs_knownFields = { FieldNestedPartyID::TAG
, FieldNestedPartyIDSource::TAG
, FieldNestedPartyRole::TAG
, FieldNoNestedPartySubIDs::TAG
};

const std::vector<unsigned> Legs_knownFields = { FieldLegSymbol::TAG
, FieldLegSide::TAG
, FieldLegQty::TAG
, FieldNoLegStipulations::TAG
, FieldLegPositionEffect::TAG
, FieldNoNestedPartyIDs::TAG
, FieldLegRefID::TAG
, FieldLegPrice::TAG
, FieldLegLastPx::TAG
};

}


const std::vector<unsigned> & GroupLegStipulations::getKnownFields(){ return LegStipulations_knownFields; }

const std::vector<unsigned> & GroupNestedPartySubIDs::getKnownFields(){ return NestedPartySubIDs_knownFields; }

const std::vector<unsigned> & GroupNestedPartyIDs::getKnownFields(){ return NestedPartyIDs_knownFields; }

const std::vector<unsigned> & GroupLegs::getKnownFields(){ return Legs_knownFields; }


// -------------------------------------- reset ----------------------------------------
void GroupLegStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegStipulationValue.offset = -1;
}

void GroupNestedPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartySubIDType.offset = -1;
}

void GroupNestedPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartyIDSource.offset = -1;
     fieldNestedPartyRole.offset = -1;
     for( auto g = groupsNestedPartySubIDs.begin(); g != groupsNestedPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupLegs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSide.offset = -1;
     fieldLegQty.offset = -1;
     for( auto g = groupsLegStipulations.begin(); g != groupsLegStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegPositionEffect.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegRefID.offset = -1;
     fieldLegPrice.offset = -1;
     fieldLegLastPx.offset = -1;
}
// end of Groups.cxx

} // namespace order
