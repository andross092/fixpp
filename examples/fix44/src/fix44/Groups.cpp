
// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <fix44/Groups.h>

namespace fix44
{

// start of Groups.cxx

// Generated

// -------------------------------------- getMessageName -------------------------------

const char * GroupLegStipulations::getMessageName(){
     return "LegStipulations";
}


const char * GroupEvents::getMessageName(){
     return "Events";
}


const char * GroupLegSecurityAltID::getMessageName(){
     return "LegSecurityAltID";
}


const char * GroupCapacities::getMessageName(){
     return "Capacities";
}


const char * GroupNested3PartySubIDs::getMessageName(){
     return "Nested3PartySubIDs";
}


const char * GroupPartySubIDs::getMessageName(){
     return "PartySubIDs";
}


const char * GroupNested2PartySubIDs::getMessageName(){
     return "Nested2PartySubIDs";
}


const char * GroupNested2PartyIDs::getMessageName(){
     return "Nested2PartyIDs";
}


const char * GroupHops::getMessageName(){
     return "Hops";
}


const char * GroupCollInquiryQualifier::getMessageName(){
     return "CollInquiryQualifier";
}


const char * GroupPartyIDs::getMessageName(){
     return "PartyIDs";
}


const char * GroupAllocs::getMessageName(){
     return "Allocs";
}


const char * GroupTradingSessions::getMessageName(){
     return "TradingSessions";
}


const char * GroupSecurityAltID::getMessageName(){
     return "SecurityAltID";
}


const char * GroupUnderlyingSecurityAltID::getMessageName(){
     return "UnderlyingSecurityAltID";
}


const char * GroupUnderlyingStips::getMessageName(){
     return "UnderlyingStips";
}


const char * GroupUnderlyings::getMessageName(){
     return "Underlyings";
}


const char * GroupStipulations::getMessageName(){
     return "Stipulations";
}


const char * GroupOrders::getMessageName(){
     return "Orders";
}


const char * GroupSettlPartySubIDs::getMessageName(){
     return "SettlPartySubIDs";
}


const char * GroupSettlPartyIDs::getMessageName(){
     return "SettlPartyIDs";
}


const char * GroupDlvyInst::getMessageName(){
     return "DlvyInst";
}


const char * GroupClearingInstructions::getMessageName(){
     return "ClearingInstructions";
}


const char * GroupNestedPartySubIDs::getMessageName(){
     return "NestedPartySubIDs";
}


const char * GroupNestedPartyIDs::getMessageName(){
     return "NestedPartyIDs";
}


const char * GroupLegs::getMessageName(){
     return "Legs";
}


const char * GroupQuoteEntries::getMessageName(){
     return "QuoteEntries";
}


const char * GroupQuoteSets::getMessageName(){
     return "QuoteSets";
}


const char * GroupSecurityTypes::getMessageName(){
     return "SecurityTypes";
}


const char * GroupNested3PartyIDs::getMessageName(){
     return "Nested3PartyIDs";
}


const char * GroupPositions::getMessageName(){
     return "Positions";
}


const char * GroupAffectedOrders::getMessageName(){
     return "AffectedOrders";
}


const char * GroupExecs::getMessageName(){
     return "Execs";
}


const char * GroupMsgTypes::getMessageName(){
     return "MsgTypes";
}


const char * GroupBidComponents::getMessageName(){
     return "BidComponents";
}


const char * GroupSettlInst::getMessageName(){
     return "SettlInst";
}


const char * GroupInstrAttrib::getMessageName(){
     return "InstrAttrib";
}


const char * GroupMiscFees::getMessageName(){
     return "MiscFees";
}


const char * GroupQuoteQualifiers::getMessageName(){
     return "QuoteQualifiers";
}


const char * GroupDistribInsts::getMessageName(){
     return "DistribInsts";
}


const char * GroupTrdRegTimestamps::getMessageName(){
     return "TrdRegTimestamps";
}


const char * GroupAltMDSource::getMessageName(){
     return "AltMDSource";
}


const char * GroupSides::getMessageName(){
     return "Sides";
}


const char * GroupRoutingIDs::getMessageName(){
     return "RoutingIDs";
}


const char * GroupPosAmt::getMessageName(){
     return "PosAmt";
}


const char * GroupLinesOfText::getMessageName(){
     return "LinesOfText";
}


const char * GroupIOIQualifiers::getMessageName(){
     return "IOIQualifiers";
}


const char * GroupDates::getMessageName(){
     return "Dates";
}


const char * GroupMDEntryTypes::getMessageName(){
     return "MDEntryTypes";
}


const char * GroupRelatedSym::getMessageName(){
     return "RelatedSym";
}


const char * GroupContraBrokers::getMessageName(){
     return "ContraBrokers";
}


const char * GroupTrades::getMessageName(){
     return "Trades";
}


const char * GroupStrikes::getMessageName(){
     return "Strikes";
}


const char * GroupBidDescriptors::getMessageName(){
     return "BidDescriptors";
}


const char * GroupCompIDs::getMessageName(){
     return "CompIDs";
}


const char * GroupLegAllocs::getMessageName(){
     return "LegAllocs";
}


const char * GroupRegistDtls::getMessageName(){
     return "RegistDtls";
}


const char * GroupContAmts::getMessageName(){
     return "ContAmts";
}


const char * GroupMDEntries::getMessageName(){
     return "MDEntries";
}


// -------------------------------------- constructor ----------------------------------------

GroupLegStipulations::GroupLegStipulations(){

}

GroupEvents::GroupEvents(){

}

GroupLegSecurityAltID::GroupLegSecurityAltID(){

}

GroupCapacities::GroupCapacities(){

}

GroupNested3PartySubIDs::GroupNested3PartySubIDs(){

}

GroupPartySubIDs::GroupPartySubIDs(){

}

GroupNested2PartySubIDs::GroupNested2PartySubIDs(){

}

GroupNested2PartyIDs::GroupNested2PartyIDs(){

     groupsNested2PartySubIDs.assign( 10, {} );

}

GroupHops::GroupHops(){

}

GroupCollInquiryQualifier::GroupCollInquiryQualifier(){

}

GroupPartyIDs::GroupPartyIDs(){

     groupsPartySubIDs.assign( 10, {} );

}

GroupAllocs::GroupAllocs(){

}

GroupTradingSessions::GroupTradingSessions(){

}

GroupSecurityAltID::GroupSecurityAltID(){

}

GroupUnderlyingSecurityAltID::GroupUnderlyingSecurityAltID(){

}

GroupUnderlyingStips::GroupUnderlyingStips(){

}

GroupUnderlyings::GroupUnderlyings(){

     groupsUnderlyingSecurityAltID.assign( 10, {} );

     groupsUnderlyingStips.assign( 10, {} );

}

GroupStipulations::GroupStipulations(){

}

GroupOrders::GroupOrders(){

     groupsPartyIDs.assign( 10, {} );

     groupsAllocs.assign( 10, {} );

     groupsTradingSessions.assign( 10, {} );

     groupsSecurityAltID.assign( 10, {} );

     groupsEvents.assign( 10, {} );

     groupsUnderlyings.assign( 10, {} );

     groupsStipulations.assign( 10, {} );

}

GroupSettlPartySubIDs::GroupSettlPartySubIDs(){

}

GroupSettlPartyIDs::GroupSettlPartyIDs(){

     groupsSettlPartySubIDs.assign( 10, {} );

}

GroupDlvyInst::GroupDlvyInst(){

     groupsSettlPartyIDs.assign( 10, {} );

}

GroupClearingInstructions::GroupClearingInstructions(){

}

GroupNestedPartySubIDs::GroupNestedPartySubIDs(){

}

GroupNestedPartyIDs::GroupNestedPartyIDs(){

     groupsNestedPartySubIDs.assign( 10, {} );

}

GroupLegs::GroupLegs(){

     groupsLegSecurityAltID.assign( 10, {} );

     groupsLegStipulations.assign( 10, {} );

     groupsNestedPartyIDs.assign( 10, {} );

}

GroupQuoteEntries::GroupQuoteEntries(){

     groupsSecurityAltID.assign( 10, {} );

     groupsEvents.assign( 10, {} );

     groupsUnderlyings.assign( 10, {} );

     groupsLegs.assign( 10, {} );

}

GroupQuoteSets::GroupQuoteSets(){

     groupsUnderlyingSecurityAltID.assign( 10, {} );

     groupsUnderlyingStips.assign( 10, {} );

     groupsQuoteEntries.assign( 10, {} );

}

GroupSecurityTypes::GroupSecurityTypes(){

}

GroupNested3PartyIDs::GroupNested3PartyIDs(){

     groupsNested3PartySubIDs.assign( 10, {} );

}

GroupPositions::GroupPositions(){

     groupsNestedPartyIDs.assign( 10, {} );

}

GroupAffectedOrders::GroupAffectedOrders(){

}

GroupExecs::GroupExecs(){

}

GroupMsgTypes::GroupMsgTypes(){

}

GroupBidComponents::GroupBidComponents(){

}

GroupSettlInst::GroupSettlInst(){

     groupsPartyIDs.assign( 10, {} );

     groupsDlvyInst.assign( 10, {} );

}

GroupInstrAttrib::GroupInstrAttrib(){

}

GroupMiscFees::GroupMiscFees(){

}

GroupQuoteQualifiers::GroupQuoteQualifiers(){

}

GroupDistribInsts::GroupDistribInsts(){

}

GroupTrdRegTimestamps::GroupTrdRegTimestamps(){

}

GroupAltMDSource::GroupAltMDSource(){

}

GroupSides::GroupSides(){

     groupsPartyIDs.assign( 10, {} );

}

GroupRoutingIDs::GroupRoutingIDs(){

}

GroupPosAmt::GroupPosAmt(){

}

GroupLinesOfText::GroupLinesOfText(){

}

GroupIOIQualifiers::GroupIOIQualifiers(){

}

GroupDates::GroupDates(){

}

GroupMDEntryTypes::GroupMDEntryTypes(){

}

GroupRelatedSym::GroupRelatedSym(){

     groupsSecurityAltID.assign( 10, {} );

     groupsEvents.assign( 10, {} );

}

GroupContraBrokers::GroupContraBrokers(){

}

GroupTrades::GroupTrades(){

}

GroupStrikes::GroupStrikes(){

     groupsSecurityAltID.assign( 10, {} );

     groupsEvents.assign( 10, {} );

}

GroupBidDescriptors::GroupBidDescriptors(){

}

GroupCompIDs::GroupCompIDs(){

}

GroupLegAllocs::GroupLegAllocs(){

     groupsNested2PartyIDs.assign( 10, {} );

}

GroupRegistDtls::GroupRegistDtls(){

     groupsNestedPartyIDs.assign( 10, {} );

}

GroupContAmts::GroupContAmts(){

}

GroupMDEntries::GroupMDEntries(){

}


// -------------------------------------- scan ----------------------------------------

offset_t GroupLegStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationValue)
     group->fieldLegStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupEvents::scan( Array & arr, const char * fix, unsigned len ){
 GroupEvents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldEventType::RAW_TAG :
     FIXPP_PRINT_FIELD(EventType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldEventType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEventDate::RAW_TAG :
     FIXPP_PRINT_FIELD(EventDate)
     group->fieldEventDate.offset = gpos;
     break;

   case FieldEventPx::RAW_TAG :
     FIXPP_PRINT_FIELD(EventPx)
     group->fieldEventPx.offset = gpos;
     break;

   case FieldEventText::RAW_TAG :
     FIXPP_PRINT_FIELD(EventText)
     group->fieldEventText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSecurityAltIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityAltIDSource)
     group->fieldLegSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCapacities::scan( Array & arr, const char * fix, unsigned len ){
 GroupCapacities * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrderCapacity::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderCapacity)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrderCapacity.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrderRestrictions::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderRestrictions)
     group->fieldOrderRestrictions.offset = gpos;
     break;

   case FieldOrderCapacityQty::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderCapacityQty)
     group->fieldOrderCapacityQty.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested3PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested3PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested3PartySubIDType)
     group->fieldNested3PartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(PartySubIDType)
     group->fieldPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested2PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested2PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested2PartySubIDType)
     group->fieldNested2PartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested2PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested2PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested2PartyIDSource)
     group->fieldNested2PartyIDSource.offset = gpos;
     break;

   case FieldNested2PartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested2PartyRole)
     group->fieldNested2PartyRole.offset = gpos;
     break;

   case FieldNoNested2PartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNested2PartySubIDs)
     group->fieldNoNested2PartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartySubIDs::scan( group->groupsNested2PartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupHops::scan( Array & arr, const char * fix, unsigned len ){
 GroupHops * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldHopCompID::RAW_TAG :
     FIXPP_PRINT_FIELD(HopCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldHopCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldHopSendingTime::RAW_TAG :
     FIXPP_PRINT_FIELD(HopSendingTime)
     group->fieldHopSendingTime.offset = gpos;
     break;

   case FieldHopRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(HopRefID)
     group->fieldHopRefID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCollInquiryQualifier::scan( Array & arr, const char * fix, unsigned len ){
 GroupCollInquiryQualifier * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldCollInquiryQualifier::RAW_TAG :
     FIXPP_PRINT_FIELD(CollInquiryQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldCollInquiryQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(PartyIDSource)
     group->fieldPartyIDSource.offset = gpos;
     break;

   case FieldPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(PartyRole)
     group->fieldPartyRole.offset = gpos;
     break;

   case FieldNoPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoPartySubIDs)
     group->fieldNoPartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartySubIDs::scan( group->groupsPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAllocs::scan( Array & arr, const char * fix, unsigned len ){
 GroupAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAllocAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(AllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAllocAcctIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(AllocAcctIDSource)
     group->fieldAllocAcctIDSource.offset = gpos;
     break;

   case FieldAllocPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(AllocPrice)
     group->fieldAllocPrice.offset = gpos;
     break;

   case FieldIndividualAllocID::RAW_TAG :
     FIXPP_PRINT_FIELD(IndividualAllocID)
     group->fieldIndividualAllocID.offset = gpos;
     break;

   case FieldIndividualAllocRejCode::RAW_TAG :
     FIXPP_PRINT_FIELD(IndividualAllocRejCode)
     group->fieldIndividualAllocRejCode.offset = gpos;
     break;

   case FieldAllocText::RAW_TAG :
     FIXPP_PRINT_FIELD(AllocText)
     group->fieldAllocText.offset = gpos;
     break;

   case FieldEncodedAllocTextLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedAllocTextLen)
     group->fieldEncodedAllocTextLen.offset = gpos;
     break;

   case FieldEncodedAllocText::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedAllocText)
     group->fieldEncodedAllocText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTradingSessions::scan( Array & arr, const char * fix, unsigned len ){
 GroupTradingSessions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradingSessionID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradingSessionID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecurityAltIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityAltIDSource)
     group->fieldSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyingSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSecurityAltIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltIDSource)
     group->fieldUnderlyingSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingStips::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyingStips * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingStipType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStipType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingStipType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingStipValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStipValue)
     group->fieldUnderlyingStipValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyings::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyings * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     group->fieldUnderlyingSymbolSfx.offset = gpos;
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     group->fieldUnderlyingSecurityID.offset = gpos;
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     group->fieldUnderlyingSecurityIDSource.offset = gpos;
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID)
     group->fieldNoUnderlyingSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::scan( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     group->fieldUnderlyingProduct.offset = gpos;
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     group->fieldUnderlyingCFICode.offset = gpos;
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     group->fieldUnderlyingSecurityType.offset = gpos;
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     group->fieldUnderlyingSecuritySubType.offset = gpos;
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     group->fieldUnderlyingMaturityDate.offset = gpos;
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     group->fieldUnderlyingPutOrCall.offset = gpos;
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     group->fieldUnderlyingIssueDate.offset = gpos;
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     group->fieldUnderlyingRepurchaseRate.offset = gpos;
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     group->fieldUnderlyingFactor.offset = gpos;
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     group->fieldUnderlyingCreditRating.offset = gpos;
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     group->fieldUnderlyingInstrRegistry.offset = gpos;
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     group->fieldUnderlyingCountryOfIssue.offset = gpos;
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     group->fieldUnderlyingRedemptionDate.offset = gpos;
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     group->fieldUnderlyingStrikePrice.offset = gpos;
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     group->fieldUnderlyingStrikeCurrency.offset = gpos;
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     group->fieldUnderlyingOptAttribute.offset = gpos;
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     group->fieldUnderlyingContractMultiplier.offset = gpos;
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     group->fieldUnderlyingCouponRate.offset = gpos;
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     group->fieldUnderlyingSecurityExchange.offset = gpos;
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     group->fieldUnderlyingIssuer.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     group->fieldEncodedUnderlyingIssuer.offset = gpos;
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     group->fieldUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     group->fieldEncodedUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     group->fieldUnderlyingCPProgram.offset = gpos;
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     group->fieldUnderlyingCPRegType.offset = gpos;
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     group->fieldUnderlyingCurrency.offset = gpos;
     break;

   case FieldUnderlyingQty::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingQty)
     group->fieldUnderlyingQty.offset = gpos;
     break;

   case FieldUnderlyingPx::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingPx)
     group->fieldUnderlyingPx.offset = gpos;
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     group->fieldUnderlyingDirtyPrice.offset = gpos;
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     group->fieldUnderlyingEndPrice.offset = gpos;
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     group->fieldUnderlyingStartValue.offset = gpos;
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     group->fieldUnderlyingCurrentValue.offset = gpos;
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     group->fieldUnderlyingEndValue.offset = gpos;
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyingStips)
     group->fieldNoUnderlyingStips.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::scan( group->groupsUnderlyingStips, fix+pos, len - pos );
     break;

   case FieldUnderlyingSettlPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSettlPrice)
     group->fieldUnderlyingSettlPrice.offset = gpos;
     break;

   case FieldUnderlyingSettlPriceType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSettlPriceType)
     group->fieldUnderlyingSettlPriceType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldStipulationType::RAW_TAG :
     FIXPP_PRINT_FIELD(StipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldStipulationValue::RAW_TAG :
     FIXPP_PRINT_FIELD(StipulationValue)
     group->fieldStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupOrders::scan( Array & arr, const char * fix, unsigned len ){
 GroupOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     group->fieldSecondaryClOrdID.offset = gpos;
     break;

   case FieldListSeqNo::RAW_TAG :
     FIXPP_PRINT_FIELD(ListSeqNo)
     group->fieldListSeqNo.offset = gpos;
     break;

   case FieldClOrdLinkID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     group->fieldClOrdLinkID.offset = gpos;
     break;

   case FieldSettlInstMode::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlInstMode)
     group->fieldSettlInstMode.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     group->fieldTradeOriginationDate.offset = gpos;
     break;

   case FieldTradeDate::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeDate)
     group->fieldTradeDate.offset = gpos;
     break;

   case FieldAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(Account)
     group->fieldAccount.offset = gpos;
     break;

   case FieldAcctIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(AcctIDSource)
     group->fieldAcctIDSource.offset = gpos;
     break;

   case FieldAccountType::RAW_TAG :
     FIXPP_PRINT_FIELD(AccountType)
     group->fieldAccountType.offset = gpos;
     break;

   case FieldDayBookingInst::RAW_TAG :
     FIXPP_PRINT_FIELD(DayBookingInst)
     group->fieldDayBookingInst.offset = gpos;
     break;

   case FieldBookingUnit::RAW_TAG :
     FIXPP_PRINT_FIELD(BookingUnit)
     group->fieldBookingUnit.offset = gpos;
     break;

   case FieldAllocID::RAW_TAG :
     FIXPP_PRINT_FIELD(AllocID)
     group->fieldAllocID.offset = gpos;
     break;

   case FieldPreallocMethod::RAW_TAG :
     FIXPP_PRINT_FIELD(PreallocMethod)
     group->fieldPreallocMethod.offset = gpos;
     break;

   case FieldNoAllocs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoAllocs)
     group->fieldNoAllocs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupAllocs::scan( group->groupsAllocs, fix+pos, len - pos );
     break;

   case FieldSettlType::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlType)
     group->fieldSettlType.offset = gpos;
     break;

   case FieldSettlDate::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlDate)
     group->fieldSettlDate.offset = gpos;
     break;

   case FieldCashMargin::RAW_TAG :
     FIXPP_PRINT_FIELD(CashMargin)
     group->fieldCashMargin.offset = gpos;
     break;

   case FieldClearingFeeIndicator::RAW_TAG :
     FIXPP_PRINT_FIELD(ClearingFeeIndicator)
     group->fieldClearingFeeIndicator.offset = gpos;
     break;

   case FieldHandlInst::RAW_TAG :
     FIXPP_PRINT_FIELD(HandlInst)
     group->fieldHandlInst.offset = gpos;
     break;

   case FieldExecInst::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecInst)
     group->fieldExecInst.offset = gpos;
     break;

   case FieldMinQty::RAW_TAG :
     FIXPP_PRINT_FIELD(MinQty)
     group->fieldMinQty.offset = gpos;
     break;

   case FieldMaxFloor::RAW_TAG :
     FIXPP_PRINT_FIELD(MaxFloor)
     group->fieldMaxFloor.offset = gpos;
     break;

   case FieldExDestination::RAW_TAG :
     FIXPP_PRINT_FIELD(ExDestination)
     group->fieldExDestination.offset = gpos;
     break;

   case FieldNoTradingSessions::RAW_TAG :
     FIXPP_PRINT_FIELD(NoTradingSessions)
     group->fieldNoTradingSessions.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupTradingSessions::scan( group->groupsTradingSessions, fix+pos, len - pos );
     break;

   case FieldProcessCode::RAW_TAG :
     FIXPP_PRINT_FIELD(ProcessCode)
     group->fieldProcessCode.offset = gpos;
     break;

   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol)
     group->fieldSymbol.offset = gpos;
     break;

   case FieldSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuer)
     group->fieldEncodedIssuer.offset = gpos;
     break;

   case FieldSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     group->fieldEncodedSecurityDesc.offset = gpos;
     break;

   case FieldPool::RAW_TAG :
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG :
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   case FieldNoUnderlyings::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyings)
     group->fieldNoUnderlyings.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::scan( group->groupsUnderlyings, fix+pos, len - pos );
     break;

   case FieldPrevClosePx::RAW_TAG :
     FIXPP_PRINT_FIELD(PrevClosePx)
     group->fieldPrevClosePx.offset = gpos;
     break;

   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldSideValueInd::RAW_TAG :
     FIXPP_PRINT_FIELD(SideValueInd)
     group->fieldSideValueInd.offset = gpos;
     break;

   case FieldLocateReqd::RAW_TAG :
     FIXPP_PRINT_FIELD(LocateReqd)
     group->fieldLocateReqd.offset = gpos;
     break;

   case FieldTransactTime::RAW_TAG :
     FIXPP_PRINT_FIELD(TransactTime)
     group->fieldTransactTime.offset = gpos;
     break;

   case FieldNoStipulations::RAW_TAG :
     FIXPP_PRINT_FIELD(NoStipulations)
     group->fieldNoStipulations.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupStipulations::scan( group->groupsStipulations, fix+pos, len - pos );
     break;

   case FieldQtyType::RAW_TAG :
     FIXPP_PRINT_FIELD(QtyType)
     group->fieldQtyType.offset = gpos;
     break;

   case FieldOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderQty)
     group->fieldOrderQty.offset = gpos;
     break;

   case FieldCashOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(CashOrderQty)
     group->fieldCashOrderQty.offset = gpos;
     break;

   case FieldOrderPercent::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderPercent)
     group->fieldOrderPercent.offset = gpos;
     break;

   case FieldRoundingDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(RoundingDirection)
     group->fieldRoundingDirection.offset = gpos;
     break;

   case FieldRoundingModulus::RAW_TAG :
     FIXPP_PRINT_FIELD(RoundingModulus)
     group->fieldRoundingModulus.offset = gpos;
     break;

   case FieldOrdType::RAW_TAG :
     FIXPP_PRINT_FIELD(OrdType)
     group->fieldOrdType.offset = gpos;
     break;

   case FieldPriceType::RAW_TAG :
     FIXPP_PRINT_FIELD(PriceType)
     group->fieldPriceType.offset = gpos;
     break;

   case FieldPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(Price)
     group->fieldPrice.offset = gpos;
     break;

   case FieldStopPx::RAW_TAG :
     FIXPP_PRINT_FIELD(StopPx)
     group->fieldStopPx.offset = gpos;
     break;

   case FieldSpread::RAW_TAG :
     FIXPP_PRINT_FIELD(Spread)
     group->fieldSpread.offset = gpos;
     break;

   case FieldBenchmarkCurveCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkCurveCurrency)
     group->fieldBenchmarkCurveCurrency.offset = gpos;
     break;

   case FieldBenchmarkCurveName::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkCurveName)
     group->fieldBenchmarkCurveName.offset = gpos;
     break;

   case FieldBenchmarkCurvePoint::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkCurvePoint)
     group->fieldBenchmarkCurvePoint.offset = gpos;
     break;

   case FieldBenchmarkPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkPrice)
     group->fieldBenchmarkPrice.offset = gpos;
     break;

   case FieldBenchmarkPriceType::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkPriceType)
     group->fieldBenchmarkPriceType.offset = gpos;
     break;

   case FieldBenchmarkSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkSecurityID)
     group->fieldBenchmarkSecurityID.offset = gpos;
     break;

   case FieldBenchmarkSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(BenchmarkSecurityIDSource)
     group->fieldBenchmarkSecurityIDSource.offset = gpos;
     break;

   case FieldYieldType::RAW_TAG :
     FIXPP_PRINT_FIELD(YieldType)
     group->fieldYieldType.offset = gpos;
     break;

   case FieldYield::RAW_TAG :
     FIXPP_PRINT_FIELD(Yield)
     group->fieldYield.offset = gpos;
     break;

   case FieldYieldCalcDate::RAW_TAG :
     FIXPP_PRINT_FIELD(YieldCalcDate)
     group->fieldYieldCalcDate.offset = gpos;
     break;

   case FieldYieldRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(YieldRedemptionDate)
     group->fieldYieldRedemptionDate.offset = gpos;
     break;

   case FieldYieldRedemptionPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(YieldRedemptionPrice)
     group->fieldYieldRedemptionPrice.offset = gpos;
     break;

   case FieldYieldRedemptionPriceType::RAW_TAG :
     FIXPP_PRINT_FIELD(YieldRedemptionPriceType)
     group->fieldYieldRedemptionPriceType.offset = gpos;
     break;

   case FieldCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(Currency)
     group->fieldCurrency.offset = gpos;
     break;

   case FieldComplianceID::RAW_TAG :
     FIXPP_PRINT_FIELD(ComplianceID)
     group->fieldComplianceID.offset = gpos;
     break;

   case FieldSolicitedFlag::RAW_TAG :
     FIXPP_PRINT_FIELD(SolicitedFlag)
     group->fieldSolicitedFlag.offset = gpos;
     break;

   case FieldIOIID::RAW_TAG :
     FIXPP_PRINT_FIELD(IOIID)
     group->fieldIOIID.offset = gpos;
     break;

   case FieldQuoteID::RAW_TAG :
     FIXPP_PRINT_FIELD(QuoteID)
     group->fieldQuoteID.offset = gpos;
     break;

   case FieldTimeInForce::RAW_TAG :
     FIXPP_PRINT_FIELD(TimeInForce)
     group->fieldTimeInForce.offset = gpos;
     break;

   case FieldEffectiveTime::RAW_TAG :
     FIXPP_PRINT_FIELD(EffectiveTime)
     group->fieldEffectiveTime.offset = gpos;
     break;

   case FieldExpireDate::RAW_TAG :
     FIXPP_PRINT_FIELD(ExpireDate)
     group->fieldExpireDate.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG :
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldGTBookingInst::RAW_TAG :
     FIXPP_PRINT_FIELD(GTBookingInst)
     group->fieldGTBookingInst.offset = gpos;
     break;

   case FieldCommission::RAW_TAG :
     FIXPP_PRINT_FIELD(Commission)
     group->fieldCommission.offset = gpos;
     break;

   case FieldCommType::RAW_TAG :
     FIXPP_PRINT_FIELD(CommType)
     group->fieldCommType.offset = gpos;
     break;

   case FieldCommCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(CommCurrency)
     group->fieldCommCurrency.offset = gpos;
     break;

   case FieldFundRenewWaiv::RAW_TAG :
     FIXPP_PRINT_FIELD(FundRenewWaiv)
     group->fieldFundRenewWaiv.offset = gpos;
     break;

   case FieldOrderCapacity::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderCapacity)
     group->fieldOrderCapacity.offset = gpos;
     break;

   case FieldOrderRestrictions::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderRestrictions)
     group->fieldOrderRestrictions.offset = gpos;
     break;

   case FieldCustOrderCapacity::RAW_TAG :
     FIXPP_PRINT_FIELD(CustOrderCapacity)
     group->fieldCustOrderCapacity.offset = gpos;
     break;

   case FieldForexReq::RAW_TAG :
     FIXPP_PRINT_FIELD(ForexReq)
     group->fieldForexReq.offset = gpos;
     break;

   case FieldSettlCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlCurrency)
     group->fieldSettlCurrency.offset = gpos;
     break;

   case FieldBookingType::RAW_TAG :
     FIXPP_PRINT_FIELD(BookingType)
     group->fieldBookingType.offset = gpos;
     break;

   case FieldText::RAW_TAG :
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedText)
     group->fieldEncodedText.offset = gpos;
     break;

   case FieldSettlDate2::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlDate2)
     group->fieldSettlDate2.offset = gpos;
     break;

   case FieldOrderQty2::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderQty2)
     group->fieldOrderQty2.offset = gpos;
     break;

   case FieldPrice2::RAW_TAG :
     FIXPP_PRINT_FIELD(Price2)
     group->fieldPrice2.offset = gpos;
     break;

   case FieldPositionEffect::RAW_TAG :
     FIXPP_PRINT_FIELD(PositionEffect)
     group->fieldPositionEffect.offset = gpos;
     break;

   case FieldCoveredOrUncovered::RAW_TAG :
     FIXPP_PRINT_FIELD(CoveredOrUncovered)
     group->fieldCoveredOrUncovered.offset = gpos;
     break;

   case FieldMaxShow::RAW_TAG :
     FIXPP_PRINT_FIELD(MaxShow)
     group->fieldMaxShow.offset = gpos;
     break;

   case FieldPegOffsetValue::RAW_TAG :
     FIXPP_PRINT_FIELD(PegOffsetValue)
     group->fieldPegOffsetValue.offset = gpos;
     break;

   case FieldPegMoveType::RAW_TAG :
     FIXPP_PRINT_FIELD(PegMoveType)
     group->fieldPegMoveType.offset = gpos;
     break;

   case FieldPegOffsetType::RAW_TAG :
     FIXPP_PRINT_FIELD(PegOffsetType)
     group->fieldPegOffsetType.offset = gpos;
     break;

   case FieldPegLimitType::RAW_TAG :
     FIXPP_PRINT_FIELD(PegLimitType)
     group->fieldPegLimitType.offset = gpos;
     break;

   case FieldPegRoundDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(PegRoundDirection)
     group->fieldPegRoundDirection.offset = gpos;
     break;

   case FieldPegScope::RAW_TAG :
     FIXPP_PRINT_FIELD(PegScope)
     group->fieldPegScope.offset = gpos;
     break;

   case FieldDiscretionInst::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionInst)
     group->fieldDiscretionInst.offset = gpos;
     break;

   case FieldDiscretionOffsetValue::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionOffsetValue)
     group->fieldDiscretionOffsetValue.offset = gpos;
     break;

   case FieldDiscretionMoveType::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionMoveType)
     group->fieldDiscretionMoveType.offset = gpos;
     break;

   case FieldDiscretionOffsetType::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionOffsetType)
     group->fieldDiscretionOffsetType.offset = gpos;
     break;

   case FieldDiscretionLimitType::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionLimitType)
     group->fieldDiscretionLimitType.offset = gpos;
     break;

   case FieldDiscretionRoundDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionRoundDirection)
     group->fieldDiscretionRoundDirection.offset = gpos;
     break;

   case FieldDiscretionScope::RAW_TAG :
     FIXPP_PRINT_FIELD(DiscretionScope)
     group->fieldDiscretionScope.offset = gpos;
     break;

   case FieldTargetStrategy::RAW_TAG :
     FIXPP_PRINT_FIELD(TargetStrategy)
     group->fieldTargetStrategy.offset = gpos;
     break;

   case FieldTargetStrategyParameters::RAW_TAG :
     FIXPP_PRINT_FIELD(TargetStrategyParameters)
     group->fieldTargetStrategyParameters.offset = gpos;
     break;

   case FieldParticipationRate::RAW_TAG :
     FIXPP_PRINT_FIELD(ParticipationRate)
     group->fieldParticipationRate.offset = gpos;
     break;

   case FieldDesignation::RAW_TAG :
     FIXPP_PRINT_FIELD(Designation)
     group->fieldDesignation.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlPartySubIDType)
     group->fieldSettlPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlPartyIDSource)
     group->fieldSettlPartyIDSource.offset = gpos;
     break;

   case FieldSettlPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlPartyRole)
     group->fieldSettlPartyRole.offset = gpos;
     break;

   case FieldNoSettlPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSettlPartySubIDs)
     group->fieldNoSettlPartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartySubIDs::scan( group->groupsSettlPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDlvyInst::scan( Array & arr, const char * fix, unsigned len ){
 GroupDlvyInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlInstSource)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstSource.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDlvyInstType::RAW_TAG :
     FIXPP_PRINT_FIELD(DlvyInstType)
     group->fieldDlvyInstType.offset = gpos;
     break;

   case FieldNoSettlPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSettlPartyIDs)
     group->fieldNoSettlPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartyIDs::scan( group->groupsSettlPartyIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupClearingInstructions::scan( Array & arr, const char * fix, unsigned len ){
 GroupClearingInstructions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClearingInstruction::RAW_TAG :
     FIXPP_PRINT_FIELD(ClearingInstruction)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClearingInstruction.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     group->fieldNestedPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     group->fieldNestedPartyIDSource.offset = gpos;
     break;

   case FieldNestedPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyRole)
     group->fieldNestedPartyRole.offset = gpos;
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs)
     group->fieldNoNestedPartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::scan( group->groupsNestedPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSymbolSfx)
     group->fieldLegSymbolSfx.offset = gpos;
     break;

   case FieldLegSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityID)
     group->fieldLegSecurityID.offset = gpos;
     break;

   case FieldLegSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityIDSource)
     group->fieldLegSecurityIDSource.offset = gpos;
     break;

   case FieldNoLegSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegSecurityAltID)
     group->fieldNoLegSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegSecurityAltID::scan( group->groupsLegSecurityAltID, fix+pos, len - pos );
     break;

   case FieldLegProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(LegProduct)
     group->fieldLegProduct.offset = gpos;
     break;

   case FieldLegCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCFICode)
     group->fieldLegCFICode.offset = gpos;
     break;

   case FieldLegSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityType)
     group->fieldLegSecurityType.offset = gpos;
     break;

   case FieldLegSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecuritySubType)
     group->fieldLegSecuritySubType.offset = gpos;
     break;

   case FieldLegMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(LegMaturityMonthYear)
     group->fieldLegMaturityMonthYear.offset = gpos;
     break;

   case FieldLegMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegMaturityDate)
     group->fieldLegMaturityDate.offset = gpos;
     break;

   case FieldLegCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCouponPaymentDate)
     group->fieldLegCouponPaymentDate.offset = gpos;
     break;

   case FieldLegIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegIssueDate)
     group->fieldLegIssueDate.offset = gpos;
     break;

   case FieldLegRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRepoCollateralSecurityType)
     group->fieldLegRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldLegRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRepurchaseTerm)
     group->fieldLegRepurchaseTerm.offset = gpos;
     break;

   case FieldLegRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRepurchaseRate)
     group->fieldLegRepurchaseRate.offset = gpos;
     break;

   case FieldLegFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(LegFactor)
     group->fieldLegFactor.offset = gpos;
     break;

   case FieldLegCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCreditRating)
     group->fieldLegCreditRating.offset = gpos;
     break;

   case FieldLegInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(LegInstrRegistry)
     group->fieldLegInstrRegistry.offset = gpos;
     break;

   case FieldLegCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCountryOfIssue)
     group->fieldLegCountryOfIssue.offset = gpos;
     break;

   case FieldLegStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStateOrProvinceOfIssue)
     group->fieldLegStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLegLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegLocaleOfIssue)
     group->fieldLegLocaleOfIssue.offset = gpos;
     break;

   case FieldLegRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRedemptionDate)
     group->fieldLegRedemptionDate.offset = gpos;
     break;

   case FieldLegStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStrikePrice)
     group->fieldLegStrikePrice.offset = gpos;
     break;

   case FieldLegStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStrikeCurrency)
     group->fieldLegStrikeCurrency.offset = gpos;
     break;

   case FieldLegOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(LegOptAttribute)
     group->fieldLegOptAttribute.offset = gpos;
     break;

   case FieldLegContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(LegContractMultiplier)
     group->fieldLegContractMultiplier.offset = gpos;
     break;

   case FieldLegCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCouponRate)
     group->fieldLegCouponRate.offset = gpos;
     break;

   case FieldLegSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityExchange)
     group->fieldLegSecurityExchange.offset = gpos;
     break;

   case FieldLegIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(LegIssuer)
     group->fieldLegIssuer.offset = gpos;
     break;

   case FieldEncodedLegIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedLegIssuerLen)
     group->fieldEncodedLegIssuerLen.offset = gpos;
     break;

   case FieldEncodedLegIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedLegIssuer)
     group->fieldEncodedLegIssuer.offset = gpos;
     break;

   case FieldLegSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSecurityDesc)
     group->fieldLegSecurityDesc.offset = gpos;
     break;

   case FieldEncodedLegSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedLegSecurityDescLen)
     group->fieldEncodedLegSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedLegSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedLegSecurityDesc)
     group->fieldEncodedLegSecurityDesc.offset = gpos;
     break;

   case FieldLegRatioQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRatioQty)
     group->fieldLegRatioQty.offset = gpos;
     break;

   case FieldLegSide::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSide)
     group->fieldLegSide.offset = gpos;
     break;

   case FieldLegCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCurrency)
     group->fieldLegCurrency.offset = gpos;
     break;

   case FieldLegPool::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPool)
     group->fieldLegPool.offset = gpos;
     break;

   case FieldLegDatedDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegDatedDate)
     group->fieldLegDatedDate.offset = gpos;
     break;

   case FieldLegContractSettlMonth::RAW_TAG :
     FIXPP_PRINT_FIELD(LegContractSettlMonth)
     group->fieldLegContractSettlMonth.offset = gpos;
     break;

   case FieldLegInterestAccrualDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegInterestAccrualDate)
     group->fieldLegInterestAccrualDate.offset = gpos;
     break;

   case FieldLegQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegQty)
     group->fieldLegQty.offset = gpos;
     break;

   case FieldLegSwapType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSwapType)
     group->fieldLegSwapType.offset = gpos;
     break;

   case FieldNoLegStipulations::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegStipulations)
     group->fieldNoLegStipulations.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::scan( group->groupsLegStipulations, fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPositionEffect)
     group->fieldLegPositionEffect.offset = gpos;
     break;

   case FieldLegCoveredOrUncovered::RAW_TAG :
     FIXPP_PRINT_FIELD(LegCoveredOrUncovered)
     group->fieldLegCoveredOrUncovered.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRefID)
     group->fieldLegRefID.offset = gpos;
     break;

   case FieldLegPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPrice)
     group->fieldLegPrice.offset = gpos;
     break;

   case FieldLegSettlType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSettlType)
     group->fieldLegSettlType.offset = gpos;
     break;

   case FieldLegSettlDate::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSettlDate)
     group->fieldLegSettlDate.offset = gpos;
     break;

   case FieldLegLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LegLastPx)
     group->fieldLegLastPx.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteEntries::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuer)
     group->fieldEncodedIssuer.offset = gpos;
     break;

   case FieldSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     group->fieldEncodedSecurityDesc.offset = gpos;
     break;

   case FieldPool::RAW_TAG :
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG :
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   case FieldAgreementDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(AgreementDesc)
     group->fieldAgreementDesc.offset = gpos;
     break;

   case FieldAgreementID::RAW_TAG :
     FIXPP_PRINT_FIELD(AgreementID)
     group->fieldAgreementID.offset = gpos;
     break;

   case FieldAgreementDate::RAW_TAG :
     FIXPP_PRINT_FIELD(AgreementDate)
     group->fieldAgreementDate.offset = gpos;
     break;

   case FieldAgreementCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(AgreementCurrency)
     group->fieldAgreementCurrency.offset = gpos;
     break;

   case FieldTerminationType::RAW_TAG :
     FIXPP_PRINT_FIELD(TerminationType)
     group->fieldTerminationType.offset = gpos;
     break;

   case FieldStartDate::RAW_TAG :
     FIXPP_PRINT_FIELD(StartDate)
     group->fieldStartDate.offset = gpos;
     break;

   case FieldEndDate::RAW_TAG :
     FIXPP_PRINT_FIELD(EndDate)
     group->fieldEndDate.offset = gpos;
     break;

   case FieldDeliveryType::RAW_TAG :
     FIXPP_PRINT_FIELD(DeliveryType)
     group->fieldDeliveryType.offset = gpos;
     break;

   case FieldMarginRatio::RAW_TAG :
     FIXPP_PRINT_FIELD(MarginRatio)
     group->fieldMarginRatio.offset = gpos;
     break;

   case FieldNoUnderlyings::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyings)
     group->fieldNoUnderlyings.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::scan( group->groupsUnderlyings, fix+pos, len - pos );
     break;

   case FieldNoLegs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegs)
     group->fieldNoLegs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::scan( group->groupsLegs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteSets::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteSets * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteSetID::RAW_TAG :
     FIXPP_PRINT_FIELD(QuoteSetID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteSetID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     group->fieldUnderlyingSymbol.offset = gpos;
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     group->fieldUnderlyingSymbolSfx.offset = gpos;
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     group->fieldUnderlyingSecurityID.offset = gpos;
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     group->fieldUnderlyingSecurityIDSource.offset = gpos;
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID)
     group->fieldNoUnderlyingSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::scan( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     group->fieldUnderlyingProduct.offset = gpos;
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     group->fieldUnderlyingCFICode.offset = gpos;
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     group->fieldUnderlyingSecurityType.offset = gpos;
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     group->fieldUnderlyingSecuritySubType.offset = gpos;
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     group->fieldUnderlyingMaturityDate.offset = gpos;
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     group->fieldUnderlyingPutOrCall.offset = gpos;
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     group->fieldUnderlyingIssueDate.offset = gpos;
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     group->fieldUnderlyingRepurchaseRate.offset = gpos;
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     group->fieldUnderlyingFactor.offset = gpos;
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     group->fieldUnderlyingCreditRating.offset = gpos;
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     group->fieldUnderlyingInstrRegistry.offset = gpos;
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     group->fieldUnderlyingCountryOfIssue.offset = gpos;
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     group->fieldUnderlyingRedemptionDate.offset = gpos;
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     group->fieldUnderlyingStrikePrice.offset = gpos;
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     group->fieldUnderlyingStrikeCurrency.offset = gpos;
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     group->fieldUnderlyingOptAttribute.offset = gpos;
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     group->fieldUnderlyingContractMultiplier.offset = gpos;
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     group->fieldUnderlyingCouponRate.offset = gpos;
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     group->fieldUnderlyingSecurityExchange.offset = gpos;
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     group->fieldUnderlyingIssuer.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     group->fieldEncodedUnderlyingIssuer.offset = gpos;
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     group->fieldUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     group->fieldEncodedUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     group->fieldUnderlyingCPProgram.offset = gpos;
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     group->fieldUnderlyingCPRegType.offset = gpos;
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     group->fieldUnderlyingCurrency.offset = gpos;
     break;

   case FieldUnderlyingQty::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingQty)
     group->fieldUnderlyingQty.offset = gpos;
     break;

   case FieldUnderlyingPx::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingPx)
     group->fieldUnderlyingPx.offset = gpos;
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     group->fieldUnderlyingDirtyPrice.offset = gpos;
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     group->fieldUnderlyingEndPrice.offset = gpos;
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     group->fieldUnderlyingStartValue.offset = gpos;
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     group->fieldUnderlyingCurrentValue.offset = gpos;
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     group->fieldUnderlyingEndValue.offset = gpos;
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     FIXPP_PRINT_FIELD(NoUnderlyingStips)
     group->fieldNoUnderlyingStips.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::scan( group->groupsUnderlyingStips, fix+pos, len - pos );
     break;

   case FieldTotNoQuoteEntries::RAW_TAG :
     FIXPP_PRINT_FIELD(TotNoQuoteEntries)
     group->fieldTotNoQuoteEntries.offset = gpos;
     break;

   case FieldLastFragment::RAW_TAG :
     FIXPP_PRINT_FIELD(LastFragment)
     group->fieldLastFragment.offset = gpos;
     break;

   case FieldNoQuoteEntries::RAW_TAG :
     FIXPP_PRINT_FIELD(NoQuoteEntries)
     group->fieldNoQuoteEntries.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupQuoteEntries::scan( group->groupsQuoteEntries, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupSecurityTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested3PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested3PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested3PartyIDSource)
     group->fieldNested3PartyIDSource.offset = gpos;
     break;

   case FieldNested3PartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(Nested3PartyRole)
     group->fieldNested3PartyRole.offset = gpos;
     break;

   case FieldNoNested3PartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNested3PartySubIDs)
     group->fieldNoNested3PartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested3PartySubIDs::scan( group->groupsNested3PartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPositions::scan( Array & arr, const char * fix, unsigned len ){
 GroupPositions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosType::RAW_TAG :
     FIXPP_PRINT_FIELD(PosType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLongQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LongQty)
     group->fieldLongQty.offset = gpos;
     break;

   case FieldShortQty::RAW_TAG :
     FIXPP_PRINT_FIELD(ShortQty)
     group->fieldShortQty.offset = gpos;
     break;

   case FieldPosQtyStatus::RAW_TAG :
     FIXPP_PRINT_FIELD(PosQtyStatus)
     group->fieldPosQtyStatus.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAffectedOrders::scan( Array & arr, const char * fix, unsigned len ){
 GroupAffectedOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrigClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(OrigClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrigClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAffectedOrderID::RAW_TAG :
     FIXPP_PRINT_FIELD(AffectedOrderID)
     group->fieldAffectedOrderID.offset = gpos;
     break;

   case FieldAffectedSecondaryOrderID::RAW_TAG :
     FIXPP_PRINT_FIELD(AffectedSecondaryOrderID)
     group->fieldAffectedSecondaryOrderID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupExecs::scan( Array & arr, const char * fix, unsigned len ){
 GroupExecs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLastQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LastQty)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLastQty.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldExecID::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecID)
     group->fieldExecID.offset = gpos;
     break;

   case FieldSecondaryExecID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecondaryExecID)
     group->fieldSecondaryExecID.offset = gpos;
     break;

   case FieldLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LastPx)
     group->fieldLastPx.offset = gpos;
     break;

   case FieldLastParPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LastParPx)
     group->fieldLastParPx.offset = gpos;
     break;

   case FieldLastCapacity::RAW_TAG :
     FIXPP_PRINT_FIELD(LastCapacity)
     group->fieldLastCapacity.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMsgTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupMsgTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefMsgType::RAW_TAG :
     FIXPP_PRINT_FIELD(RefMsgType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefMsgType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMsgDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(MsgDirection)
     group->fieldMsgDirection.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidComponents::scan( Array & arr, const char * fix, unsigned len ){
 GroupBidComponents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldListID::RAW_TAG :
     FIXPP_PRINT_FIELD(ListID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldListID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldTradingSessionID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionID)
     group->fieldTradingSessionID.offset = gpos;
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   case FieldNetGrossInd::RAW_TAG :
     FIXPP_PRINT_FIELD(NetGrossInd)
     group->fieldNetGrossInd.offset = gpos;
     break;

   case FieldSettlType::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlType)
     group->fieldSettlType.offset = gpos;
     break;

   case FieldSettlDate::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlDate)
     group->fieldSettlDate.offset = gpos;
     break;

   case FieldAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(Account)
     group->fieldAccount.offset = gpos;
     break;

   case FieldAcctIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(AcctIDSource)
     group->fieldAcctIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlInst::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstID::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlInstID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlInstTransType::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlInstTransType)
     group->fieldSettlInstTransType.offset = gpos;
     break;

   case FieldSettlInstRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlInstRefID)
     group->fieldSettlInstRefID.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldEffectiveTime::RAW_TAG :
     FIXPP_PRINT_FIELD(EffectiveTime)
     group->fieldEffectiveTime.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG :
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldLastUpdateTime::RAW_TAG :
     FIXPP_PRINT_FIELD(LastUpdateTime)
     group->fieldLastUpdateTime.offset = gpos;
     break;

   case FieldSettlDeliveryType::RAW_TAG :
     FIXPP_PRINT_FIELD(SettlDeliveryType)
     group->fieldSettlDeliveryType.offset = gpos;
     break;

   case FieldStandInstDbType::RAW_TAG :
     FIXPP_PRINT_FIELD(StandInstDbType)
     group->fieldStandInstDbType.offset = gpos;
     break;

   case FieldStandInstDbName::RAW_TAG :
     FIXPP_PRINT_FIELD(StandInstDbName)
     group->fieldStandInstDbName.offset = gpos;
     break;

   case FieldStandInstDbID::RAW_TAG :
     FIXPP_PRINT_FIELD(StandInstDbID)
     group->fieldStandInstDbID.offset = gpos;
     break;

   case FieldNoDlvyInst::RAW_TAG :
     FIXPP_PRINT_FIELD(NoDlvyInst)
     group->fieldNoDlvyInst.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupDlvyInst::scan( group->groupsDlvyInst, fix+pos, len - pos );
     break;

   case FieldPaymentMethod::RAW_TAG :
     FIXPP_PRINT_FIELD(PaymentMethod)
     group->fieldPaymentMethod.offset = gpos;
     break;

   case FieldPaymentRef::RAW_TAG :
     FIXPP_PRINT_FIELD(PaymentRef)
     group->fieldPaymentRef.offset = gpos;
     break;

   case FieldCardHolderName::RAW_TAG :
     FIXPP_PRINT_FIELD(CardHolderName)
     group->fieldCardHolderName.offset = gpos;
     break;

   case FieldCardNumber::RAW_TAG :
     FIXPP_PRINT_FIELD(CardNumber)
     group->fieldCardNumber.offset = gpos;
     break;

   case FieldCardStartDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CardStartDate)
     group->fieldCardStartDate.offset = gpos;
     break;

   case FieldCardExpDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CardExpDate)
     group->fieldCardExpDate.offset = gpos;
     break;

   case FieldCardIssNum::RAW_TAG :
     FIXPP_PRINT_FIELD(CardIssNum)
     group->fieldCardIssNum.offset = gpos;
     break;

   case FieldPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(PaymentDate)
     group->fieldPaymentDate.offset = gpos;
     break;

   case FieldPaymentRemitterID::RAW_TAG :
     FIXPP_PRINT_FIELD(PaymentRemitterID)
     group->fieldPaymentRemitterID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupInstrAttrib::scan( Array & arr, const char * fix, unsigned len ){
 GroupInstrAttrib * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldInstrAttribType::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrAttribType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldInstrAttribType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldInstrAttribValue::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrAttribValue)
     group->fieldInstrAttribValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMiscFees::scan( Array & arr, const char * fix, unsigned len ){
 GroupMiscFees * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMiscFeeAmt::RAW_TAG :
     FIXPP_PRINT_FIELD(MiscFeeAmt)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMiscFeeAmt.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMiscFeeCurr::RAW_TAG :
     FIXPP_PRINT_FIELD(MiscFeeCurr)
     group->fieldMiscFeeCurr.offset = gpos;
     break;

   case FieldMiscFeeType::RAW_TAG :
     FIXPP_PRINT_FIELD(MiscFeeType)
     group->fieldMiscFeeType.offset = gpos;
     break;

   case FieldMiscFeeBasis::RAW_TAG :
     FIXPP_PRINT_FIELD(MiscFeeBasis)
     group->fieldMiscFeeBasis.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteQualifiers::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteQualifier::RAW_TAG :
     FIXPP_PRINT_FIELD(QuoteQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDistribInsts::scan( Array & arr, const char * fix, unsigned len ){
 GroupDistribInsts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldDistribPaymentMethod::RAW_TAG :
     FIXPP_PRINT_FIELD(DistribPaymentMethod)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldDistribPaymentMethod.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDistribPercentage::RAW_TAG :
     FIXPP_PRINT_FIELD(DistribPercentage)
     group->fieldDistribPercentage.offset = gpos;
     break;

   case FieldCashDistribCurr::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribCurr)
     group->fieldCashDistribCurr.offset = gpos;
     break;

   case FieldCashDistribAgentName::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribAgentName)
     group->fieldCashDistribAgentName.offset = gpos;
     break;

   case FieldCashDistribAgentCode::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribAgentCode)
     group->fieldCashDistribAgentCode.offset = gpos;
     break;

   case FieldCashDistribAgentAcctNumber::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribAgentAcctNumber)
     group->fieldCashDistribAgentAcctNumber.offset = gpos;
     break;

   case FieldCashDistribPayRef::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribPayRef)
     group->fieldCashDistribPayRef.offset = gpos;
     break;

   case FieldCashDistribAgentAcctName::RAW_TAG :
     FIXPP_PRINT_FIELD(CashDistribAgentAcctName)
     group->fieldCashDistribAgentAcctName.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrdRegTimestamps::scan( Array & arr, const char * fix, unsigned len ){
 GroupTrdRegTimestamps * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTrdRegTimestamp::RAW_TAG :
     FIXPP_PRINT_FIELD(TrdRegTimestamp)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTrdRegTimestamp.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTrdRegTimestampType::RAW_TAG :
     FIXPP_PRINT_FIELD(TrdRegTimestampType)
     group->fieldTrdRegTimestampType.offset = gpos;
     break;

   case FieldTrdRegTimestampOrigin::RAW_TAG :
     FIXPP_PRINT_FIELD(TrdRegTimestampOrigin)
     group->fieldTrdRegTimestampOrigin.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAltMDSource::scan( Array & arr, const char * fix, unsigned len ){
 GroupAltMDSource * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAltMDSourceID::RAW_TAG :
     FIXPP_PRINT_FIELD(AltMDSourceID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAltMDSourceID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSides::scan( Array & arr, const char * fix, unsigned len ){
 GroupSides * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSide::RAW_TAG :
     FIXPP_PRINT_FIELD(Side)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSide.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrigClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(OrigClOrdID)
     group->fieldOrigClOrdID.offset = gpos;
     break;

   case FieldClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdID)
     group->fieldClOrdID.offset = gpos;
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     group->fieldSecondaryClOrdID.offset = gpos;
     break;

   case FieldClOrdLinkID::RAW_TAG :
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     group->fieldClOrdLinkID.offset = gpos;
     break;

   case FieldOrigOrdModTime::RAW_TAG :
     FIXPP_PRINT_FIELD(OrigOrdModTime)
     group->fieldOrigOrdModTime.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     group->fieldTradeOriginationDate.offset = gpos;
     break;

   case FieldTradeDate::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeDate)
     group->fieldTradeDate.offset = gpos;
     break;

   case FieldOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderQty)
     group->fieldOrderQty.offset = gpos;
     break;

   case FieldCashOrderQty::RAW_TAG :
     FIXPP_PRINT_FIELD(CashOrderQty)
     group->fieldCashOrderQty.offset = gpos;
     break;

   case FieldOrderPercent::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderPercent)
     group->fieldOrderPercent.offset = gpos;
     break;

   case FieldRoundingDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(RoundingDirection)
     group->fieldRoundingDirection.offset = gpos;
     break;

   case FieldRoundingModulus::RAW_TAG :
     FIXPP_PRINT_FIELD(RoundingModulus)
     group->fieldRoundingModulus.offset = gpos;
     break;

   case FieldComplianceID::RAW_TAG :
     FIXPP_PRINT_FIELD(ComplianceID)
     group->fieldComplianceID.offset = gpos;
     break;

   case FieldText::RAW_TAG :
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedText)
     group->fieldEncodedText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRoutingIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupRoutingIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRoutingType::RAW_TAG :
     FIXPP_PRINT_FIELD(RoutingType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRoutingType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRoutingID::RAW_TAG :
     FIXPP_PRINT_FIELD(RoutingID)
     group->fieldRoutingID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPosAmt::scan( Array & arr, const char * fix, unsigned len ){
 GroupPosAmt * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosAmtType::RAW_TAG :
     FIXPP_PRINT_FIELD(PosAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPosAmt::RAW_TAG :
     FIXPP_PRINT_FIELD(PosAmt)
     group->fieldPosAmt.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLinesOfText::scan( Array & arr, const char * fix, unsigned len ){
 GroupLinesOfText * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldText::RAW_TAG :
     FIXPP_PRINT_FIELD(Text)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldText.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEncodedTextLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedText)
     group->fieldEncodedText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupIOIQualifiers::scan( Array & arr, const char * fix, unsigned len ){
 GroupIOIQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldIOIQualifier::RAW_TAG :
     FIXPP_PRINT_FIELD(IOIQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldIOIQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDates::scan( Array & arr, const char * fix, unsigned len ){
 GroupDates * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeDate::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeDate)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeDate.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTransactTime::RAW_TAG :
     FIXPP_PRINT_FIELD(TransactTime)
     group->fieldTransactTime.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntryTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupMDEntryTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRelatedSym::scan( Array & arr, const char * fix, unsigned len ){
 GroupRelatedSym * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuer)
     group->fieldEncodedIssuer.offset = gpos;
     break;

   case FieldSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     group->fieldEncodedSecurityDesc.offset = gpos;
     break;

   case FieldPool::RAW_TAG :
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG :
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContraBrokers::scan( Array & arr, const char * fix, unsigned len ){
 GroupContraBrokers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContraBroker::RAW_TAG :
     FIXPP_PRINT_FIELD(ContraBroker)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContraBroker.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContraTrader::RAW_TAG :
     FIXPP_PRINT_FIELD(ContraTrader)
     group->fieldContraTrader.offset = gpos;
     break;

   case FieldContraTradeQty::RAW_TAG :
     FIXPP_PRINT_FIELD(ContraTradeQty)
     group->fieldContraTradeQty.offset = gpos;
     break;

   case FieldContraTradeTime::RAW_TAG :
     FIXPP_PRINT_FIELD(ContraTradeTime)
     group->fieldContraTradeTime.offset = gpos;
     break;

   case FieldContraLegRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(ContraLegRefID)
     group->fieldContraLegRefID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrades::scan( Array & arr, const char * fix, unsigned len ){
 GroupTrades * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeReportID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeReportID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeReportID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryTradeReportID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecondaryTradeReportID)
     group->fieldSecondaryTradeReportID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStrikes::scan( Array & arr, const char * fix, unsigned len ){
 GroupStrikes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG :
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG :
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG :
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG :
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG :
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG :
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG :
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG :
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG :
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG :
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG :
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG :
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG :
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedIssuer)
     group->fieldEncodedIssuer.offset = gpos;
     break;

   case FieldSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     group->fieldEncodedSecurityDesc.offset = gpos;
     break;

   case FieldPool::RAW_TAG :
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG :
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG :
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG :
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG :
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidDescriptors::scan( Array & arr, const char * fix, unsigned len ){
 GroupBidDescriptors * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldBidDescriptorType::RAW_TAG :
     FIXPP_PRINT_FIELD(BidDescriptorType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldBidDescriptorType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldBidDescriptor::RAW_TAG :
     FIXPP_PRINT_FIELD(BidDescriptor)
     group->fieldBidDescriptor.offset = gpos;
     break;

   case FieldSideValueInd::RAW_TAG :
     FIXPP_PRINT_FIELD(SideValueInd)
     group->fieldSideValueInd.offset = gpos;
     break;

   case FieldLiquidityValue::RAW_TAG :
     FIXPP_PRINT_FIELD(LiquidityValue)
     group->fieldLiquidityValue.offset = gpos;
     break;

   case FieldLiquidityNumSecurities::RAW_TAG :
     FIXPP_PRINT_FIELD(LiquidityNumSecurities)
     group->fieldLiquidityNumSecurities.offset = gpos;
     break;

   case FieldLiquidityPctLow::RAW_TAG :
     FIXPP_PRINT_FIELD(LiquidityPctLow)
     group->fieldLiquidityPctLow.offset = gpos;
     break;

   case FieldLiquidityPctHigh::RAW_TAG :
     FIXPP_PRINT_FIELD(LiquidityPctHigh)
     group->fieldLiquidityPctHigh.offset = gpos;
     break;

   case FieldEFPTrackingError::RAW_TAG :
     FIXPP_PRINT_FIELD(EFPTrackingError)
     group->fieldEFPTrackingError.offset = gpos;
     break;

   case FieldFairValue::RAW_TAG :
     FIXPP_PRINT_FIELD(FairValue)
     group->fieldFairValue.offset = gpos;
     break;

   case FieldOutsideIndexPct::RAW_TAG :
     FIXPP_PRINT_FIELD(OutsideIndexPct)
     group->fieldOutsideIndexPct.offset = gpos;
     break;

   case FieldValueOfFutures::RAW_TAG :
     FIXPP_PRINT_FIELD(ValueOfFutures)
     group->fieldValueOfFutures.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCompIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupCompIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefCompID::RAW_TAG :
     FIXPP_PRINT_FIELD(RefCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRefSubID::RAW_TAG :
     FIXPP_PRINT_FIELD(RefSubID)
     group->fieldRefSubID.offset = gpos;
     break;

   case FieldLocationID::RAW_TAG :
     FIXPP_PRINT_FIELD(LocationID)
     group->fieldLocationID.offset = gpos;
     break;

   case FieldDeskID::RAW_TAG :
     FIXPP_PRINT_FIELD(DeskID)
     group->fieldDeskID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegAllocs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegAllocAccount::RAW_TAG :
     FIXPP_PRINT_FIELD(LegAllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegIndividualAllocID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegIndividualAllocID)
     group->fieldLegIndividualAllocID.offset = gpos;
     break;

   case FieldNoNested2PartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNested2PartyIDs)
     group->fieldNoNested2PartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartyIDs::scan( group->groupsNested2PartyIDs, fix+pos, len - pos );
     break;

   case FieldLegAllocQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegAllocQty)
     group->fieldLegAllocQty.offset = gpos;
     break;

   case FieldLegAllocAcctIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(LegAllocAcctIDSource)
     group->fieldLegAllocAcctIDSource.offset = gpos;
     break;

   case FieldLegSettlCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSettlCurrency)
     group->fieldLegSettlCurrency.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRegistDtls::scan( Array & arr, const char * fix, unsigned len ){
 GroupRegistDtls * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRegistDtls::RAW_TAG :
     FIXPP_PRINT_FIELD(RegistDtls)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRegistDtls.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRegistEmail::RAW_TAG :
     FIXPP_PRINT_FIELD(RegistEmail)
     group->fieldRegistEmail.offset = gpos;
     break;

   case FieldMailingDtls::RAW_TAG :
     FIXPP_PRINT_FIELD(MailingDtls)
     group->fieldMailingDtls.offset = gpos;
     break;

   case FieldMailingInst::RAW_TAG :
     FIXPP_PRINT_FIELD(MailingInst)
     group->fieldMailingInst.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldOwnerType::RAW_TAG :
     FIXPP_PRINT_FIELD(OwnerType)
     group->fieldOwnerType.offset = gpos;
     break;

   case FieldDateOfBirth::RAW_TAG :
     FIXPP_PRINT_FIELD(DateOfBirth)
     group->fieldDateOfBirth.offset = gpos;
     break;

   case FieldInvestorCountryOfResidence::RAW_TAG :
     FIXPP_PRINT_FIELD(InvestorCountryOfResidence)
     group->fieldInvestorCountryOfResidence.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContAmts::scan( Array & arr, const char * fix, unsigned len ){
 GroupContAmts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContAmtType::RAW_TAG :
     FIXPP_PRINT_FIELD(ContAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContAmtValue::RAW_TAG :
     FIXPP_PRINT_FIELD(ContAmtValue)
     group->fieldContAmtValue.offset = gpos;
     break;

   case FieldContAmtCurr::RAW_TAG :
     FIXPP_PRINT_FIELD(ContAmtCurr)
     group->fieldContAmtCurr.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntries::scan( Array & arr, const char * fix, unsigned len ){
 GroupMDEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMDEntryPx::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryPx)
     group->fieldMDEntryPx.offset = gpos;
     break;

   case FieldCurrency::RAW_TAG :
     FIXPP_PRINT_FIELD(Currency)
     group->fieldCurrency.offset = gpos;
     break;

   case FieldMDEntrySize::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntrySize)
     group->fieldMDEntrySize.offset = gpos;
     break;

   case FieldMDEntryDate::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryDate)
     group->fieldMDEntryDate.offset = gpos;
     break;

   case FieldMDEntryTime::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryTime)
     group->fieldMDEntryTime.offset = gpos;
     break;

   case FieldTickDirection::RAW_TAG :
     FIXPP_PRINT_FIELD(TickDirection)
     group->fieldTickDirection.offset = gpos;
     break;

   case FieldMDMkt::RAW_TAG :
     FIXPP_PRINT_FIELD(MDMkt)
     group->fieldMDMkt.offset = gpos;
     break;

   case FieldTradingSessionID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionID)
     group->fieldTradingSessionID.offset = gpos;
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   case FieldQuoteCondition::RAW_TAG :
     FIXPP_PRINT_FIELD(QuoteCondition)
     group->fieldQuoteCondition.offset = gpos;
     break;

   case FieldTradeCondition::RAW_TAG :
     FIXPP_PRINT_FIELD(TradeCondition)
     group->fieldTradeCondition.offset = gpos;
     break;

   case FieldMDEntryOriginator::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryOriginator)
     group->fieldMDEntryOriginator.offset = gpos;
     break;

   case FieldLocationID::RAW_TAG :
     FIXPP_PRINT_FIELD(LocationID)
     group->fieldLocationID.offset = gpos;
     break;

   case FieldDeskID::RAW_TAG :
     FIXPP_PRINT_FIELD(DeskID)
     group->fieldDeskID.offset = gpos;
     break;

   case FieldOpenCloseSettlFlag::RAW_TAG :
     FIXPP_PRINT_FIELD(OpenCloseSettlFlag)
     group->fieldOpenCloseSettlFlag.offset = gpos;
     break;

   case FieldTimeInForce::RAW_TAG :
     FIXPP_PRINT_FIELD(TimeInForce)
     group->fieldTimeInForce.offset = gpos;
     break;

   case FieldExpireDate::RAW_TAG :
     FIXPP_PRINT_FIELD(ExpireDate)
     group->fieldExpireDate.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG :
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldMinQty::RAW_TAG :
     FIXPP_PRINT_FIELD(MinQty)
     group->fieldMinQty.offset = gpos;
     break;

   case FieldExecInst::RAW_TAG :
     FIXPP_PRINT_FIELD(ExecInst)
     group->fieldExecInst.offset = gpos;
     break;

   case FieldSellerDays::RAW_TAG :
     FIXPP_PRINT_FIELD(SellerDays)
     group->fieldSellerDays.offset = gpos;
     break;

   case FieldOrderID::RAW_TAG :
     FIXPP_PRINT_FIELD(OrderID)
     group->fieldOrderID.offset = gpos;
     break;

   case FieldQuoteEntryID::RAW_TAG :
     FIXPP_PRINT_FIELD(QuoteEntryID)
     group->fieldQuoteEntryID.offset = gpos;
     break;

   case FieldMDEntryBuyer::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryBuyer)
     group->fieldMDEntryBuyer.offset = gpos;
     break;

   case FieldMDEntrySeller::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntrySeller)
     group->fieldMDEntrySeller.offset = gpos;
     break;

   case FieldNumberOfOrders::RAW_TAG :
     FIXPP_PRINT_FIELD(NumberOfOrders)
     group->fieldNumberOfOrders.offset = gpos;
     break;

   case FieldMDEntryPositionNo::RAW_TAG :
     FIXPP_PRINT_FIELD(MDEntryPositionNo)
     group->fieldMDEntryPositionNo.offset = gpos;
     break;

   case FieldScope::RAW_TAG :
     FIXPP_PRINT_FIELD(Scope)
     group->fieldScope.offset = gpos;
     break;

   case FieldPriceDelta::RAW_TAG :
     FIXPP_PRINT_FIELD(PriceDelta)
     group->fieldPriceDelta.offset = gpos;
     break;

   case FieldText::RAW_TAG :
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG :
     FIXPP_PRINT_FIELD(EncodedText)
     group->fieldEncodedText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}


// -------------------------------------- skip ----------------------------------------

offset_t GroupLegStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     break;

   case FieldLegStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupEvents::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldEventType::RAW_TAG :
     break;

   case FieldEventDate::RAW_TAG :
     break;

   case FieldEventPx::RAW_TAG :
     break;

   case FieldEventText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSecurityAltID::RAW_TAG :
     break;

   case FieldLegSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCapacities::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldOrderCapacity::RAW_TAG :
     break;

   case FieldOrderRestrictions::RAW_TAG :
     break;

   case FieldOrderCapacityQty::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested3PartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested3PartySubID::RAW_TAG :
     break;

   case FieldNested3PartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPartySubID::RAW_TAG :
     break;

   case FieldPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested2PartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested2PartySubID::RAW_TAG :
     break;

   case FieldNested2PartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested2PartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested2PartyID::RAW_TAG :
     break;

   case FieldNested2PartyIDSource::RAW_TAG :
     break;

   case FieldNested2PartyRole::RAW_TAG :
     break;

   case FieldNoNested2PartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupHops::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldHopCompID::RAW_TAG :
     break;

   case FieldHopSendingTime::RAW_TAG :
     break;

   case FieldHopRefID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCollInquiryQualifier::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldCollInquiryQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPartyID::RAW_TAG :
     break;

   case FieldPartyIDSource::RAW_TAG :
     break;

   case FieldPartyRole::RAW_TAG :
     break;

   case FieldNoPartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAllocs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldAllocAccount::RAW_TAG :
     break;

   case FieldAllocAcctIDSource::RAW_TAG :
     break;

   case FieldAllocPrice::RAW_TAG :
     break;

   case FieldIndividualAllocID::RAW_TAG :
     break;

   case FieldIndividualAllocRejCode::RAW_TAG :
     break;

   case FieldAllocText::RAW_TAG :
     break;

   case FieldEncodedAllocTextLen::RAW_TAG :
     break;

   case FieldEncodedAllocText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTradingSessions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSecurityAltID::RAW_TAG :
     break;

   case FieldSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyingSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingSecurityAltID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyingStips::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingStipType::RAW_TAG :
     break;

   case FieldUnderlyingStipValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyings::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingSymbol::RAW_TAG :
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     break;

   case FieldUnderlyingQty::RAW_TAG :
     break;

   case FieldUnderlyingPx::RAW_TAG :
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingSettlPrice::RAW_TAG :
     break;

   case FieldUnderlyingSettlPriceType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldStipulationType::RAW_TAG :
     break;

   case FieldStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupOrders::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldClOrdID::RAW_TAG :
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     break;

   case FieldListSeqNo::RAW_TAG :
     break;

   case FieldClOrdLinkID::RAW_TAG :
     break;

   case FieldSettlInstMode::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     break;

   case FieldTradeDate::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldAcctIDSource::RAW_TAG :
     break;

   case FieldAccountType::RAW_TAG :
     break;

   case FieldDayBookingInst::RAW_TAG :
     break;

   case FieldBookingUnit::RAW_TAG :
     break;

   case FieldAllocID::RAW_TAG :
     break;

   case FieldPreallocMethod::RAW_TAG :
     break;

   case FieldNoAllocs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupAllocs::skip( fix+pos, len - pos );
     break;

   case FieldSettlType::RAW_TAG :
     break;

   case FieldSettlDate::RAW_TAG :
     break;

   case FieldCashMargin::RAW_TAG :
     break;

   case FieldClearingFeeIndicator::RAW_TAG :
     break;

   case FieldHandlInst::RAW_TAG :
     break;

   case FieldExecInst::RAW_TAG :
     break;

   case FieldMinQty::RAW_TAG :
     break;

   case FieldMaxFloor::RAW_TAG :
     break;

   case FieldExDestination::RAW_TAG :
     break;

   case FieldNoTradingSessions::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupTradingSessions::skip( fix+pos, len - pos );
     break;

   case FieldProcessCode::RAW_TAG :
     break;

   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   case FieldNoUnderlyings::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::skip( fix+pos, len - pos );
     break;

   case FieldPrevClosePx::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldSideValueInd::RAW_TAG :
     break;

   case FieldLocateReqd::RAW_TAG :
     break;

   case FieldTransactTime::RAW_TAG :
     break;

   case FieldNoStipulations::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupStipulations::skip( fix+pos, len - pos );
     break;

   case FieldQtyType::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldCashOrderQty::RAW_TAG :
     break;

   case FieldOrderPercent::RAW_TAG :
     break;

   case FieldRoundingDirection::RAW_TAG :
     break;

   case FieldRoundingModulus::RAW_TAG :
     break;

   case FieldOrdType::RAW_TAG :
     break;

   case FieldPriceType::RAW_TAG :
     break;

   case FieldPrice::RAW_TAG :
     break;

   case FieldStopPx::RAW_TAG :
     break;

   case FieldSpread::RAW_TAG :
     break;

   case FieldBenchmarkCurveCurrency::RAW_TAG :
     break;

   case FieldBenchmarkCurveName::RAW_TAG :
     break;

   case FieldBenchmarkCurvePoint::RAW_TAG :
     break;

   case FieldBenchmarkPrice::RAW_TAG :
     break;

   case FieldBenchmarkPriceType::RAW_TAG :
     break;

   case FieldBenchmarkSecurityID::RAW_TAG :
     break;

   case FieldBenchmarkSecurityIDSource::RAW_TAG :
     break;

   case FieldYieldType::RAW_TAG :
     break;

   case FieldYield::RAW_TAG :
     break;

   case FieldYieldCalcDate::RAW_TAG :
     break;

   case FieldYieldRedemptionDate::RAW_TAG :
     break;

   case FieldYieldRedemptionPrice::RAW_TAG :
     break;

   case FieldYieldRedemptionPriceType::RAW_TAG :
     break;

   case FieldCurrency::RAW_TAG :
     break;

   case FieldComplianceID::RAW_TAG :
     break;

   case FieldSolicitedFlag::RAW_TAG :
     break;

   case FieldIOIID::RAW_TAG :
     break;

   case FieldQuoteID::RAW_TAG :
     break;

   case FieldTimeInForce::RAW_TAG :
     break;

   case FieldEffectiveTime::RAW_TAG :
     break;

   case FieldExpireDate::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldGTBookingInst::RAW_TAG :
     break;

   case FieldCommission::RAW_TAG :
     break;

   case FieldCommType::RAW_TAG :
     break;

   case FieldCommCurrency::RAW_TAG :
     break;

   case FieldFundRenewWaiv::RAW_TAG :
     break;

   case FieldOrderCapacity::RAW_TAG :
     break;

   case FieldOrderRestrictions::RAW_TAG :
     break;

   case FieldCustOrderCapacity::RAW_TAG :
     break;

   case FieldForexReq::RAW_TAG :
     break;

   case FieldSettlCurrency::RAW_TAG :
     break;

   case FieldBookingType::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG :
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   case FieldSettlDate2::RAW_TAG :
     break;

   case FieldOrderQty2::RAW_TAG :
     break;

   case FieldPrice2::RAW_TAG :
     break;

   case FieldPositionEffect::RAW_TAG :
     break;

   case FieldCoveredOrUncovered::RAW_TAG :
     break;

   case FieldMaxShow::RAW_TAG :
     break;

   case FieldPegOffsetValue::RAW_TAG :
     break;

   case FieldPegMoveType::RAW_TAG :
     break;

   case FieldPegOffsetType::RAW_TAG :
     break;

   case FieldPegLimitType::RAW_TAG :
     break;

   case FieldPegRoundDirection::RAW_TAG :
     break;

   case FieldPegScope::RAW_TAG :
     break;

   case FieldDiscretionInst::RAW_TAG :
     break;

   case FieldDiscretionOffsetValue::RAW_TAG :
     break;

   case FieldDiscretionMoveType::RAW_TAG :
     break;

   case FieldDiscretionOffsetType::RAW_TAG :
     break;

   case FieldDiscretionLimitType::RAW_TAG :
     break;

   case FieldDiscretionRoundDirection::RAW_TAG :
     break;

   case FieldDiscretionScope::RAW_TAG :
     break;

   case FieldTargetStrategy::RAW_TAG :
     break;

   case FieldTargetStrategyParameters::RAW_TAG :
     break;

   case FieldParticipationRate::RAW_TAG :
     break;

   case FieldDesignation::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlPartySubID::RAW_TAG :
     break;

   case FieldSettlPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlPartyID::RAW_TAG :
     break;

   case FieldSettlPartyIDSource::RAW_TAG :
     break;

   case FieldSettlPartyRole::RAW_TAG :
     break;

   case FieldNoSettlPartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDlvyInst::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlInstSource::RAW_TAG :
     break;

   case FieldDlvyInstType::RAW_TAG :
     break;

   case FieldNoSettlPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartyIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupClearingInstructions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldClearingInstruction::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     break;

   case FieldNestedPartyRole::RAW_TAG :
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     break;

   case FieldLegSymbolSfx::RAW_TAG :
     break;

   case FieldLegSecurityID::RAW_TAG :
     break;

   case FieldLegSecurityIDSource::RAW_TAG :
     break;

   case FieldNoLegSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldLegProduct::RAW_TAG :
     break;

   case FieldLegCFICode::RAW_TAG :
     break;

   case FieldLegSecurityType::RAW_TAG :
     break;

   case FieldLegSecuritySubType::RAW_TAG :
     break;

   case FieldLegMaturityMonthYear::RAW_TAG :
     break;

   case FieldLegMaturityDate::RAW_TAG :
     break;

   case FieldLegCouponPaymentDate::RAW_TAG :
     break;

   case FieldLegIssueDate::RAW_TAG :
     break;

   case FieldLegRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldLegRepurchaseTerm::RAW_TAG :
     break;

   case FieldLegRepurchaseRate::RAW_TAG :
     break;

   case FieldLegFactor::RAW_TAG :
     break;

   case FieldLegCreditRating::RAW_TAG :
     break;

   case FieldLegInstrRegistry::RAW_TAG :
     break;

   case FieldLegCountryOfIssue::RAW_TAG :
     break;

   case FieldLegStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLegLocaleOfIssue::RAW_TAG :
     break;

   case FieldLegRedemptionDate::RAW_TAG :
     break;

   case FieldLegStrikePrice::RAW_TAG :
     break;

   case FieldLegStrikeCurrency::RAW_TAG :
     break;

   case FieldLegOptAttribute::RAW_TAG :
     break;

   case FieldLegContractMultiplier::RAW_TAG :
     break;

   case FieldLegCouponRate::RAW_TAG :
     break;

   case FieldLegSecurityExchange::RAW_TAG :
     break;

   case FieldLegIssuer::RAW_TAG :
     break;

   case FieldEncodedLegIssuerLen::RAW_TAG :
     break;

   case FieldEncodedLegIssuer::RAW_TAG :
     break;

   case FieldLegSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedLegSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedLegSecurityDesc::RAW_TAG :
     break;

   case FieldLegRatioQty::RAW_TAG :
     break;

   case FieldLegSide::RAW_TAG :
     break;

   case FieldLegCurrency::RAW_TAG :
     break;

   case FieldLegPool::RAW_TAG :
     break;

   case FieldLegDatedDate::RAW_TAG :
     break;

   case FieldLegContractSettlMonth::RAW_TAG :
     break;

   case FieldLegInterestAccrualDate::RAW_TAG :
     break;

   case FieldLegQty::RAW_TAG :
     break;

   case FieldLegSwapType::RAW_TAG :
     break;

   case FieldNoLegStipulations::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::skip( fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     break;

   case FieldLegCoveredOrUncovered::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     break;

   case FieldLegPrice::RAW_TAG :
     break;

   case FieldLegSettlType::RAW_TAG :
     break;

   case FieldLegSettlDate::RAW_TAG :
     break;

   case FieldLegLastPx::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteEntries::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   case FieldAgreementDesc::RAW_TAG :
     break;

   case FieldAgreementID::RAW_TAG :
     break;

   case FieldAgreementDate::RAW_TAG :
     break;

   case FieldAgreementCurrency::RAW_TAG :
     break;

   case FieldTerminationType::RAW_TAG :
     break;

   case FieldStartDate::RAW_TAG :
     break;

   case FieldEndDate::RAW_TAG :
     break;

   case FieldDeliveryType::RAW_TAG :
     break;

   case FieldMarginRatio::RAW_TAG :
     break;

   case FieldNoUnderlyings::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::skip( fix+pos, len - pos );
     break;

   case FieldNoLegs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteSets::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldQuoteSetID::RAW_TAG :
     break;

   case FieldUnderlyingSymbol::RAW_TAG :
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     break;

   case FieldUnderlyingQty::RAW_TAG :
     break;

   case FieldUnderlyingPx::RAW_TAG :
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::skip( fix+pos, len - pos );
     break;

   case FieldTotNoQuoteEntries::RAW_TAG :
     break;

   case FieldLastFragment::RAW_TAG :
     break;

   case FieldNoQuoteEntries::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupQuoteEntries::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSecurityTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested3PartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested3PartyID::RAW_TAG :
     break;

   case FieldNested3PartyIDSource::RAW_TAG :
     break;

   case FieldNested3PartyRole::RAW_TAG :
     break;

   case FieldNoNested3PartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested3PartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPositions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPosType::RAW_TAG :
     break;

   case FieldLongQty::RAW_TAG :
     break;

   case FieldShortQty::RAW_TAG :
     break;

   case FieldPosQtyStatus::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAffectedOrders::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldOrigClOrdID::RAW_TAG :
     break;

   case FieldAffectedOrderID::RAW_TAG :
     break;

   case FieldAffectedSecondaryOrderID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupExecs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLastQty::RAW_TAG :
     break;

   case FieldExecID::RAW_TAG :
     break;

   case FieldSecondaryExecID::RAW_TAG :
     break;

   case FieldLastPx::RAW_TAG :
     break;

   case FieldLastParPx::RAW_TAG :
     break;

   case FieldLastCapacity::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMsgTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRefMsgType::RAW_TAG :
     break;

   case FieldMsgDirection::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupBidComponents::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldListID::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   case FieldNetGrossInd::RAW_TAG :
     break;

   case FieldSettlType::RAW_TAG :
     break;

   case FieldSettlDate::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldAcctIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlInst::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlInstID::RAW_TAG :
     break;

   case FieldSettlInstTransType::RAW_TAG :
     break;

   case FieldSettlInstRefID::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldEffectiveTime::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldLastUpdateTime::RAW_TAG :
     break;

   case FieldSettlDeliveryType::RAW_TAG :
     break;

   case FieldStandInstDbType::RAW_TAG :
     break;

   case FieldStandInstDbName::RAW_TAG :
     break;

   case FieldStandInstDbID::RAW_TAG :
     break;

   case FieldNoDlvyInst::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupDlvyInst::skip( fix+pos, len - pos );
     break;

   case FieldPaymentMethod::RAW_TAG :
     break;

   case FieldPaymentRef::RAW_TAG :
     break;

   case FieldCardHolderName::RAW_TAG :
     break;

   case FieldCardNumber::RAW_TAG :
     break;

   case FieldCardStartDate::RAW_TAG :
     break;

   case FieldCardExpDate::RAW_TAG :
     break;

   case FieldCardIssNum::RAW_TAG :
     break;

   case FieldPaymentDate::RAW_TAG :
     break;

   case FieldPaymentRemitterID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupInstrAttrib::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldInstrAttribType::RAW_TAG :
     break;

   case FieldInstrAttribValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMiscFees::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMiscFeeAmt::RAW_TAG :
     break;

   case FieldMiscFeeCurr::RAW_TAG :
     break;

   case FieldMiscFeeType::RAW_TAG :
     break;

   case FieldMiscFeeBasis::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteQualifiers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldQuoteQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDistribInsts::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldDistribPaymentMethod::RAW_TAG :
     break;

   case FieldDistribPercentage::RAW_TAG :
     break;

   case FieldCashDistribCurr::RAW_TAG :
     break;

   case FieldCashDistribAgentName::RAW_TAG :
     break;

   case FieldCashDistribAgentCode::RAW_TAG :
     break;

   case FieldCashDistribAgentAcctNumber::RAW_TAG :
     break;

   case FieldCashDistribPayRef::RAW_TAG :
     break;

   case FieldCashDistribAgentAcctName::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTrdRegTimestamps::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTrdRegTimestamp::RAW_TAG :
     break;

   case FieldTrdRegTimestampType::RAW_TAG :
     break;

   case FieldTrdRegTimestampOrigin::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAltMDSource::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldAltMDSourceID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSides::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSide::RAW_TAG :
     break;

   case FieldOrigClOrdID::RAW_TAG :
     break;

   case FieldClOrdID::RAW_TAG :
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     break;

   case FieldClOrdLinkID::RAW_TAG :
     break;

   case FieldOrigOrdModTime::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     break;

   case FieldTradeDate::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldCashOrderQty::RAW_TAG :
     break;

   case FieldOrderPercent::RAW_TAG :
     break;

   case FieldRoundingDirection::RAW_TAG :
     break;

   case FieldRoundingModulus::RAW_TAG :
     break;

   case FieldComplianceID::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG :
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRoutingIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRoutingType::RAW_TAG :
     break;

   case FieldRoutingID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPosAmt::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPosAmtType::RAW_TAG :
     break;

   case FieldPosAmt::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLinesOfText::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG :
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupIOIQualifiers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldIOIQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDates::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradeDate::RAW_TAG :
     break;

   case FieldTransactTime::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMDEntryTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRelatedSym::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupContraBrokers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldContraBroker::RAW_TAG :
     break;

   case FieldContraTrader::RAW_TAG :
     break;

   case FieldContraTradeQty::RAW_TAG :
     break;

   case FieldContraTradeTime::RAW_TAG :
     break;

   case FieldContraLegRefID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTrades::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradeReportID::RAW_TAG :
     break;

   case FieldSecondaryTradeReportID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupStrikes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG :
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG :
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupBidDescriptors::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldBidDescriptorType::RAW_TAG :
     break;

   case FieldBidDescriptor::RAW_TAG :
     break;

   case FieldSideValueInd::RAW_TAG :
     break;

   case FieldLiquidityValue::RAW_TAG :
     break;

   case FieldLiquidityNumSecurities::RAW_TAG :
     break;

   case FieldLiquidityPctLow::RAW_TAG :
     break;

   case FieldLiquidityPctHigh::RAW_TAG :
     break;

   case FieldEFPTrackingError::RAW_TAG :
     break;

   case FieldFairValue::RAW_TAG :
     break;

   case FieldOutsideIndexPct::RAW_TAG :
     break;

   case FieldValueOfFutures::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCompIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRefCompID::RAW_TAG :
     break;

   case FieldRefSubID::RAW_TAG :
     break;

   case FieldLocationID::RAW_TAG :
     break;

   case FieldDeskID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegAllocs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegAllocAccount::RAW_TAG :
     break;

   case FieldLegIndividualAllocID::RAW_TAG :
     break;

   case FieldNoNested2PartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegAllocQty::RAW_TAG :
     break;

   case FieldLegAllocAcctIDSource::RAW_TAG :
     break;

   case FieldLegSettlCurrency::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRegistDtls::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRegistDtls::RAW_TAG :
     break;

   case FieldRegistEmail::RAW_TAG :
     break;

   case FieldMailingDtls::RAW_TAG :
     break;

   case FieldMailingInst::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldOwnerType::RAW_TAG :
     break;

   case FieldDateOfBirth::RAW_TAG :
     break;

   case FieldInvestorCountryOfResidence::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupContAmts::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldContAmtType::RAW_TAG :
     break;

   case FieldContAmtValue::RAW_TAG :
     break;

   case FieldContAmtCurr::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMDEntries::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     break;

   case FieldMDEntryPx::RAW_TAG :
     break;

   case FieldCurrency::RAW_TAG :
     break;

   case FieldMDEntrySize::RAW_TAG :
     break;

   case FieldMDEntryDate::RAW_TAG :
     break;

   case FieldMDEntryTime::RAW_TAG :
     break;

   case FieldTickDirection::RAW_TAG :
     break;

   case FieldMDMkt::RAW_TAG :
     break;

   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   case FieldQuoteCondition::RAW_TAG :
     break;

   case FieldTradeCondition::RAW_TAG :
     break;

   case FieldMDEntryOriginator::RAW_TAG :
     break;

   case FieldLocationID::RAW_TAG :
     break;

   case FieldDeskID::RAW_TAG :
     break;

   case FieldOpenCloseSettlFlag::RAW_TAG :
     break;

   case FieldTimeInForce::RAW_TAG :
     break;

   case FieldExpireDate::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldMinQty::RAW_TAG :
     break;

   case FieldExecInst::RAW_TAG :
     break;

   case FieldSellerDays::RAW_TAG :
     break;

   case FieldOrderID::RAW_TAG :
     break;

   case FieldQuoteEntryID::RAW_TAG :
     break;

   case FieldMDEntryBuyer::RAW_TAG :
     break;

   case FieldMDEntrySeller::RAW_TAG :
     break;

   case FieldNumberOfOrders::RAW_TAG :
     break;

   case FieldMDEntryPositionNo::RAW_TAG :
     break;

   case FieldScope::RAW_TAG :
     break;

   case FieldPriceDelta::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG :
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}


// ---------------------------------- getFieldDepth ---------------------------------

GetDepthMethod GroupLegStipulations::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupEvents::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupLegSecurityAltID::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupCapacities::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNested3PartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupPartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNested2PartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNested2PartyIDs::groupGetDepthMethods[] = {
   GroupNested2PartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupHops::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupCollInquiryQualifier::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupPartyIDs::groupGetDepthMethods[] = {
   GroupPartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupAllocs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupTradingSessions::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupSecurityAltID::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupUnderlyingSecurityAltID::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupUnderlyingStips::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupUnderlyings::groupGetDepthMethods[] = {
   GroupUnderlyingSecurityAltID::getFieldDepth,
   GroupUnderlyingStips::getFieldDepth,
   nullptr };

GetDepthMethod GroupStipulations::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupOrders::groupGetDepthMethods[] = {
   GroupPartyIDs::getFieldDepth,
   GroupAllocs::getFieldDepth,
   GroupTradingSessions::getFieldDepth,
   GroupSecurityAltID::getFieldDepth,
   GroupEvents::getFieldDepth,
   GroupUnderlyings::getFieldDepth,
   GroupStipulations::getFieldDepth,
   nullptr };

GetDepthMethod GroupSettlPartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupSettlPartyIDs::groupGetDepthMethods[] = {
   GroupSettlPartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupDlvyInst::groupGetDepthMethods[] = {
   GroupSettlPartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupClearingInstructions::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartyIDs::groupGetDepthMethods[] = {
   GroupNestedPartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupLegs::groupGetDepthMethods[] = {
   GroupLegSecurityAltID::getFieldDepth,
   GroupLegStipulations::getFieldDepth,
   GroupNestedPartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupQuoteEntries::groupGetDepthMethods[] = {
   GroupSecurityAltID::getFieldDepth,
   GroupEvents::getFieldDepth,
   GroupUnderlyings::getFieldDepth,
   GroupLegs::getFieldDepth,
   nullptr };

GetDepthMethod GroupQuoteSets::groupGetDepthMethods[] = {
   GroupUnderlyingSecurityAltID::getFieldDepth,
   GroupUnderlyingStips::getFieldDepth,
   GroupQuoteEntries::getFieldDepth,
   nullptr };

GetDepthMethod GroupSecurityTypes::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNested3PartyIDs::groupGetDepthMethods[] = {
   GroupNested3PartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupPositions::groupGetDepthMethods[] = {
   GroupNestedPartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupAffectedOrders::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupExecs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupMsgTypes::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupBidComponents::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupSettlInst::groupGetDepthMethods[] = {
   GroupPartyIDs::getFieldDepth,
   GroupDlvyInst::getFieldDepth,
   nullptr };

GetDepthMethod GroupInstrAttrib::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupMiscFees::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupQuoteQualifiers::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupDistribInsts::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupTrdRegTimestamps::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupAltMDSource::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupSides::groupGetDepthMethods[] = {
   GroupPartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupRoutingIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupPosAmt::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupLinesOfText::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupIOIQualifiers::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupDates::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupMDEntryTypes::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupRelatedSym::groupGetDepthMethods[] = {
   GroupSecurityAltID::getFieldDepth,
   GroupEvents::getFieldDepth,
   nullptr };

GetDepthMethod GroupContraBrokers::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupTrades::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupStrikes::groupGetDepthMethods[] = {
   GroupSecurityAltID::getFieldDepth,
   GroupEvents::getFieldDepth,
   nullptr };

GetDepthMethod GroupBidDescriptors::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupCompIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupLegAllocs::groupGetDepthMethods[] = {
   GroupNested2PartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupRegistDtls::groupGetDepthMethods[] = {
   GroupNestedPartyIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupContAmts::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupMDEntries::groupGetDepthMethods[] = {
   nullptr };


FieldDepth GroupLegStipulations::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegStipulationType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegStipulationValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupEvents::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldEventType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldEventDate::RAW_TAG :
     case FieldEventPx::RAW_TAG :
     case FieldEventText::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLegSecurityAltID::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegSecurityAltID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegSecurityAltIDSource::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupCapacities::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldOrderCapacity::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldOrderRestrictions::RAW_TAG :
     case FieldOrderCapacityQty::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNested3PartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNested3PartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNested3PartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupPartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldPartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldPartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNested2PartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNested2PartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNested2PartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNested2PartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNested2PartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNested2PartyIDSource::RAW_TAG :
     case FieldNested2PartyRole::RAW_TAG :
     case FieldNoNested2PartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupHops::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldHopCompID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldHopSendingTime::RAW_TAG :
     case FieldHopRefID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupCollInquiryQualifier::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldCollInquiryQualifier::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupPartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldPartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldPartyIDSource::RAW_TAG :
     case FieldPartyRole::RAW_TAG :
     case FieldNoPartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupAllocs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldAllocAccount::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldAllocAcctIDSource::RAW_TAG :
     case FieldAllocPrice::RAW_TAG :
     case FieldIndividualAllocID::RAW_TAG :
     case FieldIndividualAllocRejCode::RAW_TAG :
     case FieldAllocText::RAW_TAG :
     case FieldEncodedAllocTextLen::RAW_TAG :
     case FieldEncodedAllocText::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupTradingSessions::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldTradingSessionID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldTradingSessionSubID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSecurityAltID::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSecurityAltID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSecurityAltIDSource::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupUnderlyingSecurityAltID::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldUnderlyingSecurityAltID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldUnderlyingSecurityAltIDSource::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupUnderlyingStips::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldUnderlyingStipType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldUnderlyingStipValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupUnderlyings::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldUnderlyingSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldUnderlyingSymbolSfx::RAW_TAG :
     case FieldUnderlyingSecurityID::RAW_TAG :
     case FieldUnderlyingSecurityIDSource::RAW_TAG :
     case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     case FieldUnderlyingProduct::RAW_TAG :
     case FieldUnderlyingCFICode::RAW_TAG :
     case FieldUnderlyingSecurityType::RAW_TAG :
     case FieldUnderlyingSecuritySubType::RAW_TAG :
     case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     case FieldUnderlyingMaturityDate::RAW_TAG :
     case FieldUnderlyingPutOrCall::RAW_TAG :
     case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     case FieldUnderlyingIssueDate::RAW_TAG :
     case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     case FieldUnderlyingRepurchaseRate::RAW_TAG :
     case FieldUnderlyingFactor::RAW_TAG :
     case FieldUnderlyingCreditRating::RAW_TAG :
     case FieldUnderlyingInstrRegistry::RAW_TAG :
     case FieldUnderlyingCountryOfIssue::RAW_TAG :
     case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     case FieldUnderlyingRedemptionDate::RAW_TAG :
     case FieldUnderlyingStrikePrice::RAW_TAG :
     case FieldUnderlyingStrikeCurrency::RAW_TAG :
     case FieldUnderlyingOptAttribute::RAW_TAG :
     case FieldUnderlyingContractMultiplier::RAW_TAG :
     case FieldUnderlyingCouponRate::RAW_TAG :
     case FieldUnderlyingSecurityExchange::RAW_TAG :
     case FieldUnderlyingIssuer::RAW_TAG :
     case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     case FieldEncodedUnderlyingIssuer::RAW_TAG :
     case FieldUnderlyingSecurityDesc::RAW_TAG :
     case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     case FieldUnderlyingCPProgram::RAW_TAG :
     case FieldUnderlyingCPRegType::RAW_TAG :
     case FieldUnderlyingCurrency::RAW_TAG :
     case FieldUnderlyingQty::RAW_TAG :
     case FieldUnderlyingPx::RAW_TAG :
     case FieldUnderlyingDirtyPrice::RAW_TAG :
     case FieldUnderlyingEndPrice::RAW_TAG :
     case FieldUnderlyingStartValue::RAW_TAG :
     case FieldUnderlyingCurrentValue::RAW_TAG :
     case FieldUnderlyingEndValue::RAW_TAG :
     case FieldNoUnderlyingStips::RAW_TAG :
     case FieldUnderlyingSettlPrice::RAW_TAG :
     case FieldUnderlyingSettlPriceType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupStipulations::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldStipulationType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldStipulationValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupOrders::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldClOrdID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSecondaryClOrdID::RAW_TAG :
     case FieldListSeqNo::RAW_TAG :
     case FieldClOrdLinkID::RAW_TAG :
     case FieldSettlInstMode::RAW_TAG :
     case FieldNoPartyIDs::RAW_TAG :
     case FieldTradeOriginationDate::RAW_TAG :
     case FieldTradeDate::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldAcctIDSource::RAW_TAG :
     case FieldAccountType::RAW_TAG :
     case FieldDayBookingInst::RAW_TAG :
     case FieldBookingUnit::RAW_TAG :
     case FieldAllocID::RAW_TAG :
     case FieldPreallocMethod::RAW_TAG :
     case FieldNoAllocs::RAW_TAG :
     case FieldSettlType::RAW_TAG :
     case FieldSettlDate::RAW_TAG :
     case FieldCashMargin::RAW_TAG :
     case FieldClearingFeeIndicator::RAW_TAG :
     case FieldHandlInst::RAW_TAG :
     case FieldExecInst::RAW_TAG :
     case FieldMinQty::RAW_TAG :
     case FieldMaxFloor::RAW_TAG :
     case FieldExDestination::RAW_TAG :
     case FieldNoTradingSessions::RAW_TAG :
     case FieldProcessCode::RAW_TAG :
     case FieldSymbol::RAW_TAG :
     case FieldSymbolSfx::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityIDSource::RAW_TAG :
     case FieldNoSecurityAltID::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldCFICode::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldSecuritySubType::RAW_TAG :
     case FieldMaturityMonthYear::RAW_TAG :
     case FieldMaturityDate::RAW_TAG :
     case FieldPutOrCall::RAW_TAG :
     case FieldCouponPaymentDate::RAW_TAG :
     case FieldIssueDate::RAW_TAG :
     case FieldRepoCollateralSecurityType::RAW_TAG :
     case FieldRepurchaseTerm::RAW_TAG :
     case FieldRepurchaseRate::RAW_TAG :
     case FieldFactor::RAW_TAG :
     case FieldCreditRating::RAW_TAG :
     case FieldInstrRegistry::RAW_TAG :
     case FieldCountryOfIssue::RAW_TAG :
     case FieldStateOrProvinceOfIssue::RAW_TAG :
     case FieldLocaleOfIssue::RAW_TAG :
     case FieldRedemptionDate::RAW_TAG :
     case FieldStrikePrice::RAW_TAG :
     case FieldStrikeCurrency::RAW_TAG :
     case FieldOptAttribute::RAW_TAG :
     case FieldContractMultiplier::RAW_TAG :
     case FieldCouponRate::RAW_TAG :
     case FieldSecurityExchange::RAW_TAG :
     case FieldIssuer::RAW_TAG :
     case FieldEncodedIssuerLen::RAW_TAG :
     case FieldEncodedIssuer::RAW_TAG :
     case FieldSecurityDesc::RAW_TAG :
     case FieldEncodedSecurityDescLen::RAW_TAG :
     case FieldEncodedSecurityDesc::RAW_TAG :
     case FieldPool::RAW_TAG :
     case FieldContractSettlMonth::RAW_TAG :
     case FieldCPProgram::RAW_TAG :
     case FieldCPRegType::RAW_TAG :
     case FieldNoEvents::RAW_TAG :
     case FieldDatedDate::RAW_TAG :
     case FieldInterestAccrualDate::RAW_TAG :
     case FieldNoUnderlyings::RAW_TAG :
     case FieldPrevClosePx::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldSideValueInd::RAW_TAG :
     case FieldLocateReqd::RAW_TAG :
     case FieldTransactTime::RAW_TAG :
     case FieldNoStipulations::RAW_TAG :
     case FieldQtyType::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldCashOrderQty::RAW_TAG :
     case FieldOrderPercent::RAW_TAG :
     case FieldRoundingDirection::RAW_TAG :
     case FieldRoundingModulus::RAW_TAG :
     case FieldOrdType::RAW_TAG :
     case FieldPriceType::RAW_TAG :
     case FieldPrice::RAW_TAG :
     case FieldStopPx::RAW_TAG :
     case FieldSpread::RAW_TAG :
     case FieldBenchmarkCurveCurrency::RAW_TAG :
     case FieldBenchmarkCurveName::RAW_TAG :
     case FieldBenchmarkCurvePoint::RAW_TAG :
     case FieldBenchmarkPrice::RAW_TAG :
     case FieldBenchmarkPriceType::RAW_TAG :
     case FieldBenchmarkSecurityID::RAW_TAG :
     case FieldBenchmarkSecurityIDSource::RAW_TAG :
     case FieldYieldType::RAW_TAG :
     case FieldYield::RAW_TAG :
     case FieldYieldCalcDate::RAW_TAG :
     case FieldYieldRedemptionDate::RAW_TAG :
     case FieldYieldRedemptionPrice::RAW_TAG :
     case FieldYieldRedemptionPriceType::RAW_TAG :
     case FieldCurrency::RAW_TAG :
     case FieldComplianceID::RAW_TAG :
     case FieldSolicitedFlag::RAW_TAG :
     case FieldIOIID::RAW_TAG :
     case FieldQuoteID::RAW_TAG :
     case FieldTimeInForce::RAW_TAG :
     case FieldEffectiveTime::RAW_TAG :
     case FieldExpireDate::RAW_TAG :
     case FieldExpireTime::RAW_TAG :
     case FieldGTBookingInst::RAW_TAG :
     case FieldCommission::RAW_TAG :
     case FieldCommType::RAW_TAG :
     case FieldCommCurrency::RAW_TAG :
     case FieldFundRenewWaiv::RAW_TAG :
     case FieldOrderCapacity::RAW_TAG :
     case FieldOrderRestrictions::RAW_TAG :
     case FieldCustOrderCapacity::RAW_TAG :
     case FieldForexReq::RAW_TAG :
     case FieldSettlCurrency::RAW_TAG :
     case FieldBookingType::RAW_TAG :
     case FieldText::RAW_TAG :
     case FieldEncodedTextLen::RAW_TAG :
     case FieldEncodedText::RAW_TAG :
     case FieldSettlDate2::RAW_TAG :
     case FieldOrderQty2::RAW_TAG :
     case FieldPrice2::RAW_TAG :
     case FieldPositionEffect::RAW_TAG :
     case FieldCoveredOrUncovered::RAW_TAG :
     case FieldMaxShow::RAW_TAG :
     case FieldPegOffsetValue::RAW_TAG :
     case FieldPegMoveType::RAW_TAG :
     case FieldPegOffsetType::RAW_TAG :
     case FieldPegLimitType::RAW_TAG :
     case FieldPegRoundDirection::RAW_TAG :
     case FieldPegScope::RAW_TAG :
     case FieldDiscretionInst::RAW_TAG :
     case FieldDiscretionOffsetValue::RAW_TAG :
     case FieldDiscretionMoveType::RAW_TAG :
     case FieldDiscretionOffsetType::RAW_TAG :
     case FieldDiscretionLimitType::RAW_TAG :
     case FieldDiscretionRoundDirection::RAW_TAG :
     case FieldDiscretionScope::RAW_TAG :
     case FieldTargetStrategy::RAW_TAG :
     case FieldTargetStrategyParameters::RAW_TAG :
     case FieldParticipationRate::RAW_TAG :
     case FieldDesignation::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSettlPartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSettlPartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSettlPartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSettlPartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSettlPartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSettlPartyIDSource::RAW_TAG :
     case FieldSettlPartyRole::RAW_TAG :
     case FieldNoSettlPartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupDlvyInst::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSettlInstSource::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldDlvyInstType::RAW_TAG :
     case FieldNoSettlPartyIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupClearingInstructions::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldClearingInstruction::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartyIDSource::RAW_TAG :
     case FieldNestedPartyRole::RAW_TAG :
     case FieldNoNestedPartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLegs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegSymbolSfx::RAW_TAG :
     case FieldLegSecurityID::RAW_TAG :
     case FieldLegSecurityIDSource::RAW_TAG :
     case FieldNoLegSecurityAltID::RAW_TAG :
     case FieldLegProduct::RAW_TAG :
     case FieldLegCFICode::RAW_TAG :
     case FieldLegSecurityType::RAW_TAG :
     case FieldLegSecuritySubType::RAW_TAG :
     case FieldLegMaturityMonthYear::RAW_TAG :
     case FieldLegMaturityDate::RAW_TAG :
     case FieldLegCouponPaymentDate::RAW_TAG :
     case FieldLegIssueDate::RAW_TAG :
     case FieldLegRepoCollateralSecurityType::RAW_TAG :
     case FieldLegRepurchaseTerm::RAW_TAG :
     case FieldLegRepurchaseRate::RAW_TAG :
     case FieldLegFactor::RAW_TAG :
     case FieldLegCreditRating::RAW_TAG :
     case FieldLegInstrRegistry::RAW_TAG :
     case FieldLegCountryOfIssue::RAW_TAG :
     case FieldLegStateOrProvinceOfIssue::RAW_TAG :
     case FieldLegLocaleOfIssue::RAW_TAG :
     case FieldLegRedemptionDate::RAW_TAG :
     case FieldLegStrikePrice::RAW_TAG :
     case FieldLegStrikeCurrency::RAW_TAG :
     case FieldLegOptAttribute::RAW_TAG :
     case FieldLegContractMultiplier::RAW_TAG :
     case FieldLegCouponRate::RAW_TAG :
     case FieldLegSecurityExchange::RAW_TAG :
     case FieldLegIssuer::RAW_TAG :
     case FieldEncodedLegIssuerLen::RAW_TAG :
     case FieldEncodedLegIssuer::RAW_TAG :
     case FieldLegSecurityDesc::RAW_TAG :
     case FieldEncodedLegSecurityDescLen::RAW_TAG :
     case FieldEncodedLegSecurityDesc::RAW_TAG :
     case FieldLegRatioQty::RAW_TAG :
     case FieldLegSide::RAW_TAG :
     case FieldLegCurrency::RAW_TAG :
     case FieldLegPool::RAW_TAG :
     case FieldLegDatedDate::RAW_TAG :
     case FieldLegContractSettlMonth::RAW_TAG :
     case FieldLegInterestAccrualDate::RAW_TAG :
     case FieldLegQty::RAW_TAG :
     case FieldLegSwapType::RAW_TAG :
     case FieldNoLegStipulations::RAW_TAG :
     case FieldLegPositionEffect::RAW_TAG :
     case FieldLegCoveredOrUncovered::RAW_TAG :
     case FieldNoNestedPartyIDs::RAW_TAG :
     case FieldLegRefID::RAW_TAG :
     case FieldLegPrice::RAW_TAG :
     case FieldLegSettlType::RAW_TAG :
     case FieldLegSettlDate::RAW_TAG :
     case FieldLegLastPx::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupQuoteEntries::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSymbolSfx::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityIDSource::RAW_TAG :
     case FieldNoSecurityAltID::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldCFICode::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldSecuritySubType::RAW_TAG :
     case FieldMaturityMonthYear::RAW_TAG :
     case FieldMaturityDate::RAW_TAG :
     case FieldPutOrCall::RAW_TAG :
     case FieldCouponPaymentDate::RAW_TAG :
     case FieldIssueDate::RAW_TAG :
     case FieldRepoCollateralSecurityType::RAW_TAG :
     case FieldRepurchaseTerm::RAW_TAG :
     case FieldRepurchaseRate::RAW_TAG :
     case FieldFactor::RAW_TAG :
     case FieldCreditRating::RAW_TAG :
     case FieldInstrRegistry::RAW_TAG :
     case FieldCountryOfIssue::RAW_TAG :
     case FieldStateOrProvinceOfIssue::RAW_TAG :
     case FieldLocaleOfIssue::RAW_TAG :
     case FieldRedemptionDate::RAW_TAG :
     case FieldStrikePrice::RAW_TAG :
     case FieldStrikeCurrency::RAW_TAG :
     case FieldOptAttribute::RAW_TAG :
     case FieldContractMultiplier::RAW_TAG :
     case FieldCouponRate::RAW_TAG :
     case FieldSecurityExchange::RAW_TAG :
     case FieldIssuer::RAW_TAG :
     case FieldEncodedIssuerLen::RAW_TAG :
     case FieldEncodedIssuer::RAW_TAG :
     case FieldSecurityDesc::RAW_TAG :
     case FieldEncodedSecurityDescLen::RAW_TAG :
     case FieldEncodedSecurityDesc::RAW_TAG :
     case FieldPool::RAW_TAG :
     case FieldContractSettlMonth::RAW_TAG :
     case FieldCPProgram::RAW_TAG :
     case FieldCPRegType::RAW_TAG :
     case FieldNoEvents::RAW_TAG :
     case FieldDatedDate::RAW_TAG :
     case FieldInterestAccrualDate::RAW_TAG :
     case FieldAgreementDesc::RAW_TAG :
     case FieldAgreementID::RAW_TAG :
     case FieldAgreementDate::RAW_TAG :
     case FieldAgreementCurrency::RAW_TAG :
     case FieldTerminationType::RAW_TAG :
     case FieldStartDate::RAW_TAG :
     case FieldEndDate::RAW_TAG :
     case FieldDeliveryType::RAW_TAG :
     case FieldMarginRatio::RAW_TAG :
     case FieldNoUnderlyings::RAW_TAG :
     case FieldNoLegs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupQuoteSets::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldQuoteSetID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldUnderlyingSymbol::RAW_TAG :
     case FieldUnderlyingSymbolSfx::RAW_TAG :
     case FieldUnderlyingSecurityID::RAW_TAG :
     case FieldUnderlyingSecurityIDSource::RAW_TAG :
     case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     case FieldUnderlyingProduct::RAW_TAG :
     case FieldUnderlyingCFICode::RAW_TAG :
     case FieldUnderlyingSecurityType::RAW_TAG :
     case FieldUnderlyingSecuritySubType::RAW_TAG :
     case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     case FieldUnderlyingMaturityDate::RAW_TAG :
     case FieldUnderlyingPutOrCall::RAW_TAG :
     case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     case FieldUnderlyingIssueDate::RAW_TAG :
     case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     case FieldUnderlyingRepurchaseRate::RAW_TAG :
     case FieldUnderlyingFactor::RAW_TAG :
     case FieldUnderlyingCreditRating::RAW_TAG :
     case FieldUnderlyingInstrRegistry::RAW_TAG :
     case FieldUnderlyingCountryOfIssue::RAW_TAG :
     case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     case FieldUnderlyingRedemptionDate::RAW_TAG :
     case FieldUnderlyingStrikePrice::RAW_TAG :
     case FieldUnderlyingStrikeCurrency::RAW_TAG :
     case FieldUnderlyingOptAttribute::RAW_TAG :
     case FieldUnderlyingContractMultiplier::RAW_TAG :
     case FieldUnderlyingCouponRate::RAW_TAG :
     case FieldUnderlyingSecurityExchange::RAW_TAG :
     case FieldUnderlyingIssuer::RAW_TAG :
     case FieldEncodedUnderlyingIssuerLen::RAW_TAG :
     case FieldEncodedUnderlyingIssuer::RAW_TAG :
     case FieldUnderlyingSecurityDesc::RAW_TAG :
     case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG :
     case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     case FieldUnderlyingCPProgram::RAW_TAG :
     case FieldUnderlyingCPRegType::RAW_TAG :
     case FieldUnderlyingCurrency::RAW_TAG :
     case FieldUnderlyingQty::RAW_TAG :
     case FieldUnderlyingPx::RAW_TAG :
     case FieldUnderlyingDirtyPrice::RAW_TAG :
     case FieldUnderlyingEndPrice::RAW_TAG :
     case FieldUnderlyingStartValue::RAW_TAG :
     case FieldUnderlyingCurrentValue::RAW_TAG :
     case FieldUnderlyingEndValue::RAW_TAG :
     case FieldNoUnderlyingStips::RAW_TAG :
     case FieldTotNoQuoteEntries::RAW_TAG :
     case FieldLastFragment::RAW_TAG :
     case FieldNoQuoteEntries::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSecurityTypes::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSecurityType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSecuritySubType::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldCFICode::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNested3PartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNested3PartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNested3PartyIDSource::RAW_TAG :
     case FieldNested3PartyRole::RAW_TAG :
     case FieldNoNested3PartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupPositions::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldPosType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLongQty::RAW_TAG :
     case FieldShortQty::RAW_TAG :
     case FieldPosQtyStatus::RAW_TAG :
     case FieldNoNestedPartyIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupAffectedOrders::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldOrigClOrdID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldAffectedOrderID::RAW_TAG :
     case FieldAffectedSecondaryOrderID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupExecs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLastQty::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldExecID::RAW_TAG :
     case FieldSecondaryExecID::RAW_TAG :
     case FieldLastPx::RAW_TAG :
     case FieldLastParPx::RAW_TAG :
     case FieldLastCapacity::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupMsgTypes::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldRefMsgType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldMsgDirection::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupBidComponents::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldListID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSide::RAW_TAG :
     case FieldTradingSessionID::RAW_TAG :
     case FieldTradingSessionSubID::RAW_TAG :
     case FieldNetGrossInd::RAW_TAG :
     case FieldSettlType::RAW_TAG :
     case FieldSettlDate::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldAcctIDSource::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSettlInst::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSettlInstID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSettlInstTransType::RAW_TAG :
     case FieldSettlInstRefID::RAW_TAG :
     case FieldNoPartyIDs::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldCFICode::RAW_TAG :
     case FieldEffectiveTime::RAW_TAG :
     case FieldExpireTime::RAW_TAG :
     case FieldLastUpdateTime::RAW_TAG :
     case FieldSettlDeliveryType::RAW_TAG :
     case FieldStandInstDbType::RAW_TAG :
     case FieldStandInstDbName::RAW_TAG :
     case FieldStandInstDbID::RAW_TAG :
     case FieldNoDlvyInst::RAW_TAG :
     case FieldPaymentMethod::RAW_TAG :
     case FieldPaymentRef::RAW_TAG :
     case FieldCardHolderName::RAW_TAG :
     case FieldCardNumber::RAW_TAG :
     case FieldCardStartDate::RAW_TAG :
     case FieldCardExpDate::RAW_TAG :
     case FieldCardIssNum::RAW_TAG :
     case FieldPaymentDate::RAW_TAG :
     case FieldPaymentRemitterID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupInstrAttrib::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldInstrAttribType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldInstrAttribValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupMiscFees::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldMiscFeeAmt::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldMiscFeeCurr::RAW_TAG :
     case FieldMiscFeeType::RAW_TAG :
     case FieldMiscFeeBasis::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupQuoteQualifiers::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldQuoteQualifier::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupDistribInsts::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldDistribPaymentMethod::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldDistribPercentage::RAW_TAG :
     case FieldCashDistribCurr::RAW_TAG :
     case FieldCashDistribAgentName::RAW_TAG :
     case FieldCashDistribAgentCode::RAW_TAG :
     case FieldCashDistribAgentAcctNumber::RAW_TAG :
     case FieldCashDistribPayRef::RAW_TAG :
     case FieldCashDistribAgentAcctName::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupTrdRegTimestamps::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldTrdRegTimestamp::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldTrdRegTimestampType::RAW_TAG :
     case FieldTrdRegTimestampOrigin::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupAltMDSource::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldAltMDSourceID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupSides::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSide::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldOrigClOrdID::RAW_TAG :
     case FieldClOrdID::RAW_TAG :
     case FieldSecondaryClOrdID::RAW_TAG :
     case FieldClOrdLinkID::RAW_TAG :
     case FieldOrigOrdModTime::RAW_TAG :
     case FieldNoPartyIDs::RAW_TAG :
     case FieldTradeOriginationDate::RAW_TAG :
     case FieldTradeDate::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldCashOrderQty::RAW_TAG :
     case FieldOrderPercent::RAW_TAG :
     case FieldRoundingDirection::RAW_TAG :
     case FieldRoundingModulus::RAW_TAG :
     case FieldComplianceID::RAW_TAG :
     case FieldText::RAW_TAG :
     case FieldEncodedTextLen::RAW_TAG :
     case FieldEncodedText::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupRoutingIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldRoutingType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldRoutingID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupPosAmt::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldPosAmtType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldPosAmt::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLinesOfText::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldText::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldEncodedTextLen::RAW_TAG :
     case FieldEncodedText::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupIOIQualifiers::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldIOIQualifier::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupDates::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldTradeDate::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldTransactTime::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupMDEntryTypes::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldMDEntryType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupRelatedSym::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSymbolSfx::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityIDSource::RAW_TAG :
     case FieldNoSecurityAltID::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldCFICode::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldSecuritySubType::RAW_TAG :
     case FieldMaturityMonthYear::RAW_TAG :
     case FieldMaturityDate::RAW_TAG :
     case FieldPutOrCall::RAW_TAG :
     case FieldCouponPaymentDate::RAW_TAG :
     case FieldIssueDate::RAW_TAG :
     case FieldRepoCollateralSecurityType::RAW_TAG :
     case FieldRepurchaseTerm::RAW_TAG :
     case FieldRepurchaseRate::RAW_TAG :
     case FieldFactor::RAW_TAG :
     case FieldCreditRating::RAW_TAG :
     case FieldInstrRegistry::RAW_TAG :
     case FieldCountryOfIssue::RAW_TAG :
     case FieldStateOrProvinceOfIssue::RAW_TAG :
     case FieldLocaleOfIssue::RAW_TAG :
     case FieldRedemptionDate::RAW_TAG :
     case FieldStrikePrice::RAW_TAG :
     case FieldStrikeCurrency::RAW_TAG :
     case FieldOptAttribute::RAW_TAG :
     case FieldContractMultiplier::RAW_TAG :
     case FieldCouponRate::RAW_TAG :
     case FieldSecurityExchange::RAW_TAG :
     case FieldIssuer::RAW_TAG :
     case FieldEncodedIssuerLen::RAW_TAG :
     case FieldEncodedIssuer::RAW_TAG :
     case FieldSecurityDesc::RAW_TAG :
     case FieldEncodedSecurityDescLen::RAW_TAG :
     case FieldEncodedSecurityDesc::RAW_TAG :
     case FieldPool::RAW_TAG :
     case FieldContractSettlMonth::RAW_TAG :
     case FieldCPProgram::RAW_TAG :
     case FieldCPRegType::RAW_TAG :
     case FieldNoEvents::RAW_TAG :
     case FieldDatedDate::RAW_TAG :
     case FieldInterestAccrualDate::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupContraBrokers::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldContraBroker::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldContraTrader::RAW_TAG :
     case FieldContraTradeQty::RAW_TAG :
     case FieldContraTradeTime::RAW_TAG :
     case FieldContraLegRefID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupTrades::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldTradeReportID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSecondaryTradeReportID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupStrikes::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldSymbolSfx::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityIDSource::RAW_TAG :
     case FieldNoSecurityAltID::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldCFICode::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldSecuritySubType::RAW_TAG :
     case FieldMaturityMonthYear::RAW_TAG :
     case FieldMaturityDate::RAW_TAG :
     case FieldPutOrCall::RAW_TAG :
     case FieldCouponPaymentDate::RAW_TAG :
     case FieldIssueDate::RAW_TAG :
     case FieldRepoCollateralSecurityType::RAW_TAG :
     case FieldRepurchaseTerm::RAW_TAG :
     case FieldRepurchaseRate::RAW_TAG :
     case FieldFactor::RAW_TAG :
     case FieldCreditRating::RAW_TAG :
     case FieldInstrRegistry::RAW_TAG :
     case FieldCountryOfIssue::RAW_TAG :
     case FieldStateOrProvinceOfIssue::RAW_TAG :
     case FieldLocaleOfIssue::RAW_TAG :
     case FieldRedemptionDate::RAW_TAG :
     case FieldStrikePrice::RAW_TAG :
     case FieldStrikeCurrency::RAW_TAG :
     case FieldOptAttribute::RAW_TAG :
     case FieldContractMultiplier::RAW_TAG :
     case FieldCouponRate::RAW_TAG :
     case FieldSecurityExchange::RAW_TAG :
     case FieldIssuer::RAW_TAG :
     case FieldEncodedIssuerLen::RAW_TAG :
     case FieldEncodedIssuer::RAW_TAG :
     case FieldSecurityDesc::RAW_TAG :
     case FieldEncodedSecurityDescLen::RAW_TAG :
     case FieldEncodedSecurityDesc::RAW_TAG :
     case FieldPool::RAW_TAG :
     case FieldContractSettlMonth::RAW_TAG :
     case FieldCPProgram::RAW_TAG :
     case FieldCPRegType::RAW_TAG :
     case FieldNoEvents::RAW_TAG :
     case FieldDatedDate::RAW_TAG :
     case FieldInterestAccrualDate::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupBidDescriptors::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldBidDescriptorType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldBidDescriptor::RAW_TAG :
     case FieldSideValueInd::RAW_TAG :
     case FieldLiquidityValue::RAW_TAG :
     case FieldLiquidityNumSecurities::RAW_TAG :
     case FieldLiquidityPctLow::RAW_TAG :
     case FieldLiquidityPctHigh::RAW_TAG :
     case FieldEFPTrackingError::RAW_TAG :
     case FieldFairValue::RAW_TAG :
     case FieldOutsideIndexPct::RAW_TAG :
     case FieldValueOfFutures::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupCompIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldRefCompID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldRefSubID::RAW_TAG :
     case FieldLocationID::RAW_TAG :
     case FieldDeskID::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLegAllocs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegAllocAccount::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegIndividualAllocID::RAW_TAG :
     case FieldNoNested2PartyIDs::RAW_TAG :
     case FieldLegAllocQty::RAW_TAG :
     case FieldLegAllocAcctIDSource::RAW_TAG :
     case FieldLegSettlCurrency::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupRegistDtls::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldRegistDtls::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldRegistEmail::RAW_TAG :
     case FieldMailingDtls::RAW_TAG :
     case FieldMailingInst::RAW_TAG :
     case FieldNoNestedPartyIDs::RAW_TAG :
     case FieldOwnerType::RAW_TAG :
     case FieldDateOfBirth::RAW_TAG :
     case FieldInvestorCountryOfResidence::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupContAmts::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldContAmtType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldContAmtValue::RAW_TAG :
     case FieldContAmtCurr::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupMDEntries::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldMDEntryType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldMDEntryPx::RAW_TAG :
     case FieldCurrency::RAW_TAG :
     case FieldMDEntrySize::RAW_TAG :
     case FieldMDEntryDate::RAW_TAG :
     case FieldMDEntryTime::RAW_TAG :
     case FieldTickDirection::RAW_TAG :
     case FieldMDMkt::RAW_TAG :
     case FieldTradingSessionID::RAW_TAG :
     case FieldTradingSessionSubID::RAW_TAG :
     case FieldQuoteCondition::RAW_TAG :
     case FieldTradeCondition::RAW_TAG :
     case FieldMDEntryOriginator::RAW_TAG :
     case FieldLocationID::RAW_TAG :
     case FieldDeskID::RAW_TAG :
     case FieldOpenCloseSettlFlag::RAW_TAG :
     case FieldTimeInForce::RAW_TAG :
     case FieldExpireDate::RAW_TAG :
     case FieldExpireTime::RAW_TAG :
     case FieldMinQty::RAW_TAG :
     case FieldExecInst::RAW_TAG :
     case FieldSellerDays::RAW_TAG :
     case FieldOrderID::RAW_TAG :
     case FieldQuoteEntryID::RAW_TAG :
     case FieldMDEntryBuyer::RAW_TAG :
     case FieldMDEntrySeller::RAW_TAG :
     case FieldNumberOfOrders::RAW_TAG :
     case FieldMDEntryPositionNo::RAW_TAG :
     case FieldScope::RAW_TAG :
     case FieldPriceDelta::RAW_TAG :
     case FieldText::RAW_TAG :
     case FieldEncodedTextLen::RAW_TAG :
     case FieldEncodedText::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}


// ---------------------------------- getFieldValue ---------------------------------

const char * GroupLegStipulations::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegStipulationType::TAG : return fieldLegStipulationType.offset > 0 ? _fixPtr + fieldLegStipulationType.offset : nullptr;
     case FieldLegStipulationValue::TAG : return fieldLegStipulationValue.offset > 0 ? _fixPtr + fieldLegStipulationValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupEvents::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldEventType::TAG : return fieldEventType.offset > 0 ? _fixPtr + fieldEventType.offset : nullptr;
     case FieldEventDate::TAG : return fieldEventDate.offset > 0 ? _fixPtr + fieldEventDate.offset : nullptr;
     case FieldEventPx::TAG : return fieldEventPx.offset > 0 ? _fixPtr + fieldEventPx.offset : nullptr;
     case FieldEventText::TAG : return fieldEventText.offset > 0 ? _fixPtr + fieldEventText.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLegSecurityAltID::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegSecurityAltID::TAG : return fieldLegSecurityAltID.offset > 0 ? _fixPtr + fieldLegSecurityAltID.offset : nullptr;
     case FieldLegSecurityAltIDSource::TAG : return fieldLegSecurityAltIDSource.offset > 0 ? _fixPtr + fieldLegSecurityAltIDSource.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupCapacities::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldOrderCapacity::TAG : return fieldOrderCapacity.offset > 0 ? _fixPtr + fieldOrderCapacity.offset : nullptr;
     case FieldOrderRestrictions::TAG : return fieldOrderRestrictions.offset > 0 ? _fixPtr + fieldOrderRestrictions.offset : nullptr;
     case FieldOrderCapacityQty::TAG : return fieldOrderCapacityQty.offset > 0 ? _fixPtr + fieldOrderCapacityQty.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNested3PartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNested3PartySubID::TAG : return fieldNested3PartySubID.offset > 0 ? _fixPtr + fieldNested3PartySubID.offset : nullptr;
     case FieldNested3PartySubIDType::TAG : return fieldNested3PartySubIDType.offset > 0 ? _fixPtr + fieldNested3PartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupPartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldPartySubID::TAG : return fieldPartySubID.offset > 0 ? _fixPtr + fieldPartySubID.offset : nullptr;
     case FieldPartySubIDType::TAG : return fieldPartySubIDType.offset > 0 ? _fixPtr + fieldPartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNested2PartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNested2PartySubID::TAG : return fieldNested2PartySubID.offset > 0 ? _fixPtr + fieldNested2PartySubID.offset : nullptr;
     case FieldNested2PartySubIDType::TAG : return fieldNested2PartySubIDType.offset > 0 ? _fixPtr + fieldNested2PartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNested2PartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNested2PartyID::TAG : return fieldNested2PartyID.offset > 0 ? _fixPtr + fieldNested2PartyID.offset : nullptr;
     case FieldNested2PartyIDSource::TAG : return fieldNested2PartyIDSource.offset > 0 ? _fixPtr + fieldNested2PartyIDSource.offset : nullptr;
     case FieldNested2PartyRole::TAG : return fieldNested2PartyRole.offset > 0 ? _fixPtr + fieldNested2PartyRole.offset : nullptr;
     case FieldNoNested2PartySubIDs::TAG : return fieldNoNested2PartySubIDs.offset > 0 ? _fixPtr + fieldNoNested2PartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupHops::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldHopCompID::TAG : return fieldHopCompID.offset > 0 ? _fixPtr + fieldHopCompID.offset : nullptr;
     case FieldHopSendingTime::TAG : return fieldHopSendingTime.offset > 0 ? _fixPtr + fieldHopSendingTime.offset : nullptr;
     case FieldHopRefID::TAG : return fieldHopRefID.offset > 0 ? _fixPtr + fieldHopRefID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupCollInquiryQualifier::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldCollInquiryQualifier::TAG : return fieldCollInquiryQualifier.offset > 0 ? _fixPtr + fieldCollInquiryQualifier.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupPartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldPartyID::TAG : return fieldPartyID.offset > 0 ? _fixPtr + fieldPartyID.offset : nullptr;
     case FieldPartyIDSource::TAG : return fieldPartyIDSource.offset > 0 ? _fixPtr + fieldPartyIDSource.offset : nullptr;
     case FieldPartyRole::TAG : return fieldPartyRole.offset > 0 ? _fixPtr + fieldPartyRole.offset : nullptr;
     case FieldNoPartySubIDs::TAG : return fieldNoPartySubIDs.offset > 0 ? _fixPtr + fieldNoPartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupAllocs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldAllocAccount::TAG : return fieldAllocAccount.offset > 0 ? _fixPtr + fieldAllocAccount.offset : nullptr;
     case FieldAllocAcctIDSource::TAG : return fieldAllocAcctIDSource.offset > 0 ? _fixPtr + fieldAllocAcctIDSource.offset : nullptr;
     case FieldAllocPrice::TAG : return fieldAllocPrice.offset > 0 ? _fixPtr + fieldAllocPrice.offset : nullptr;
     case FieldIndividualAllocID::TAG : return fieldIndividualAllocID.offset > 0 ? _fixPtr + fieldIndividualAllocID.offset : nullptr;
     case FieldIndividualAllocRejCode::TAG : return fieldIndividualAllocRejCode.offset > 0 ? _fixPtr + fieldIndividualAllocRejCode.offset : nullptr;
     case FieldAllocText::TAG : return fieldAllocText.offset > 0 ? _fixPtr + fieldAllocText.offset : nullptr;
     case FieldEncodedAllocTextLen::TAG : return fieldEncodedAllocTextLen.offset > 0 ? _fixPtr + fieldEncodedAllocTextLen.offset : nullptr;
     case FieldEncodedAllocText::TAG : return fieldEncodedAllocText.offset > 0 ? _fixPtr + fieldEncodedAllocText.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupTradingSessions::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldTradingSessionID::TAG : return fieldTradingSessionID.offset > 0 ? _fixPtr + fieldTradingSessionID.offset : nullptr;
     case FieldTradingSessionSubID::TAG : return fieldTradingSessionSubID.offset > 0 ? _fixPtr + fieldTradingSessionSubID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSecurityAltID::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSecurityAltID::TAG : return fieldSecurityAltID.offset > 0 ? _fixPtr + fieldSecurityAltID.offset : nullptr;
     case FieldSecurityAltIDSource::TAG : return fieldSecurityAltIDSource.offset > 0 ? _fixPtr + fieldSecurityAltIDSource.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupUnderlyingSecurityAltID::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldUnderlyingSecurityAltID::TAG : return fieldUnderlyingSecurityAltID.offset > 0 ? _fixPtr + fieldUnderlyingSecurityAltID.offset : nullptr;
     case FieldUnderlyingSecurityAltIDSource::TAG : return fieldUnderlyingSecurityAltIDSource.offset > 0 ? _fixPtr + fieldUnderlyingSecurityAltIDSource.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupUnderlyingStips::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldUnderlyingStipType::TAG : return fieldUnderlyingStipType.offset > 0 ? _fixPtr + fieldUnderlyingStipType.offset : nullptr;
     case FieldUnderlyingStipValue::TAG : return fieldUnderlyingStipValue.offset > 0 ? _fixPtr + fieldUnderlyingStipValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupUnderlyings::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldUnderlyingSymbol::TAG : return fieldUnderlyingSymbol.offset > 0 ? _fixPtr + fieldUnderlyingSymbol.offset : nullptr;
     case FieldUnderlyingSymbolSfx::TAG : return fieldUnderlyingSymbolSfx.offset > 0 ? _fixPtr + fieldUnderlyingSymbolSfx.offset : nullptr;
     case FieldUnderlyingSecurityID::TAG : return fieldUnderlyingSecurityID.offset > 0 ? _fixPtr + fieldUnderlyingSecurityID.offset : nullptr;
     case FieldUnderlyingSecurityIDSource::TAG : return fieldUnderlyingSecurityIDSource.offset > 0 ? _fixPtr + fieldUnderlyingSecurityIDSource.offset : nullptr;
     case FieldNoUnderlyingSecurityAltID::TAG : return fieldNoUnderlyingSecurityAltID.offset > 0 ? _fixPtr + fieldNoUnderlyingSecurityAltID.offset : nullptr;
     case FieldUnderlyingProduct::TAG : return fieldUnderlyingProduct.offset > 0 ? _fixPtr + fieldUnderlyingProduct.offset : nullptr;
     case FieldUnderlyingCFICode::TAG : return fieldUnderlyingCFICode.offset > 0 ? _fixPtr + fieldUnderlyingCFICode.offset : nullptr;
     case FieldUnderlyingSecurityType::TAG : return fieldUnderlyingSecurityType.offset > 0 ? _fixPtr + fieldUnderlyingSecurityType.offset : nullptr;
     case FieldUnderlyingSecuritySubType::TAG : return fieldUnderlyingSecuritySubType.offset > 0 ? _fixPtr + fieldUnderlyingSecuritySubType.offset : nullptr;
     case FieldUnderlyingMaturityMonthYear::TAG : return fieldUnderlyingMaturityMonthYear.offset > 0 ? _fixPtr + fieldUnderlyingMaturityMonthYear.offset : nullptr;
     case FieldUnderlyingMaturityDate::TAG : return fieldUnderlyingMaturityDate.offset > 0 ? _fixPtr + fieldUnderlyingMaturityDate.offset : nullptr;
     case FieldUnderlyingPutOrCall::TAG : return fieldUnderlyingPutOrCall.offset > 0 ? _fixPtr + fieldUnderlyingPutOrCall.offset : nullptr;
     case FieldUnderlyingCouponPaymentDate::TAG : return fieldUnderlyingCouponPaymentDate.offset > 0 ? _fixPtr + fieldUnderlyingCouponPaymentDate.offset : nullptr;
     case FieldUnderlyingIssueDate::TAG : return fieldUnderlyingIssueDate.offset > 0 ? _fixPtr + fieldUnderlyingIssueDate.offset : nullptr;
     case FieldUnderlyingRepoCollateralSecurityType::TAG : return fieldUnderlyingRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldUnderlyingRepoCollateralSecurityType.offset : nullptr;
     case FieldUnderlyingRepurchaseTerm::TAG : return fieldUnderlyingRepurchaseTerm.offset > 0 ? _fixPtr + fieldUnderlyingRepurchaseTerm.offset : nullptr;
     case FieldUnderlyingRepurchaseRate::TAG : return fieldUnderlyingRepurchaseRate.offset > 0 ? _fixPtr + fieldUnderlyingRepurchaseRate.offset : nullptr;
     case FieldUnderlyingFactor::TAG : return fieldUnderlyingFactor.offset > 0 ? _fixPtr + fieldUnderlyingFactor.offset : nullptr;
     case FieldUnderlyingCreditRating::TAG : return fieldUnderlyingCreditRating.offset > 0 ? _fixPtr + fieldUnderlyingCreditRating.offset : nullptr;
     case FieldUnderlyingInstrRegistry::TAG : return fieldUnderlyingInstrRegistry.offset > 0 ? _fixPtr + fieldUnderlyingInstrRegistry.offset : nullptr;
     case FieldUnderlyingCountryOfIssue::TAG : return fieldUnderlyingCountryOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingCountryOfIssue.offset : nullptr;
     case FieldUnderlyingStateOrProvinceOfIssue::TAG : return fieldUnderlyingStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingStateOrProvinceOfIssue.offset : nullptr;
     case FieldUnderlyingLocaleOfIssue::TAG : return fieldUnderlyingLocaleOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingLocaleOfIssue.offset : nullptr;
     case FieldUnderlyingRedemptionDate::TAG : return fieldUnderlyingRedemptionDate.offset > 0 ? _fixPtr + fieldUnderlyingRedemptionDate.offset : nullptr;
     case FieldUnderlyingStrikePrice::TAG : return fieldUnderlyingStrikePrice.offset > 0 ? _fixPtr + fieldUnderlyingStrikePrice.offset : nullptr;
     case FieldUnderlyingStrikeCurrency::TAG : return fieldUnderlyingStrikeCurrency.offset > 0 ? _fixPtr + fieldUnderlyingStrikeCurrency.offset : nullptr;
     case FieldUnderlyingOptAttribute::TAG : return fieldUnderlyingOptAttribute.offset > 0 ? _fixPtr + fieldUnderlyingOptAttribute.offset : nullptr;
     case FieldUnderlyingContractMultiplier::TAG : return fieldUnderlyingContractMultiplier.offset > 0 ? _fixPtr + fieldUnderlyingContractMultiplier.offset : nullptr;
     case FieldUnderlyingCouponRate::TAG : return fieldUnderlyingCouponRate.offset > 0 ? _fixPtr + fieldUnderlyingCouponRate.offset : nullptr;
     case FieldUnderlyingSecurityExchange::TAG : return fieldUnderlyingSecurityExchange.offset > 0 ? _fixPtr + fieldUnderlyingSecurityExchange.offset : nullptr;
     case FieldUnderlyingIssuer::TAG : return fieldUnderlyingIssuer.offset > 0 ? _fixPtr + fieldUnderlyingIssuer.offset : nullptr;
     case FieldEncodedUnderlyingIssuerLen::TAG : return fieldEncodedUnderlyingIssuerLen.offset > 0 ? _fixPtr + fieldEncodedUnderlyingIssuerLen.offset : nullptr;
     case FieldEncodedUnderlyingIssuer::TAG : return fieldEncodedUnderlyingIssuer.offset > 0 ? _fixPtr + fieldEncodedUnderlyingIssuer.offset : nullptr;
     case FieldUnderlyingSecurityDesc::TAG : return fieldUnderlyingSecurityDesc.offset > 0 ? _fixPtr + fieldUnderlyingSecurityDesc.offset : nullptr;
     case FieldEncodedUnderlyingSecurityDescLen::TAG : return fieldEncodedUnderlyingSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedUnderlyingSecurityDescLen.offset : nullptr;
     case FieldEncodedUnderlyingSecurityDesc::TAG : return fieldEncodedUnderlyingSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedUnderlyingSecurityDesc.offset : nullptr;
     case FieldUnderlyingCPProgram::TAG : return fieldUnderlyingCPProgram.offset > 0 ? _fixPtr + fieldUnderlyingCPProgram.offset : nullptr;
     case FieldUnderlyingCPRegType::TAG : return fieldUnderlyingCPRegType.offset > 0 ? _fixPtr + fieldUnderlyingCPRegType.offset : nullptr;
     case FieldUnderlyingCurrency::TAG : return fieldUnderlyingCurrency.offset > 0 ? _fixPtr + fieldUnderlyingCurrency.offset : nullptr;
     case FieldUnderlyingQty::TAG : return fieldUnderlyingQty.offset > 0 ? _fixPtr + fieldUnderlyingQty.offset : nullptr;
     case FieldUnderlyingPx::TAG : return fieldUnderlyingPx.offset > 0 ? _fixPtr + fieldUnderlyingPx.offset : nullptr;
     case FieldUnderlyingDirtyPrice::TAG : return fieldUnderlyingDirtyPrice.offset > 0 ? _fixPtr + fieldUnderlyingDirtyPrice.offset : nullptr;
     case FieldUnderlyingEndPrice::TAG : return fieldUnderlyingEndPrice.offset > 0 ? _fixPtr + fieldUnderlyingEndPrice.offset : nullptr;
     case FieldUnderlyingStartValue::TAG : return fieldUnderlyingStartValue.offset > 0 ? _fixPtr + fieldUnderlyingStartValue.offset : nullptr;
     case FieldUnderlyingCurrentValue::TAG : return fieldUnderlyingCurrentValue.offset > 0 ? _fixPtr + fieldUnderlyingCurrentValue.offset : nullptr;
     case FieldUnderlyingEndValue::TAG : return fieldUnderlyingEndValue.offset > 0 ? _fixPtr + fieldUnderlyingEndValue.offset : nullptr;
     case FieldNoUnderlyingStips::TAG : return fieldNoUnderlyingStips.offset > 0 ? _fixPtr + fieldNoUnderlyingStips.offset : nullptr;
     case FieldUnderlyingSettlPrice::TAG : return fieldUnderlyingSettlPrice.offset > 0 ? _fixPtr + fieldUnderlyingSettlPrice.offset : nullptr;
     case FieldUnderlyingSettlPriceType::TAG : return fieldUnderlyingSettlPriceType.offset > 0 ? _fixPtr + fieldUnderlyingSettlPriceType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupStipulations::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldStipulationType::TAG : return fieldStipulationType.offset > 0 ? _fixPtr + fieldStipulationType.offset : nullptr;
     case FieldStipulationValue::TAG : return fieldStipulationValue.offset > 0 ? _fixPtr + fieldStipulationValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupOrders::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0 ? _fixPtr + fieldClOrdID.offset : nullptr;
     case FieldSecondaryClOrdID::TAG : return fieldSecondaryClOrdID.offset > 0 ? _fixPtr + fieldSecondaryClOrdID.offset : nullptr;
     case FieldListSeqNo::TAG : return fieldListSeqNo.offset > 0 ? _fixPtr + fieldListSeqNo.offset : nullptr;
     case FieldClOrdLinkID::TAG : return fieldClOrdLinkID.offset > 0 ? _fixPtr + fieldClOrdLinkID.offset : nullptr;
     case FieldSettlInstMode::TAG : return fieldSettlInstMode.offset > 0 ? _fixPtr + fieldSettlInstMode.offset : nullptr;
     case FieldNoPartyIDs::TAG : return fieldNoPartyIDs.offset > 0 ? _fixPtr + fieldNoPartyIDs.offset : nullptr;
     case FieldTradeOriginationDate::TAG : return fieldTradeOriginationDate.offset > 0 ? _fixPtr + fieldTradeOriginationDate.offset : nullptr;
     case FieldTradeDate::TAG : return fieldTradeDate.offset > 0 ? _fixPtr + fieldTradeDate.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset > 0 ? _fixPtr + fieldAccount.offset : nullptr;
     case FieldAcctIDSource::TAG : return fieldAcctIDSource.offset > 0 ? _fixPtr + fieldAcctIDSource.offset : nullptr;
     case FieldAccountType::TAG : return fieldAccountType.offset > 0 ? _fixPtr + fieldAccountType.offset : nullptr;
     case FieldDayBookingInst::TAG : return fieldDayBookingInst.offset > 0 ? _fixPtr + fieldDayBookingInst.offset : nullptr;
     case FieldBookingUnit::TAG : return fieldBookingUnit.offset > 0 ? _fixPtr + fieldBookingUnit.offset : nullptr;
     case FieldAllocID::TAG : return fieldAllocID.offset > 0 ? _fixPtr + fieldAllocID.offset : nullptr;
     case FieldPreallocMethod::TAG : return fieldPreallocMethod.offset > 0 ? _fixPtr + fieldPreallocMethod.offset : nullptr;
     case FieldNoAllocs::TAG : return fieldNoAllocs.offset > 0 ? _fixPtr + fieldNoAllocs.offset : nullptr;
     case FieldSettlType::TAG : return fieldSettlType.offset > 0 ? _fixPtr + fieldSettlType.offset : nullptr;
     case FieldSettlDate::TAG : return fieldSettlDate.offset > 0 ? _fixPtr + fieldSettlDate.offset : nullptr;
     case FieldCashMargin::TAG : return fieldCashMargin.offset > 0 ? _fixPtr + fieldCashMargin.offset : nullptr;
     case FieldClearingFeeIndicator::TAG : return fieldClearingFeeIndicator.offset > 0 ? _fixPtr + fieldClearingFeeIndicator.offset : nullptr;
     case FieldHandlInst::TAG : return fieldHandlInst.offset > 0 ? _fixPtr + fieldHandlInst.offset : nullptr;
     case FieldExecInst::TAG : return fieldExecInst.offset > 0 ? _fixPtr + fieldExecInst.offset : nullptr;
     case FieldMinQty::TAG : return fieldMinQty.offset > 0 ? _fixPtr + fieldMinQty.offset : nullptr;
     case FieldMaxFloor::TAG : return fieldMaxFloor.offset > 0 ? _fixPtr + fieldMaxFloor.offset : nullptr;
     case FieldExDestination::TAG : return fieldExDestination.offset > 0 ? _fixPtr + fieldExDestination.offset : nullptr;
     case FieldNoTradingSessions::TAG : return fieldNoTradingSessions.offset > 0 ? _fixPtr + fieldNoTradingSessions.offset : nullptr;
     case FieldProcessCode::TAG : return fieldProcessCode.offset > 0 ? _fixPtr + fieldProcessCode.offset : nullptr;
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSymbolSfx::TAG : return fieldSymbolSfx.offset > 0 ? _fixPtr + fieldSymbolSfx.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSecurityIDSource::TAG : return fieldSecurityIDSource.offset > 0 ? _fixPtr + fieldSecurityIDSource.offset : nullptr;
     case FieldNoSecurityAltID::TAG : return fieldNoSecurityAltID.offset > 0 ? _fixPtr + fieldNoSecurityAltID.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldSecuritySubType::TAG : return fieldSecuritySubType.offset > 0 ? _fixPtr + fieldSecuritySubType.offset : nullptr;
     case FieldMaturityMonthYear::TAG : return fieldMaturityMonthYear.offset > 0 ? _fixPtr + fieldMaturityMonthYear.offset : nullptr;
     case FieldMaturityDate::TAG : return fieldMaturityDate.offset > 0 ? _fixPtr + fieldMaturityDate.offset : nullptr;
     case FieldPutOrCall::TAG : return fieldPutOrCall.offset > 0 ? _fixPtr + fieldPutOrCall.offset : nullptr;
     case FieldCouponPaymentDate::TAG : return fieldCouponPaymentDate.offset > 0 ? _fixPtr + fieldCouponPaymentDate.offset : nullptr;
     case FieldIssueDate::TAG : return fieldIssueDate.offset > 0 ? _fixPtr + fieldIssueDate.offset : nullptr;
     case FieldRepoCollateralSecurityType::TAG : return fieldRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldRepoCollateralSecurityType.offset : nullptr;
     case FieldRepurchaseTerm::TAG : return fieldRepurchaseTerm.offset > 0 ? _fixPtr + fieldRepurchaseTerm.offset : nullptr;
     case FieldRepurchaseRate::TAG : return fieldRepurchaseRate.offset > 0 ? _fixPtr + fieldRepurchaseRate.offset : nullptr;
     case FieldFactor::TAG : return fieldFactor.offset > 0 ? _fixPtr + fieldFactor.offset : nullptr;
     case FieldCreditRating::TAG : return fieldCreditRating.offset > 0 ? _fixPtr + fieldCreditRating.offset : nullptr;
     case FieldInstrRegistry::TAG : return fieldInstrRegistry.offset > 0 ? _fixPtr + fieldInstrRegistry.offset : nullptr;
     case FieldCountryOfIssue::TAG : return fieldCountryOfIssue.offset > 0 ? _fixPtr + fieldCountryOfIssue.offset : nullptr;
     case FieldStateOrProvinceOfIssue::TAG : return fieldStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldStateOrProvinceOfIssue.offset : nullptr;
     case FieldLocaleOfIssue::TAG : return fieldLocaleOfIssue.offset > 0 ? _fixPtr + fieldLocaleOfIssue.offset : nullptr;
     case FieldRedemptionDate::TAG : return fieldRedemptionDate.offset > 0 ? _fixPtr + fieldRedemptionDate.offset : nullptr;
     case FieldStrikePrice::TAG : return fieldStrikePrice.offset > 0 ? _fixPtr + fieldStrikePrice.offset : nullptr;
     case FieldStrikeCurrency::TAG : return fieldStrikeCurrency.offset > 0 ? _fixPtr + fieldStrikeCurrency.offset : nullptr;
     case FieldOptAttribute::TAG : return fieldOptAttribute.offset > 0 ? _fixPtr + fieldOptAttribute.offset : nullptr;
     case FieldContractMultiplier::TAG : return fieldContractMultiplier.offset > 0 ? _fixPtr + fieldContractMultiplier.offset : nullptr;
     case FieldCouponRate::TAG : return fieldCouponRate.offset > 0 ? _fixPtr + fieldCouponRate.offset : nullptr;
     case FieldSecurityExchange::TAG : return fieldSecurityExchange.offset > 0 ? _fixPtr + fieldSecurityExchange.offset : nullptr;
     case FieldIssuer::TAG : return fieldIssuer.offset > 0 ? _fixPtr + fieldIssuer.offset : nullptr;
     case FieldEncodedIssuerLen::TAG : return fieldEncodedIssuerLen.offset > 0 ? _fixPtr + fieldEncodedIssuerLen.offset : nullptr;
     case FieldEncodedIssuer::TAG : return fieldEncodedIssuer.offset > 0 ? _fixPtr + fieldEncodedIssuer.offset : nullptr;
     case FieldSecurityDesc::TAG : return fieldSecurityDesc.offset > 0 ? _fixPtr + fieldSecurityDesc.offset : nullptr;
     case FieldEncodedSecurityDescLen::TAG : return fieldEncodedSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedSecurityDescLen.offset : nullptr;
     case FieldEncodedSecurityDesc::TAG : return fieldEncodedSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedSecurityDesc.offset : nullptr;
     case FieldPool::TAG : return fieldPool.offset > 0 ? _fixPtr + fieldPool.offset : nullptr;
     case FieldContractSettlMonth::TAG : return fieldContractSettlMonth.offset > 0 ? _fixPtr + fieldContractSettlMonth.offset : nullptr;
     case FieldCPProgram::TAG : return fieldCPProgram.offset > 0 ? _fixPtr + fieldCPProgram.offset : nullptr;
     case FieldCPRegType::TAG : return fieldCPRegType.offset > 0 ? _fixPtr + fieldCPRegType.offset : nullptr;
     case FieldNoEvents::TAG : return fieldNoEvents.offset > 0 ? _fixPtr + fieldNoEvents.offset : nullptr;
     case FieldDatedDate::TAG : return fieldDatedDate.offset > 0 ? _fixPtr + fieldDatedDate.offset : nullptr;
     case FieldInterestAccrualDate::TAG : return fieldInterestAccrualDate.offset > 0 ? _fixPtr + fieldInterestAccrualDate.offset : nullptr;
     case FieldNoUnderlyings::TAG : return fieldNoUnderlyings.offset > 0 ? _fixPtr + fieldNoUnderlyings.offset : nullptr;
     case FieldPrevClosePx::TAG : return fieldPrevClosePx.offset > 0 ? _fixPtr + fieldPrevClosePx.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldSideValueInd::TAG : return fieldSideValueInd.offset > 0 ? _fixPtr + fieldSideValueInd.offset : nullptr;
     case FieldLocateReqd::TAG : return fieldLocateReqd.offset > 0 ? _fixPtr + fieldLocateReqd.offset : nullptr;
     case FieldTransactTime::TAG : return fieldTransactTime.offset > 0 ? _fixPtr + fieldTransactTime.offset : nullptr;
     case FieldNoStipulations::TAG : return fieldNoStipulations.offset > 0 ? _fixPtr + fieldNoStipulations.offset : nullptr;
     case FieldQtyType::TAG : return fieldQtyType.offset > 0 ? _fixPtr + fieldQtyType.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0 ? _fixPtr + fieldOrderQty.offset : nullptr;
     case FieldCashOrderQty::TAG : return fieldCashOrderQty.offset > 0 ? _fixPtr + fieldCashOrderQty.offset : nullptr;
     case FieldOrderPercent::TAG : return fieldOrderPercent.offset > 0 ? _fixPtr + fieldOrderPercent.offset : nullptr;
     case FieldRoundingDirection::TAG : return fieldRoundingDirection.offset > 0 ? _fixPtr + fieldRoundingDirection.offset : nullptr;
     case FieldRoundingModulus::TAG : return fieldRoundingModulus.offset > 0 ? _fixPtr + fieldRoundingModulus.offset : nullptr;
     case FieldOrdType::TAG : return fieldOrdType.offset > 0 ? _fixPtr + fieldOrdType.offset : nullptr;
     case FieldPriceType::TAG : return fieldPriceType.offset > 0 ? _fixPtr + fieldPriceType.offset : nullptr;
     case FieldPrice::TAG : return fieldPrice.offset > 0 ? _fixPtr + fieldPrice.offset : nullptr;
     case FieldStopPx::TAG : return fieldStopPx.offset > 0 ? _fixPtr + fieldStopPx.offset : nullptr;
     case FieldSpread::TAG : return fieldSpread.offset > 0 ? _fixPtr + fieldSpread.offset : nullptr;
     case FieldBenchmarkCurveCurrency::TAG : return fieldBenchmarkCurveCurrency.offset > 0 ? _fixPtr + fieldBenchmarkCurveCurrency.offset : nullptr;
     case FieldBenchmarkCurveName::TAG : return fieldBenchmarkCurveName.offset > 0 ? _fixPtr + fieldBenchmarkCurveName.offset : nullptr;
     case FieldBenchmarkCurvePoint::TAG : return fieldBenchmarkCurvePoint.offset > 0 ? _fixPtr + fieldBenchmarkCurvePoint.offset : nullptr;
     case FieldBenchmarkPrice::TAG : return fieldBenchmarkPrice.offset > 0 ? _fixPtr + fieldBenchmarkPrice.offset : nullptr;
     case FieldBenchmarkPriceType::TAG : return fieldBenchmarkPriceType.offset > 0 ? _fixPtr + fieldBenchmarkPriceType.offset : nullptr;
     case FieldBenchmarkSecurityID::TAG : return fieldBenchmarkSecurityID.offset > 0 ? _fixPtr + fieldBenchmarkSecurityID.offset : nullptr;
     case FieldBenchmarkSecurityIDSource::TAG : return fieldBenchmarkSecurityIDSource.offset > 0 ? _fixPtr + fieldBenchmarkSecurityIDSource.offset : nullptr;
     case FieldYieldType::TAG : return fieldYieldType.offset > 0 ? _fixPtr + fieldYieldType.offset : nullptr;
     case FieldYield::TAG : return fieldYield.offset > 0 ? _fixPtr + fieldYield.offset : nullptr;
     case FieldYieldCalcDate::TAG : return fieldYieldCalcDate.offset > 0 ? _fixPtr + fieldYieldCalcDate.offset : nullptr;
     case FieldYieldRedemptionDate::TAG : return fieldYieldRedemptionDate.offset > 0 ? _fixPtr + fieldYieldRedemptionDate.offset : nullptr;
     case FieldYieldRedemptionPrice::TAG : return fieldYieldRedemptionPrice.offset > 0 ? _fixPtr + fieldYieldRedemptionPrice.offset : nullptr;
     case FieldYieldRedemptionPriceType::TAG : return fieldYieldRedemptionPriceType.offset > 0 ? _fixPtr + fieldYieldRedemptionPriceType.offset : nullptr;
     case FieldCurrency::TAG : return fieldCurrency.offset > 0 ? _fixPtr + fieldCurrency.offset : nullptr;
     case FieldComplianceID::TAG : return fieldComplianceID.offset > 0 ? _fixPtr + fieldComplianceID.offset : nullptr;
     case FieldSolicitedFlag::TAG : return fieldSolicitedFlag.offset > 0 ? _fixPtr + fieldSolicitedFlag.offset : nullptr;
     case FieldIOIID::TAG : return fieldIOIID.offset > 0 ? _fixPtr + fieldIOIID.offset : nullptr;
     case FieldQuoteID::TAG : return fieldQuoteID.offset > 0 ? _fixPtr + fieldQuoteID.offset : nullptr;
     case FieldTimeInForce::TAG : return fieldTimeInForce.offset > 0 ? _fixPtr + fieldTimeInForce.offset : nullptr;
     case FieldEffectiveTime::TAG : return fieldEffectiveTime.offset > 0 ? _fixPtr + fieldEffectiveTime.offset : nullptr;
     case FieldExpireDate::TAG : return fieldExpireDate.offset > 0 ? _fixPtr + fieldExpireDate.offset : nullptr;
     case FieldExpireTime::TAG : return fieldExpireTime.offset > 0 ? _fixPtr + fieldExpireTime.offset : nullptr;
     case FieldGTBookingInst::TAG : return fieldGTBookingInst.offset > 0 ? _fixPtr + fieldGTBookingInst.offset : nullptr;
     case FieldCommission::TAG : return fieldCommission.offset > 0 ? _fixPtr + fieldCommission.offset : nullptr;
     case FieldCommType::TAG : return fieldCommType.offset > 0 ? _fixPtr + fieldCommType.offset : nullptr;
     case FieldCommCurrency::TAG : return fieldCommCurrency.offset > 0 ? _fixPtr + fieldCommCurrency.offset : nullptr;
     case FieldFundRenewWaiv::TAG : return fieldFundRenewWaiv.offset > 0 ? _fixPtr + fieldFundRenewWaiv.offset : nullptr;
     case FieldOrderCapacity::TAG : return fieldOrderCapacity.offset > 0 ? _fixPtr + fieldOrderCapacity.offset : nullptr;
     case FieldOrderRestrictions::TAG : return fieldOrderRestrictions.offset > 0 ? _fixPtr + fieldOrderRestrictions.offset : nullptr;
     case FieldCustOrderCapacity::TAG : return fieldCustOrderCapacity.offset > 0 ? _fixPtr + fieldCustOrderCapacity.offset : nullptr;
     case FieldForexReq::TAG : return fieldForexReq.offset > 0 ? _fixPtr + fieldForexReq.offset : nullptr;
     case FieldSettlCurrency::TAG : return fieldSettlCurrency.offset > 0 ? _fixPtr + fieldSettlCurrency.offset : nullptr;
     case FieldBookingType::TAG : return fieldBookingType.offset > 0 ? _fixPtr + fieldBookingType.offset : nullptr;
     case FieldText::TAG : return fieldText.offset > 0 ? _fixPtr + fieldText.offset : nullptr;
     case FieldEncodedTextLen::TAG : return fieldEncodedTextLen.offset > 0 ? _fixPtr + fieldEncodedTextLen.offset : nullptr;
     case FieldEncodedText::TAG : return fieldEncodedText.offset > 0 ? _fixPtr + fieldEncodedText.offset : nullptr;
     case FieldSettlDate2::TAG : return fieldSettlDate2.offset > 0 ? _fixPtr + fieldSettlDate2.offset : nullptr;
     case FieldOrderQty2::TAG : return fieldOrderQty2.offset > 0 ? _fixPtr + fieldOrderQty2.offset : nullptr;
     case FieldPrice2::TAG : return fieldPrice2.offset > 0 ? _fixPtr + fieldPrice2.offset : nullptr;
     case FieldPositionEffect::TAG : return fieldPositionEffect.offset > 0 ? _fixPtr + fieldPositionEffect.offset : nullptr;
     case FieldCoveredOrUncovered::TAG : return fieldCoveredOrUncovered.offset > 0 ? _fixPtr + fieldCoveredOrUncovered.offset : nullptr;
     case FieldMaxShow::TAG : return fieldMaxShow.offset > 0 ? _fixPtr + fieldMaxShow.offset : nullptr;
     case FieldPegOffsetValue::TAG : return fieldPegOffsetValue.offset > 0 ? _fixPtr + fieldPegOffsetValue.offset : nullptr;
     case FieldPegMoveType::TAG : return fieldPegMoveType.offset > 0 ? _fixPtr + fieldPegMoveType.offset : nullptr;
     case FieldPegOffsetType::TAG : return fieldPegOffsetType.offset > 0 ? _fixPtr + fieldPegOffsetType.offset : nullptr;
     case FieldPegLimitType::TAG : return fieldPegLimitType.offset > 0 ? _fixPtr + fieldPegLimitType.offset : nullptr;
     case FieldPegRoundDirection::TAG : return fieldPegRoundDirection.offset > 0 ? _fixPtr + fieldPegRoundDirection.offset : nullptr;
     case FieldPegScope::TAG : return fieldPegScope.offset > 0 ? _fixPtr + fieldPegScope.offset : nullptr;
     case FieldDiscretionInst::TAG : return fieldDiscretionInst.offset > 0 ? _fixPtr + fieldDiscretionInst.offset : nullptr;
     case FieldDiscretionOffsetValue::TAG : return fieldDiscretionOffsetValue.offset > 0 ? _fixPtr + fieldDiscretionOffsetValue.offset : nullptr;
     case FieldDiscretionMoveType::TAG : return fieldDiscretionMoveType.offset > 0 ? _fixPtr + fieldDiscretionMoveType.offset : nullptr;
     case FieldDiscretionOffsetType::TAG : return fieldDiscretionOffsetType.offset > 0 ? _fixPtr + fieldDiscretionOffsetType.offset : nullptr;
     case FieldDiscretionLimitType::TAG : return fieldDiscretionLimitType.offset > 0 ? _fixPtr + fieldDiscretionLimitType.offset : nullptr;
     case FieldDiscretionRoundDirection::TAG : return fieldDiscretionRoundDirection.offset > 0 ? _fixPtr + fieldDiscretionRoundDirection.offset : nullptr;
     case FieldDiscretionScope::TAG : return fieldDiscretionScope.offset > 0 ? _fixPtr + fieldDiscretionScope.offset : nullptr;
     case FieldTargetStrategy::TAG : return fieldTargetStrategy.offset > 0 ? _fixPtr + fieldTargetStrategy.offset : nullptr;
     case FieldTargetStrategyParameters::TAG : return fieldTargetStrategyParameters.offset > 0 ? _fixPtr + fieldTargetStrategyParameters.offset : nullptr;
     case FieldParticipationRate::TAG : return fieldParticipationRate.offset > 0 ? _fixPtr + fieldParticipationRate.offset : nullptr;
     case FieldDesignation::TAG : return fieldDesignation.offset > 0 ? _fixPtr + fieldDesignation.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSettlPartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSettlPartySubID::TAG : return fieldSettlPartySubID.offset > 0 ? _fixPtr + fieldSettlPartySubID.offset : nullptr;
     case FieldSettlPartySubIDType::TAG : return fieldSettlPartySubIDType.offset > 0 ? _fixPtr + fieldSettlPartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSettlPartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSettlPartyID::TAG : return fieldSettlPartyID.offset > 0 ? _fixPtr + fieldSettlPartyID.offset : nullptr;
     case FieldSettlPartyIDSource::TAG : return fieldSettlPartyIDSource.offset > 0 ? _fixPtr + fieldSettlPartyIDSource.offset : nullptr;
     case FieldSettlPartyRole::TAG : return fieldSettlPartyRole.offset > 0 ? _fixPtr + fieldSettlPartyRole.offset : nullptr;
     case FieldNoSettlPartySubIDs::TAG : return fieldNoSettlPartySubIDs.offset > 0 ? _fixPtr + fieldNoSettlPartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupDlvyInst::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSettlInstSource::TAG : return fieldSettlInstSource.offset > 0 ? _fixPtr + fieldSettlInstSource.offset : nullptr;
     case FieldDlvyInstType::TAG : return fieldDlvyInstType.offset > 0 ? _fixPtr + fieldDlvyInstType.offset : nullptr;
     case FieldNoSettlPartyIDs::TAG : return fieldNoSettlPartyIDs.offset > 0 ? _fixPtr + fieldNoSettlPartyIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupClearingInstructions::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldClearingInstruction::TAG : return fieldClearingInstruction.offset > 0 ? _fixPtr + fieldClearingInstruction.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartySubID::TAG : return fieldNestedPartySubID.offset > 0 ? _fixPtr + fieldNestedPartySubID.offset : nullptr;
     case FieldNestedPartySubIDType::TAG : return fieldNestedPartySubIDType.offset > 0 ? _fixPtr + fieldNestedPartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartyID::TAG : return fieldNestedPartyID.offset > 0 ? _fixPtr + fieldNestedPartyID.offset : nullptr;
     case FieldNestedPartyIDSource::TAG : return fieldNestedPartyIDSource.offset > 0 ? _fixPtr + fieldNestedPartyIDSource.offset : nullptr;
     case FieldNestedPartyRole::TAG : return fieldNestedPartyRole.offset > 0 ? _fixPtr + fieldNestedPartyRole.offset : nullptr;
     case FieldNoNestedPartySubIDs::TAG : return fieldNoNestedPartySubIDs.offset > 0 ? _fixPtr + fieldNoNestedPartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLegs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegSymbol::TAG : return fieldLegSymbol.offset > 0 ? _fixPtr + fieldLegSymbol.offset : nullptr;
     case FieldLegSymbolSfx::TAG : return fieldLegSymbolSfx.offset > 0 ? _fixPtr + fieldLegSymbolSfx.offset : nullptr;
     case FieldLegSecurityID::TAG : return fieldLegSecurityID.offset > 0 ? _fixPtr + fieldLegSecurityID.offset : nullptr;
     case FieldLegSecurityIDSource::TAG : return fieldLegSecurityIDSource.offset > 0 ? _fixPtr + fieldLegSecurityIDSource.offset : nullptr;
     case FieldNoLegSecurityAltID::TAG : return fieldNoLegSecurityAltID.offset > 0 ? _fixPtr + fieldNoLegSecurityAltID.offset : nullptr;
     case FieldLegProduct::TAG : return fieldLegProduct.offset > 0 ? _fixPtr + fieldLegProduct.offset : nullptr;
     case FieldLegCFICode::TAG : return fieldLegCFICode.offset > 0 ? _fixPtr + fieldLegCFICode.offset : nullptr;
     case FieldLegSecurityType::TAG : return fieldLegSecurityType.offset > 0 ? _fixPtr + fieldLegSecurityType.offset : nullptr;
     case FieldLegSecuritySubType::TAG : return fieldLegSecuritySubType.offset > 0 ? _fixPtr + fieldLegSecuritySubType.offset : nullptr;
     case FieldLegMaturityMonthYear::TAG : return fieldLegMaturityMonthYear.offset > 0 ? _fixPtr + fieldLegMaturityMonthYear.offset : nullptr;
     case FieldLegMaturityDate::TAG : return fieldLegMaturityDate.offset > 0 ? _fixPtr + fieldLegMaturityDate.offset : nullptr;
     case FieldLegCouponPaymentDate::TAG : return fieldLegCouponPaymentDate.offset > 0 ? _fixPtr + fieldLegCouponPaymentDate.offset : nullptr;
     case FieldLegIssueDate::TAG : return fieldLegIssueDate.offset > 0 ? _fixPtr + fieldLegIssueDate.offset : nullptr;
     case FieldLegRepoCollateralSecurityType::TAG : return fieldLegRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldLegRepoCollateralSecurityType.offset : nullptr;
     case FieldLegRepurchaseTerm::TAG : return fieldLegRepurchaseTerm.offset > 0 ? _fixPtr + fieldLegRepurchaseTerm.offset : nullptr;
     case FieldLegRepurchaseRate::TAG : return fieldLegRepurchaseRate.offset > 0 ? _fixPtr + fieldLegRepurchaseRate.offset : nullptr;
     case FieldLegFactor::TAG : return fieldLegFactor.offset > 0 ? _fixPtr + fieldLegFactor.offset : nullptr;
     case FieldLegCreditRating::TAG : return fieldLegCreditRating.offset > 0 ? _fixPtr + fieldLegCreditRating.offset : nullptr;
     case FieldLegInstrRegistry::TAG : return fieldLegInstrRegistry.offset > 0 ? _fixPtr + fieldLegInstrRegistry.offset : nullptr;
     case FieldLegCountryOfIssue::TAG : return fieldLegCountryOfIssue.offset > 0 ? _fixPtr + fieldLegCountryOfIssue.offset : nullptr;
     case FieldLegStateOrProvinceOfIssue::TAG : return fieldLegStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldLegStateOrProvinceOfIssue.offset : nullptr;
     case FieldLegLocaleOfIssue::TAG : return fieldLegLocaleOfIssue.offset > 0 ? _fixPtr + fieldLegLocaleOfIssue.offset : nullptr;
     case FieldLegRedemptionDate::TAG : return fieldLegRedemptionDate.offset > 0 ? _fixPtr + fieldLegRedemptionDate.offset : nullptr;
     case FieldLegStrikePrice::TAG : return fieldLegStrikePrice.offset > 0 ? _fixPtr + fieldLegStrikePrice.offset : nullptr;
     case FieldLegStrikeCurrency::TAG : return fieldLegStrikeCurrency.offset > 0 ? _fixPtr + fieldLegStrikeCurrency.offset : nullptr;
     case FieldLegOptAttribute::TAG : return fieldLegOptAttribute.offset > 0 ? _fixPtr + fieldLegOptAttribute.offset : nullptr;
     case FieldLegContractMultiplier::TAG : return fieldLegContractMultiplier.offset > 0 ? _fixPtr + fieldLegContractMultiplier.offset : nullptr;
     case FieldLegCouponRate::TAG : return fieldLegCouponRate.offset > 0 ? _fixPtr + fieldLegCouponRate.offset : nullptr;
     case FieldLegSecurityExchange::TAG : return fieldLegSecurityExchange.offset > 0 ? _fixPtr + fieldLegSecurityExchange.offset : nullptr;
     case FieldLegIssuer::TAG : return fieldLegIssuer.offset > 0 ? _fixPtr + fieldLegIssuer.offset : nullptr;
     case FieldEncodedLegIssuerLen::TAG : return fieldEncodedLegIssuerLen.offset > 0 ? _fixPtr + fieldEncodedLegIssuerLen.offset : nullptr;
     case FieldEncodedLegIssuer::TAG : return fieldEncodedLegIssuer.offset > 0 ? _fixPtr + fieldEncodedLegIssuer.offset : nullptr;
     case FieldLegSecurityDesc::TAG : return fieldLegSecurityDesc.offset > 0 ? _fixPtr + fieldLegSecurityDesc.offset : nullptr;
     case FieldEncodedLegSecurityDescLen::TAG : return fieldEncodedLegSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedLegSecurityDescLen.offset : nullptr;
     case FieldEncodedLegSecurityDesc::TAG : return fieldEncodedLegSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedLegSecurityDesc.offset : nullptr;
     case FieldLegRatioQty::TAG : return fieldLegRatioQty.offset > 0 ? _fixPtr + fieldLegRatioQty.offset : nullptr;
     case FieldLegSide::TAG : return fieldLegSide.offset > 0 ? _fixPtr + fieldLegSide.offset : nullptr;
     case FieldLegCurrency::TAG : return fieldLegCurrency.offset > 0 ? _fixPtr + fieldLegCurrency.offset : nullptr;
     case FieldLegPool::TAG : return fieldLegPool.offset > 0 ? _fixPtr + fieldLegPool.offset : nullptr;
     case FieldLegDatedDate::TAG : return fieldLegDatedDate.offset > 0 ? _fixPtr + fieldLegDatedDate.offset : nullptr;
     case FieldLegContractSettlMonth::TAG : return fieldLegContractSettlMonth.offset > 0 ? _fixPtr + fieldLegContractSettlMonth.offset : nullptr;
     case FieldLegInterestAccrualDate::TAG : return fieldLegInterestAccrualDate.offset > 0 ? _fixPtr + fieldLegInterestAccrualDate.offset : nullptr;
     case FieldLegQty::TAG : return fieldLegQty.offset > 0 ? _fixPtr + fieldLegQty.offset : nullptr;
     case FieldLegSwapType::TAG : return fieldLegSwapType.offset > 0 ? _fixPtr + fieldLegSwapType.offset : nullptr;
     case FieldNoLegStipulations::TAG : return fieldNoLegStipulations.offset > 0 ? _fixPtr + fieldNoLegStipulations.offset : nullptr;
     case FieldLegPositionEffect::TAG : return fieldLegPositionEffect.offset > 0 ? _fixPtr + fieldLegPositionEffect.offset : nullptr;
     case FieldLegCoveredOrUncovered::TAG : return fieldLegCoveredOrUncovered.offset > 0 ? _fixPtr + fieldLegCoveredOrUncovered.offset : nullptr;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0 ? _fixPtr + fieldNoNestedPartyIDs.offset : nullptr;
     case FieldLegRefID::TAG : return fieldLegRefID.offset > 0 ? _fixPtr + fieldLegRefID.offset : nullptr;
     case FieldLegPrice::TAG : return fieldLegPrice.offset > 0 ? _fixPtr + fieldLegPrice.offset : nullptr;
     case FieldLegSettlType::TAG : return fieldLegSettlType.offset > 0 ? _fixPtr + fieldLegSettlType.offset : nullptr;
     case FieldLegSettlDate::TAG : return fieldLegSettlDate.offset > 0 ? _fixPtr + fieldLegSettlDate.offset : nullptr;
     case FieldLegLastPx::TAG : return fieldLegLastPx.offset > 0 ? _fixPtr + fieldLegLastPx.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupQuoteEntries::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSymbolSfx::TAG : return fieldSymbolSfx.offset > 0 ? _fixPtr + fieldSymbolSfx.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSecurityIDSource::TAG : return fieldSecurityIDSource.offset > 0 ? _fixPtr + fieldSecurityIDSource.offset : nullptr;
     case FieldNoSecurityAltID::TAG : return fieldNoSecurityAltID.offset > 0 ? _fixPtr + fieldNoSecurityAltID.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldSecuritySubType::TAG : return fieldSecuritySubType.offset > 0 ? _fixPtr + fieldSecuritySubType.offset : nullptr;
     case FieldMaturityMonthYear::TAG : return fieldMaturityMonthYear.offset > 0 ? _fixPtr + fieldMaturityMonthYear.offset : nullptr;
     case FieldMaturityDate::TAG : return fieldMaturityDate.offset > 0 ? _fixPtr + fieldMaturityDate.offset : nullptr;
     case FieldPutOrCall::TAG : return fieldPutOrCall.offset > 0 ? _fixPtr + fieldPutOrCall.offset : nullptr;
     case FieldCouponPaymentDate::TAG : return fieldCouponPaymentDate.offset > 0 ? _fixPtr + fieldCouponPaymentDate.offset : nullptr;
     case FieldIssueDate::TAG : return fieldIssueDate.offset > 0 ? _fixPtr + fieldIssueDate.offset : nullptr;
     case FieldRepoCollateralSecurityType::TAG : return fieldRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldRepoCollateralSecurityType.offset : nullptr;
     case FieldRepurchaseTerm::TAG : return fieldRepurchaseTerm.offset > 0 ? _fixPtr + fieldRepurchaseTerm.offset : nullptr;
     case FieldRepurchaseRate::TAG : return fieldRepurchaseRate.offset > 0 ? _fixPtr + fieldRepurchaseRate.offset : nullptr;
     case FieldFactor::TAG : return fieldFactor.offset > 0 ? _fixPtr + fieldFactor.offset : nullptr;
     case FieldCreditRating::TAG : return fieldCreditRating.offset > 0 ? _fixPtr + fieldCreditRating.offset : nullptr;
     case FieldInstrRegistry::TAG : return fieldInstrRegistry.offset > 0 ? _fixPtr + fieldInstrRegistry.offset : nullptr;
     case FieldCountryOfIssue::TAG : return fieldCountryOfIssue.offset > 0 ? _fixPtr + fieldCountryOfIssue.offset : nullptr;
     case FieldStateOrProvinceOfIssue::TAG : return fieldStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldStateOrProvinceOfIssue.offset : nullptr;
     case FieldLocaleOfIssue::TAG : return fieldLocaleOfIssue.offset > 0 ? _fixPtr + fieldLocaleOfIssue.offset : nullptr;
     case FieldRedemptionDate::TAG : return fieldRedemptionDate.offset > 0 ? _fixPtr + fieldRedemptionDate.offset : nullptr;
     case FieldStrikePrice::TAG : return fieldStrikePrice.offset > 0 ? _fixPtr + fieldStrikePrice.offset : nullptr;
     case FieldStrikeCurrency::TAG : return fieldStrikeCurrency.offset > 0 ? _fixPtr + fieldStrikeCurrency.offset : nullptr;
     case FieldOptAttribute::TAG : return fieldOptAttribute.offset > 0 ? _fixPtr + fieldOptAttribute.offset : nullptr;
     case FieldContractMultiplier::TAG : return fieldContractMultiplier.offset > 0 ? _fixPtr + fieldContractMultiplier.offset : nullptr;
     case FieldCouponRate::TAG : return fieldCouponRate.offset > 0 ? _fixPtr + fieldCouponRate.offset : nullptr;
     case FieldSecurityExchange::TAG : return fieldSecurityExchange.offset > 0 ? _fixPtr + fieldSecurityExchange.offset : nullptr;
     case FieldIssuer::TAG : return fieldIssuer.offset > 0 ? _fixPtr + fieldIssuer.offset : nullptr;
     case FieldEncodedIssuerLen::TAG : return fieldEncodedIssuerLen.offset > 0 ? _fixPtr + fieldEncodedIssuerLen.offset : nullptr;
     case FieldEncodedIssuer::TAG : return fieldEncodedIssuer.offset > 0 ? _fixPtr + fieldEncodedIssuer.offset : nullptr;
     case FieldSecurityDesc::TAG : return fieldSecurityDesc.offset > 0 ? _fixPtr + fieldSecurityDesc.offset : nullptr;
     case FieldEncodedSecurityDescLen::TAG : return fieldEncodedSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedSecurityDescLen.offset : nullptr;
     case FieldEncodedSecurityDesc::TAG : return fieldEncodedSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedSecurityDesc.offset : nullptr;
     case FieldPool::TAG : return fieldPool.offset > 0 ? _fixPtr + fieldPool.offset : nullptr;
     case FieldContractSettlMonth::TAG : return fieldContractSettlMonth.offset > 0 ? _fixPtr + fieldContractSettlMonth.offset : nullptr;
     case FieldCPProgram::TAG : return fieldCPProgram.offset > 0 ? _fixPtr + fieldCPProgram.offset : nullptr;
     case FieldCPRegType::TAG : return fieldCPRegType.offset > 0 ? _fixPtr + fieldCPRegType.offset : nullptr;
     case FieldNoEvents::TAG : return fieldNoEvents.offset > 0 ? _fixPtr + fieldNoEvents.offset : nullptr;
     case FieldDatedDate::TAG : return fieldDatedDate.offset > 0 ? _fixPtr + fieldDatedDate.offset : nullptr;
     case FieldInterestAccrualDate::TAG : return fieldInterestAccrualDate.offset > 0 ? _fixPtr + fieldInterestAccrualDate.offset : nullptr;
     case FieldAgreementDesc::TAG : return fieldAgreementDesc.offset > 0 ? _fixPtr + fieldAgreementDesc.offset : nullptr;
     case FieldAgreementID::TAG : return fieldAgreementID.offset > 0 ? _fixPtr + fieldAgreementID.offset : nullptr;
     case FieldAgreementDate::TAG : return fieldAgreementDate.offset > 0 ? _fixPtr + fieldAgreementDate.offset : nullptr;
     case FieldAgreementCurrency::TAG : return fieldAgreementCurrency.offset > 0 ? _fixPtr + fieldAgreementCurrency.offset : nullptr;
     case FieldTerminationType::TAG : return fieldTerminationType.offset > 0 ? _fixPtr + fieldTerminationType.offset : nullptr;
     case FieldStartDate::TAG : return fieldStartDate.offset > 0 ? _fixPtr + fieldStartDate.offset : nullptr;
     case FieldEndDate::TAG : return fieldEndDate.offset > 0 ? _fixPtr + fieldEndDate.offset : nullptr;
     case FieldDeliveryType::TAG : return fieldDeliveryType.offset > 0 ? _fixPtr + fieldDeliveryType.offset : nullptr;
     case FieldMarginRatio::TAG : return fieldMarginRatio.offset > 0 ? _fixPtr + fieldMarginRatio.offset : nullptr;
     case FieldNoUnderlyings::TAG : return fieldNoUnderlyings.offset > 0 ? _fixPtr + fieldNoUnderlyings.offset : nullptr;
     case FieldNoLegs::TAG : return fieldNoLegs.offset > 0 ? _fixPtr + fieldNoLegs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupQuoteSets::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldQuoteSetID::TAG : return fieldQuoteSetID.offset > 0 ? _fixPtr + fieldQuoteSetID.offset : nullptr;
     case FieldUnderlyingSymbol::TAG : return fieldUnderlyingSymbol.offset > 0 ? _fixPtr + fieldUnderlyingSymbol.offset : nullptr;
     case FieldUnderlyingSymbolSfx::TAG : return fieldUnderlyingSymbolSfx.offset > 0 ? _fixPtr + fieldUnderlyingSymbolSfx.offset : nullptr;
     case FieldUnderlyingSecurityID::TAG : return fieldUnderlyingSecurityID.offset > 0 ? _fixPtr + fieldUnderlyingSecurityID.offset : nullptr;
     case FieldUnderlyingSecurityIDSource::TAG : return fieldUnderlyingSecurityIDSource.offset > 0 ? _fixPtr + fieldUnderlyingSecurityIDSource.offset : nullptr;
     case FieldNoUnderlyingSecurityAltID::TAG : return fieldNoUnderlyingSecurityAltID.offset > 0 ? _fixPtr + fieldNoUnderlyingSecurityAltID.offset : nullptr;
     case FieldUnderlyingProduct::TAG : return fieldUnderlyingProduct.offset > 0 ? _fixPtr + fieldUnderlyingProduct.offset : nullptr;
     case FieldUnderlyingCFICode::TAG : return fieldUnderlyingCFICode.offset > 0 ? _fixPtr + fieldUnderlyingCFICode.offset : nullptr;
     case FieldUnderlyingSecurityType::TAG : return fieldUnderlyingSecurityType.offset > 0 ? _fixPtr + fieldUnderlyingSecurityType.offset : nullptr;
     case FieldUnderlyingSecuritySubType::TAG : return fieldUnderlyingSecuritySubType.offset > 0 ? _fixPtr + fieldUnderlyingSecuritySubType.offset : nullptr;
     case FieldUnderlyingMaturityMonthYear::TAG : return fieldUnderlyingMaturityMonthYear.offset > 0 ? _fixPtr + fieldUnderlyingMaturityMonthYear.offset : nullptr;
     case FieldUnderlyingMaturityDate::TAG : return fieldUnderlyingMaturityDate.offset > 0 ? _fixPtr + fieldUnderlyingMaturityDate.offset : nullptr;
     case FieldUnderlyingPutOrCall::TAG : return fieldUnderlyingPutOrCall.offset > 0 ? _fixPtr + fieldUnderlyingPutOrCall.offset : nullptr;
     case FieldUnderlyingCouponPaymentDate::TAG : return fieldUnderlyingCouponPaymentDate.offset > 0 ? _fixPtr + fieldUnderlyingCouponPaymentDate.offset : nullptr;
     case FieldUnderlyingIssueDate::TAG : return fieldUnderlyingIssueDate.offset > 0 ? _fixPtr + fieldUnderlyingIssueDate.offset : nullptr;
     case FieldUnderlyingRepoCollateralSecurityType::TAG : return fieldUnderlyingRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldUnderlyingRepoCollateralSecurityType.offset : nullptr;
     case FieldUnderlyingRepurchaseTerm::TAG : return fieldUnderlyingRepurchaseTerm.offset > 0 ? _fixPtr + fieldUnderlyingRepurchaseTerm.offset : nullptr;
     case FieldUnderlyingRepurchaseRate::TAG : return fieldUnderlyingRepurchaseRate.offset > 0 ? _fixPtr + fieldUnderlyingRepurchaseRate.offset : nullptr;
     case FieldUnderlyingFactor::TAG : return fieldUnderlyingFactor.offset > 0 ? _fixPtr + fieldUnderlyingFactor.offset : nullptr;
     case FieldUnderlyingCreditRating::TAG : return fieldUnderlyingCreditRating.offset > 0 ? _fixPtr + fieldUnderlyingCreditRating.offset : nullptr;
     case FieldUnderlyingInstrRegistry::TAG : return fieldUnderlyingInstrRegistry.offset > 0 ? _fixPtr + fieldUnderlyingInstrRegistry.offset : nullptr;
     case FieldUnderlyingCountryOfIssue::TAG : return fieldUnderlyingCountryOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingCountryOfIssue.offset : nullptr;
     case FieldUnderlyingStateOrProvinceOfIssue::TAG : return fieldUnderlyingStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingStateOrProvinceOfIssue.offset : nullptr;
     case FieldUnderlyingLocaleOfIssue::TAG : return fieldUnderlyingLocaleOfIssue.offset > 0 ? _fixPtr + fieldUnderlyingLocaleOfIssue.offset : nullptr;
     case FieldUnderlyingRedemptionDate::TAG : return fieldUnderlyingRedemptionDate.offset > 0 ? _fixPtr + fieldUnderlyingRedemptionDate.offset : nullptr;
     case FieldUnderlyingStrikePrice::TAG : return fieldUnderlyingStrikePrice.offset > 0 ? _fixPtr + fieldUnderlyingStrikePrice.offset : nullptr;
     case FieldUnderlyingStrikeCurrency::TAG : return fieldUnderlyingStrikeCurrency.offset > 0 ? _fixPtr + fieldUnderlyingStrikeCurrency.offset : nullptr;
     case FieldUnderlyingOptAttribute::TAG : return fieldUnderlyingOptAttribute.offset > 0 ? _fixPtr + fieldUnderlyingOptAttribute.offset : nullptr;
     case FieldUnderlyingContractMultiplier::TAG : return fieldUnderlyingContractMultiplier.offset > 0 ? _fixPtr + fieldUnderlyingContractMultiplier.offset : nullptr;
     case FieldUnderlyingCouponRate::TAG : return fieldUnderlyingCouponRate.offset > 0 ? _fixPtr + fieldUnderlyingCouponRate.offset : nullptr;
     case FieldUnderlyingSecurityExchange::TAG : return fieldUnderlyingSecurityExchange.offset > 0 ? _fixPtr + fieldUnderlyingSecurityExchange.offset : nullptr;
     case FieldUnderlyingIssuer::TAG : return fieldUnderlyingIssuer.offset > 0 ? _fixPtr + fieldUnderlyingIssuer.offset : nullptr;
     case FieldEncodedUnderlyingIssuerLen::TAG : return fieldEncodedUnderlyingIssuerLen.offset > 0 ? _fixPtr + fieldEncodedUnderlyingIssuerLen.offset : nullptr;
     case FieldEncodedUnderlyingIssuer::TAG : return fieldEncodedUnderlyingIssuer.offset > 0 ? _fixPtr + fieldEncodedUnderlyingIssuer.offset : nullptr;
     case FieldUnderlyingSecurityDesc::TAG : return fieldUnderlyingSecurityDesc.offset > 0 ? _fixPtr + fieldUnderlyingSecurityDesc.offset : nullptr;
     case FieldEncodedUnderlyingSecurityDescLen::TAG : return fieldEncodedUnderlyingSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedUnderlyingSecurityDescLen.offset : nullptr;
     case FieldEncodedUnderlyingSecurityDesc::TAG : return fieldEncodedUnderlyingSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedUnderlyingSecurityDesc.offset : nullptr;
     case FieldUnderlyingCPProgram::TAG : return fieldUnderlyingCPProgram.offset > 0 ? _fixPtr + fieldUnderlyingCPProgram.offset : nullptr;
     case FieldUnderlyingCPRegType::TAG : return fieldUnderlyingCPRegType.offset > 0 ? _fixPtr + fieldUnderlyingCPRegType.offset : nullptr;
     case FieldUnderlyingCurrency::TAG : return fieldUnderlyingCurrency.offset > 0 ? _fixPtr + fieldUnderlyingCurrency.offset : nullptr;
     case FieldUnderlyingQty::TAG : return fieldUnderlyingQty.offset > 0 ? _fixPtr + fieldUnderlyingQty.offset : nullptr;
     case FieldUnderlyingPx::TAG : return fieldUnderlyingPx.offset > 0 ? _fixPtr + fieldUnderlyingPx.offset : nullptr;
     case FieldUnderlyingDirtyPrice::TAG : return fieldUnderlyingDirtyPrice.offset > 0 ? _fixPtr + fieldUnderlyingDirtyPrice.offset : nullptr;
     case FieldUnderlyingEndPrice::TAG : return fieldUnderlyingEndPrice.offset > 0 ? _fixPtr + fieldUnderlyingEndPrice.offset : nullptr;
     case FieldUnderlyingStartValue::TAG : return fieldUnderlyingStartValue.offset > 0 ? _fixPtr + fieldUnderlyingStartValue.offset : nullptr;
     case FieldUnderlyingCurrentValue::TAG : return fieldUnderlyingCurrentValue.offset > 0 ? _fixPtr + fieldUnderlyingCurrentValue.offset : nullptr;
     case FieldUnderlyingEndValue::TAG : return fieldUnderlyingEndValue.offset > 0 ? _fixPtr + fieldUnderlyingEndValue.offset : nullptr;
     case FieldNoUnderlyingStips::TAG : return fieldNoUnderlyingStips.offset > 0 ? _fixPtr + fieldNoUnderlyingStips.offset : nullptr;
     case FieldTotNoQuoteEntries::TAG : return fieldTotNoQuoteEntries.offset > 0 ? _fixPtr + fieldTotNoQuoteEntries.offset : nullptr;
     case FieldLastFragment::TAG : return fieldLastFragment.offset > 0 ? _fixPtr + fieldLastFragment.offset : nullptr;
     case FieldNoQuoteEntries::TAG : return fieldNoQuoteEntries.offset > 0 ? _fixPtr + fieldNoQuoteEntries.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSecurityTypes::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldSecuritySubType::TAG : return fieldSecuritySubType.offset > 0 ? _fixPtr + fieldSecuritySubType.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNested3PartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNested3PartyID::TAG : return fieldNested3PartyID.offset > 0 ? _fixPtr + fieldNested3PartyID.offset : nullptr;
     case FieldNested3PartyIDSource::TAG : return fieldNested3PartyIDSource.offset > 0 ? _fixPtr + fieldNested3PartyIDSource.offset : nullptr;
     case FieldNested3PartyRole::TAG : return fieldNested3PartyRole.offset > 0 ? _fixPtr + fieldNested3PartyRole.offset : nullptr;
     case FieldNoNested3PartySubIDs::TAG : return fieldNoNested3PartySubIDs.offset > 0 ? _fixPtr + fieldNoNested3PartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupPositions::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldPosType::TAG : return fieldPosType.offset > 0 ? _fixPtr + fieldPosType.offset : nullptr;
     case FieldLongQty::TAG : return fieldLongQty.offset > 0 ? _fixPtr + fieldLongQty.offset : nullptr;
     case FieldShortQty::TAG : return fieldShortQty.offset > 0 ? _fixPtr + fieldShortQty.offset : nullptr;
     case FieldPosQtyStatus::TAG : return fieldPosQtyStatus.offset > 0 ? _fixPtr + fieldPosQtyStatus.offset : nullptr;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0 ? _fixPtr + fieldNoNestedPartyIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupAffectedOrders::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldOrigClOrdID::TAG : return fieldOrigClOrdID.offset > 0 ? _fixPtr + fieldOrigClOrdID.offset : nullptr;
     case FieldAffectedOrderID::TAG : return fieldAffectedOrderID.offset > 0 ? _fixPtr + fieldAffectedOrderID.offset : nullptr;
     case FieldAffectedSecondaryOrderID::TAG : return fieldAffectedSecondaryOrderID.offset > 0 ? _fixPtr + fieldAffectedSecondaryOrderID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupExecs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLastQty::TAG : return fieldLastQty.offset > 0 ? _fixPtr + fieldLastQty.offset : nullptr;
     case FieldExecID::TAG : return fieldExecID.offset > 0 ? _fixPtr + fieldExecID.offset : nullptr;
     case FieldSecondaryExecID::TAG : return fieldSecondaryExecID.offset > 0 ? _fixPtr + fieldSecondaryExecID.offset : nullptr;
     case FieldLastPx::TAG : return fieldLastPx.offset > 0 ? _fixPtr + fieldLastPx.offset : nullptr;
     case FieldLastParPx::TAG : return fieldLastParPx.offset > 0 ? _fixPtr + fieldLastParPx.offset : nullptr;
     case FieldLastCapacity::TAG : return fieldLastCapacity.offset > 0 ? _fixPtr + fieldLastCapacity.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupMsgTypes::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldRefMsgType::TAG : return fieldRefMsgType.offset > 0 ? _fixPtr + fieldRefMsgType.offset : nullptr;
     case FieldMsgDirection::TAG : return fieldMsgDirection.offset > 0 ? _fixPtr + fieldMsgDirection.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupBidComponents::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldListID::TAG : return fieldListID.offset > 0 ? _fixPtr + fieldListID.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldTradingSessionID::TAG : return fieldTradingSessionID.offset > 0 ? _fixPtr + fieldTradingSessionID.offset : nullptr;
     case FieldTradingSessionSubID::TAG : return fieldTradingSessionSubID.offset > 0 ? _fixPtr + fieldTradingSessionSubID.offset : nullptr;
     case FieldNetGrossInd::TAG : return fieldNetGrossInd.offset > 0 ? _fixPtr + fieldNetGrossInd.offset : nullptr;
     case FieldSettlType::TAG : return fieldSettlType.offset > 0 ? _fixPtr + fieldSettlType.offset : nullptr;
     case FieldSettlDate::TAG : return fieldSettlDate.offset > 0 ? _fixPtr + fieldSettlDate.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset > 0 ? _fixPtr + fieldAccount.offset : nullptr;
     case FieldAcctIDSource::TAG : return fieldAcctIDSource.offset > 0 ? _fixPtr + fieldAcctIDSource.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSettlInst::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSettlInstID::TAG : return fieldSettlInstID.offset > 0 ? _fixPtr + fieldSettlInstID.offset : nullptr;
     case FieldSettlInstTransType::TAG : return fieldSettlInstTransType.offset > 0 ? _fixPtr + fieldSettlInstTransType.offset : nullptr;
     case FieldSettlInstRefID::TAG : return fieldSettlInstRefID.offset > 0 ? _fixPtr + fieldSettlInstRefID.offset : nullptr;
     case FieldNoPartyIDs::TAG : return fieldNoPartyIDs.offset > 0 ? _fixPtr + fieldNoPartyIDs.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;
     case FieldEffectiveTime::TAG : return fieldEffectiveTime.offset > 0 ? _fixPtr + fieldEffectiveTime.offset : nullptr;
     case FieldExpireTime::TAG : return fieldExpireTime.offset > 0 ? _fixPtr + fieldExpireTime.offset : nullptr;
     case FieldLastUpdateTime::TAG : return fieldLastUpdateTime.offset > 0 ? _fixPtr + fieldLastUpdateTime.offset : nullptr;
     case FieldSettlDeliveryType::TAG : return fieldSettlDeliveryType.offset > 0 ? _fixPtr + fieldSettlDeliveryType.offset : nullptr;
     case FieldStandInstDbType::TAG : return fieldStandInstDbType.offset > 0 ? _fixPtr + fieldStandInstDbType.offset : nullptr;
     case FieldStandInstDbName::TAG : return fieldStandInstDbName.offset > 0 ? _fixPtr + fieldStandInstDbName.offset : nullptr;
     case FieldStandInstDbID::TAG : return fieldStandInstDbID.offset > 0 ? _fixPtr + fieldStandInstDbID.offset : nullptr;
     case FieldNoDlvyInst::TAG : return fieldNoDlvyInst.offset > 0 ? _fixPtr + fieldNoDlvyInst.offset : nullptr;
     case FieldPaymentMethod::TAG : return fieldPaymentMethod.offset > 0 ? _fixPtr + fieldPaymentMethod.offset : nullptr;
     case FieldPaymentRef::TAG : return fieldPaymentRef.offset > 0 ? _fixPtr + fieldPaymentRef.offset : nullptr;
     case FieldCardHolderName::TAG : return fieldCardHolderName.offset > 0 ? _fixPtr + fieldCardHolderName.offset : nullptr;
     case FieldCardNumber::TAG : return fieldCardNumber.offset > 0 ? _fixPtr + fieldCardNumber.offset : nullptr;
     case FieldCardStartDate::TAG : return fieldCardStartDate.offset > 0 ? _fixPtr + fieldCardStartDate.offset : nullptr;
     case FieldCardExpDate::TAG : return fieldCardExpDate.offset > 0 ? _fixPtr + fieldCardExpDate.offset : nullptr;
     case FieldCardIssNum::TAG : return fieldCardIssNum.offset > 0 ? _fixPtr + fieldCardIssNum.offset : nullptr;
     case FieldPaymentDate::TAG : return fieldPaymentDate.offset > 0 ? _fixPtr + fieldPaymentDate.offset : nullptr;
     case FieldPaymentRemitterID::TAG : return fieldPaymentRemitterID.offset > 0 ? _fixPtr + fieldPaymentRemitterID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupInstrAttrib::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldInstrAttribType::TAG : return fieldInstrAttribType.offset > 0 ? _fixPtr + fieldInstrAttribType.offset : nullptr;
     case FieldInstrAttribValue::TAG : return fieldInstrAttribValue.offset > 0 ? _fixPtr + fieldInstrAttribValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupMiscFees::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldMiscFeeAmt::TAG : return fieldMiscFeeAmt.offset > 0 ? _fixPtr + fieldMiscFeeAmt.offset : nullptr;
     case FieldMiscFeeCurr::TAG : return fieldMiscFeeCurr.offset > 0 ? _fixPtr + fieldMiscFeeCurr.offset : nullptr;
     case FieldMiscFeeType::TAG : return fieldMiscFeeType.offset > 0 ? _fixPtr + fieldMiscFeeType.offset : nullptr;
     case FieldMiscFeeBasis::TAG : return fieldMiscFeeBasis.offset > 0 ? _fixPtr + fieldMiscFeeBasis.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupQuoteQualifiers::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldQuoteQualifier::TAG : return fieldQuoteQualifier.offset > 0 ? _fixPtr + fieldQuoteQualifier.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupDistribInsts::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldDistribPaymentMethod::TAG : return fieldDistribPaymentMethod.offset > 0 ? _fixPtr + fieldDistribPaymentMethod.offset : nullptr;
     case FieldDistribPercentage::TAG : return fieldDistribPercentage.offset > 0 ? _fixPtr + fieldDistribPercentage.offset : nullptr;
     case FieldCashDistribCurr::TAG : return fieldCashDistribCurr.offset > 0 ? _fixPtr + fieldCashDistribCurr.offset : nullptr;
     case FieldCashDistribAgentName::TAG : return fieldCashDistribAgentName.offset > 0 ? _fixPtr + fieldCashDistribAgentName.offset : nullptr;
     case FieldCashDistribAgentCode::TAG : return fieldCashDistribAgentCode.offset > 0 ? _fixPtr + fieldCashDistribAgentCode.offset : nullptr;
     case FieldCashDistribAgentAcctNumber::TAG : return fieldCashDistribAgentAcctNumber.offset > 0 ? _fixPtr + fieldCashDistribAgentAcctNumber.offset : nullptr;
     case FieldCashDistribPayRef::TAG : return fieldCashDistribPayRef.offset > 0 ? _fixPtr + fieldCashDistribPayRef.offset : nullptr;
     case FieldCashDistribAgentAcctName::TAG : return fieldCashDistribAgentAcctName.offset > 0 ? _fixPtr + fieldCashDistribAgentAcctName.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupTrdRegTimestamps::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldTrdRegTimestamp::TAG : return fieldTrdRegTimestamp.offset > 0 ? _fixPtr + fieldTrdRegTimestamp.offset : nullptr;
     case FieldTrdRegTimestampType::TAG : return fieldTrdRegTimestampType.offset > 0 ? _fixPtr + fieldTrdRegTimestampType.offset : nullptr;
     case FieldTrdRegTimestampOrigin::TAG : return fieldTrdRegTimestampOrigin.offset > 0 ? _fixPtr + fieldTrdRegTimestampOrigin.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupAltMDSource::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldAltMDSourceID::TAG : return fieldAltMDSourceID.offset > 0 ? _fixPtr + fieldAltMDSourceID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupSides::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldOrigClOrdID::TAG : return fieldOrigClOrdID.offset > 0 ? _fixPtr + fieldOrigClOrdID.offset : nullptr;
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0 ? _fixPtr + fieldClOrdID.offset : nullptr;
     case FieldSecondaryClOrdID::TAG : return fieldSecondaryClOrdID.offset > 0 ? _fixPtr + fieldSecondaryClOrdID.offset : nullptr;
     case FieldClOrdLinkID::TAG : return fieldClOrdLinkID.offset > 0 ? _fixPtr + fieldClOrdLinkID.offset : nullptr;
     case FieldOrigOrdModTime::TAG : return fieldOrigOrdModTime.offset > 0 ? _fixPtr + fieldOrigOrdModTime.offset : nullptr;
     case FieldNoPartyIDs::TAG : return fieldNoPartyIDs.offset > 0 ? _fixPtr + fieldNoPartyIDs.offset : nullptr;
     case FieldTradeOriginationDate::TAG : return fieldTradeOriginationDate.offset > 0 ? _fixPtr + fieldTradeOriginationDate.offset : nullptr;
     case FieldTradeDate::TAG : return fieldTradeDate.offset > 0 ? _fixPtr + fieldTradeDate.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0 ? _fixPtr + fieldOrderQty.offset : nullptr;
     case FieldCashOrderQty::TAG : return fieldCashOrderQty.offset > 0 ? _fixPtr + fieldCashOrderQty.offset : nullptr;
     case FieldOrderPercent::TAG : return fieldOrderPercent.offset > 0 ? _fixPtr + fieldOrderPercent.offset : nullptr;
     case FieldRoundingDirection::TAG : return fieldRoundingDirection.offset > 0 ? _fixPtr + fieldRoundingDirection.offset : nullptr;
     case FieldRoundingModulus::TAG : return fieldRoundingModulus.offset > 0 ? _fixPtr + fieldRoundingModulus.offset : nullptr;
     case FieldComplianceID::TAG : return fieldComplianceID.offset > 0 ? _fixPtr + fieldComplianceID.offset : nullptr;
     case FieldText::TAG : return fieldText.offset > 0 ? _fixPtr + fieldText.offset : nullptr;
     case FieldEncodedTextLen::TAG : return fieldEncodedTextLen.offset > 0 ? _fixPtr + fieldEncodedTextLen.offset : nullptr;
     case FieldEncodedText::TAG : return fieldEncodedText.offset > 0 ? _fixPtr + fieldEncodedText.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupRoutingIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldRoutingType::TAG : return fieldRoutingType.offset > 0 ? _fixPtr + fieldRoutingType.offset : nullptr;
     case FieldRoutingID::TAG : return fieldRoutingID.offset > 0 ? _fixPtr + fieldRoutingID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupPosAmt::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldPosAmtType::TAG : return fieldPosAmtType.offset > 0 ? _fixPtr + fieldPosAmtType.offset : nullptr;
     case FieldPosAmt::TAG : return fieldPosAmt.offset > 0 ? _fixPtr + fieldPosAmt.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLinesOfText::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldText::TAG : return fieldText.offset > 0 ? _fixPtr + fieldText.offset : nullptr;
     case FieldEncodedTextLen::TAG : return fieldEncodedTextLen.offset > 0 ? _fixPtr + fieldEncodedTextLen.offset : nullptr;
     case FieldEncodedText::TAG : return fieldEncodedText.offset > 0 ? _fixPtr + fieldEncodedText.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupIOIQualifiers::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldIOIQualifier::TAG : return fieldIOIQualifier.offset > 0 ? _fixPtr + fieldIOIQualifier.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupDates::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldTradeDate::TAG : return fieldTradeDate.offset > 0 ? _fixPtr + fieldTradeDate.offset : nullptr;
     case FieldTransactTime::TAG : return fieldTransactTime.offset > 0 ? _fixPtr + fieldTransactTime.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupMDEntryTypes::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldMDEntryType::TAG : return fieldMDEntryType.offset > 0 ? _fixPtr + fieldMDEntryType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupRelatedSym::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSymbolSfx::TAG : return fieldSymbolSfx.offset > 0 ? _fixPtr + fieldSymbolSfx.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSecurityIDSource::TAG : return fieldSecurityIDSource.offset > 0 ? _fixPtr + fieldSecurityIDSource.offset : nullptr;
     case FieldNoSecurityAltID::TAG : return fieldNoSecurityAltID.offset > 0 ? _fixPtr + fieldNoSecurityAltID.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldSecuritySubType::TAG : return fieldSecuritySubType.offset > 0 ? _fixPtr + fieldSecuritySubType.offset : nullptr;
     case FieldMaturityMonthYear::TAG : return fieldMaturityMonthYear.offset > 0 ? _fixPtr + fieldMaturityMonthYear.offset : nullptr;
     case FieldMaturityDate::TAG : return fieldMaturityDate.offset > 0 ? _fixPtr + fieldMaturityDate.offset : nullptr;
     case FieldPutOrCall::TAG : return fieldPutOrCall.offset > 0 ? _fixPtr + fieldPutOrCall.offset : nullptr;
     case FieldCouponPaymentDate::TAG : return fieldCouponPaymentDate.offset > 0 ? _fixPtr + fieldCouponPaymentDate.offset : nullptr;
     case FieldIssueDate::TAG : return fieldIssueDate.offset > 0 ? _fixPtr + fieldIssueDate.offset : nullptr;
     case FieldRepoCollateralSecurityType::TAG : return fieldRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldRepoCollateralSecurityType.offset : nullptr;
     case FieldRepurchaseTerm::TAG : return fieldRepurchaseTerm.offset > 0 ? _fixPtr + fieldRepurchaseTerm.offset : nullptr;
     case FieldRepurchaseRate::TAG : return fieldRepurchaseRate.offset > 0 ? _fixPtr + fieldRepurchaseRate.offset : nullptr;
     case FieldFactor::TAG : return fieldFactor.offset > 0 ? _fixPtr + fieldFactor.offset : nullptr;
     case FieldCreditRating::TAG : return fieldCreditRating.offset > 0 ? _fixPtr + fieldCreditRating.offset : nullptr;
     case FieldInstrRegistry::TAG : return fieldInstrRegistry.offset > 0 ? _fixPtr + fieldInstrRegistry.offset : nullptr;
     case FieldCountryOfIssue::TAG : return fieldCountryOfIssue.offset > 0 ? _fixPtr + fieldCountryOfIssue.offset : nullptr;
     case FieldStateOrProvinceOfIssue::TAG : return fieldStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldStateOrProvinceOfIssue.offset : nullptr;
     case FieldLocaleOfIssue::TAG : return fieldLocaleOfIssue.offset > 0 ? _fixPtr + fieldLocaleOfIssue.offset : nullptr;
     case FieldRedemptionDate::TAG : return fieldRedemptionDate.offset > 0 ? _fixPtr + fieldRedemptionDate.offset : nullptr;
     case FieldStrikePrice::TAG : return fieldStrikePrice.offset > 0 ? _fixPtr + fieldStrikePrice.offset : nullptr;
     case FieldStrikeCurrency::TAG : return fieldStrikeCurrency.offset > 0 ? _fixPtr + fieldStrikeCurrency.offset : nullptr;
     case FieldOptAttribute::TAG : return fieldOptAttribute.offset > 0 ? _fixPtr + fieldOptAttribute.offset : nullptr;
     case FieldContractMultiplier::TAG : return fieldContractMultiplier.offset > 0 ? _fixPtr + fieldContractMultiplier.offset : nullptr;
     case FieldCouponRate::TAG : return fieldCouponRate.offset > 0 ? _fixPtr + fieldCouponRate.offset : nullptr;
     case FieldSecurityExchange::TAG : return fieldSecurityExchange.offset > 0 ? _fixPtr + fieldSecurityExchange.offset : nullptr;
     case FieldIssuer::TAG : return fieldIssuer.offset > 0 ? _fixPtr + fieldIssuer.offset : nullptr;
     case FieldEncodedIssuerLen::TAG : return fieldEncodedIssuerLen.offset > 0 ? _fixPtr + fieldEncodedIssuerLen.offset : nullptr;
     case FieldEncodedIssuer::TAG : return fieldEncodedIssuer.offset > 0 ? _fixPtr + fieldEncodedIssuer.offset : nullptr;
     case FieldSecurityDesc::TAG : return fieldSecurityDesc.offset > 0 ? _fixPtr + fieldSecurityDesc.offset : nullptr;
     case FieldEncodedSecurityDescLen::TAG : return fieldEncodedSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedSecurityDescLen.offset : nullptr;
     case FieldEncodedSecurityDesc::TAG : return fieldEncodedSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedSecurityDesc.offset : nullptr;
     case FieldPool::TAG : return fieldPool.offset > 0 ? _fixPtr + fieldPool.offset : nullptr;
     case FieldContractSettlMonth::TAG : return fieldContractSettlMonth.offset > 0 ? _fixPtr + fieldContractSettlMonth.offset : nullptr;
     case FieldCPProgram::TAG : return fieldCPProgram.offset > 0 ? _fixPtr + fieldCPProgram.offset : nullptr;
     case FieldCPRegType::TAG : return fieldCPRegType.offset > 0 ? _fixPtr + fieldCPRegType.offset : nullptr;
     case FieldNoEvents::TAG : return fieldNoEvents.offset > 0 ? _fixPtr + fieldNoEvents.offset : nullptr;
     case FieldDatedDate::TAG : return fieldDatedDate.offset > 0 ? _fixPtr + fieldDatedDate.offset : nullptr;
     case FieldInterestAccrualDate::TAG : return fieldInterestAccrualDate.offset > 0 ? _fixPtr + fieldInterestAccrualDate.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupContraBrokers::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldContraBroker::TAG : return fieldContraBroker.offset > 0 ? _fixPtr + fieldContraBroker.offset : nullptr;
     case FieldContraTrader::TAG : return fieldContraTrader.offset > 0 ? _fixPtr + fieldContraTrader.offset : nullptr;
     case FieldContraTradeQty::TAG : return fieldContraTradeQty.offset > 0 ? _fixPtr + fieldContraTradeQty.offset : nullptr;
     case FieldContraTradeTime::TAG : return fieldContraTradeTime.offset > 0 ? _fixPtr + fieldContraTradeTime.offset : nullptr;
     case FieldContraLegRefID::TAG : return fieldContraLegRefID.offset > 0 ? _fixPtr + fieldContraLegRefID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupTrades::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldTradeReportID::TAG : return fieldTradeReportID.offset > 0 ? _fixPtr + fieldTradeReportID.offset : nullptr;
     case FieldSecondaryTradeReportID::TAG : return fieldSecondaryTradeReportID.offset > 0 ? _fixPtr + fieldSecondaryTradeReportID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupStrikes::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSymbolSfx::TAG : return fieldSymbolSfx.offset > 0 ? _fixPtr + fieldSymbolSfx.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSecurityIDSource::TAG : return fieldSecurityIDSource.offset > 0 ? _fixPtr + fieldSecurityIDSource.offset : nullptr;
     case FieldNoSecurityAltID::TAG : return fieldNoSecurityAltID.offset > 0 ? _fixPtr + fieldNoSecurityAltID.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldCFICode::TAG : return fieldCFICode.offset > 0 ? _fixPtr + fieldCFICode.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldSecuritySubType::TAG : return fieldSecuritySubType.offset > 0 ? _fixPtr + fieldSecuritySubType.offset : nullptr;
     case FieldMaturityMonthYear::TAG : return fieldMaturityMonthYear.offset > 0 ? _fixPtr + fieldMaturityMonthYear.offset : nullptr;
     case FieldMaturityDate::TAG : return fieldMaturityDate.offset > 0 ? _fixPtr + fieldMaturityDate.offset : nullptr;
     case FieldPutOrCall::TAG : return fieldPutOrCall.offset > 0 ? _fixPtr + fieldPutOrCall.offset : nullptr;
     case FieldCouponPaymentDate::TAG : return fieldCouponPaymentDate.offset > 0 ? _fixPtr + fieldCouponPaymentDate.offset : nullptr;
     case FieldIssueDate::TAG : return fieldIssueDate.offset > 0 ? _fixPtr + fieldIssueDate.offset : nullptr;
     case FieldRepoCollateralSecurityType::TAG : return fieldRepoCollateralSecurityType.offset > 0 ? _fixPtr + fieldRepoCollateralSecurityType.offset : nullptr;
     case FieldRepurchaseTerm::TAG : return fieldRepurchaseTerm.offset > 0 ? _fixPtr + fieldRepurchaseTerm.offset : nullptr;
     case FieldRepurchaseRate::TAG : return fieldRepurchaseRate.offset > 0 ? _fixPtr + fieldRepurchaseRate.offset : nullptr;
     case FieldFactor::TAG : return fieldFactor.offset > 0 ? _fixPtr + fieldFactor.offset : nullptr;
     case FieldCreditRating::TAG : return fieldCreditRating.offset > 0 ? _fixPtr + fieldCreditRating.offset : nullptr;
     case FieldInstrRegistry::TAG : return fieldInstrRegistry.offset > 0 ? _fixPtr + fieldInstrRegistry.offset : nullptr;
     case FieldCountryOfIssue::TAG : return fieldCountryOfIssue.offset > 0 ? _fixPtr + fieldCountryOfIssue.offset : nullptr;
     case FieldStateOrProvinceOfIssue::TAG : return fieldStateOrProvinceOfIssue.offset > 0 ? _fixPtr + fieldStateOrProvinceOfIssue.offset : nullptr;
     case FieldLocaleOfIssue::TAG : return fieldLocaleOfIssue.offset > 0 ? _fixPtr + fieldLocaleOfIssue.offset : nullptr;
     case FieldRedemptionDate::TAG : return fieldRedemptionDate.offset > 0 ? _fixPtr + fieldRedemptionDate.offset : nullptr;
     case FieldStrikePrice::TAG : return fieldStrikePrice.offset > 0 ? _fixPtr + fieldStrikePrice.offset : nullptr;
     case FieldStrikeCurrency::TAG : return fieldStrikeCurrency.offset > 0 ? _fixPtr + fieldStrikeCurrency.offset : nullptr;
     case FieldOptAttribute::TAG : return fieldOptAttribute.offset > 0 ? _fixPtr + fieldOptAttribute.offset : nullptr;
     case FieldContractMultiplier::TAG : return fieldContractMultiplier.offset > 0 ? _fixPtr + fieldContractMultiplier.offset : nullptr;
     case FieldCouponRate::TAG : return fieldCouponRate.offset > 0 ? _fixPtr + fieldCouponRate.offset : nullptr;
     case FieldSecurityExchange::TAG : return fieldSecurityExchange.offset > 0 ? _fixPtr + fieldSecurityExchange.offset : nullptr;
     case FieldIssuer::TAG : return fieldIssuer.offset > 0 ? _fixPtr + fieldIssuer.offset : nullptr;
     case FieldEncodedIssuerLen::TAG : return fieldEncodedIssuerLen.offset > 0 ? _fixPtr + fieldEncodedIssuerLen.offset : nullptr;
     case FieldEncodedIssuer::TAG : return fieldEncodedIssuer.offset > 0 ? _fixPtr + fieldEncodedIssuer.offset : nullptr;
     case FieldSecurityDesc::TAG : return fieldSecurityDesc.offset > 0 ? _fixPtr + fieldSecurityDesc.offset : nullptr;
     case FieldEncodedSecurityDescLen::TAG : return fieldEncodedSecurityDescLen.offset > 0 ? _fixPtr + fieldEncodedSecurityDescLen.offset : nullptr;
     case FieldEncodedSecurityDesc::TAG : return fieldEncodedSecurityDesc.offset > 0 ? _fixPtr + fieldEncodedSecurityDesc.offset : nullptr;
     case FieldPool::TAG : return fieldPool.offset > 0 ? _fixPtr + fieldPool.offset : nullptr;
     case FieldContractSettlMonth::TAG : return fieldContractSettlMonth.offset > 0 ? _fixPtr + fieldContractSettlMonth.offset : nullptr;
     case FieldCPProgram::TAG : return fieldCPProgram.offset > 0 ? _fixPtr + fieldCPProgram.offset : nullptr;
     case FieldCPRegType::TAG : return fieldCPRegType.offset > 0 ? _fixPtr + fieldCPRegType.offset : nullptr;
     case FieldNoEvents::TAG : return fieldNoEvents.offset > 0 ? _fixPtr + fieldNoEvents.offset : nullptr;
     case FieldDatedDate::TAG : return fieldDatedDate.offset > 0 ? _fixPtr + fieldDatedDate.offset : nullptr;
     case FieldInterestAccrualDate::TAG : return fieldInterestAccrualDate.offset > 0 ? _fixPtr + fieldInterestAccrualDate.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupBidDescriptors::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldBidDescriptorType::TAG : return fieldBidDescriptorType.offset > 0 ? _fixPtr + fieldBidDescriptorType.offset : nullptr;
     case FieldBidDescriptor::TAG : return fieldBidDescriptor.offset > 0 ? _fixPtr + fieldBidDescriptor.offset : nullptr;
     case FieldSideValueInd::TAG : return fieldSideValueInd.offset > 0 ? _fixPtr + fieldSideValueInd.offset : nullptr;
     case FieldLiquidityValue::TAG : return fieldLiquidityValue.offset > 0 ? _fixPtr + fieldLiquidityValue.offset : nullptr;
     case FieldLiquidityNumSecurities::TAG : return fieldLiquidityNumSecurities.offset > 0 ? _fixPtr + fieldLiquidityNumSecurities.offset : nullptr;
     case FieldLiquidityPctLow::TAG : return fieldLiquidityPctLow.offset > 0 ? _fixPtr + fieldLiquidityPctLow.offset : nullptr;
     case FieldLiquidityPctHigh::TAG : return fieldLiquidityPctHigh.offset > 0 ? _fixPtr + fieldLiquidityPctHigh.offset : nullptr;
     case FieldEFPTrackingError::TAG : return fieldEFPTrackingError.offset > 0 ? _fixPtr + fieldEFPTrackingError.offset : nullptr;
     case FieldFairValue::TAG : return fieldFairValue.offset > 0 ? _fixPtr + fieldFairValue.offset : nullptr;
     case FieldOutsideIndexPct::TAG : return fieldOutsideIndexPct.offset > 0 ? _fixPtr + fieldOutsideIndexPct.offset : nullptr;
     case FieldValueOfFutures::TAG : return fieldValueOfFutures.offset > 0 ? _fixPtr + fieldValueOfFutures.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupCompIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldRefCompID::TAG : return fieldRefCompID.offset > 0 ? _fixPtr + fieldRefCompID.offset : nullptr;
     case FieldRefSubID::TAG : return fieldRefSubID.offset > 0 ? _fixPtr + fieldRefSubID.offset : nullptr;
     case FieldLocationID::TAG : return fieldLocationID.offset > 0 ? _fixPtr + fieldLocationID.offset : nullptr;
     case FieldDeskID::TAG : return fieldDeskID.offset > 0 ? _fixPtr + fieldDeskID.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLegAllocs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegAllocAccount::TAG : return fieldLegAllocAccount.offset > 0 ? _fixPtr + fieldLegAllocAccount.offset : nullptr;
     case FieldLegIndividualAllocID::TAG : return fieldLegIndividualAllocID.offset > 0 ? _fixPtr + fieldLegIndividualAllocID.offset : nullptr;
     case FieldNoNested2PartyIDs::TAG : return fieldNoNested2PartyIDs.offset > 0 ? _fixPtr + fieldNoNested2PartyIDs.offset : nullptr;
     case FieldLegAllocQty::TAG : return fieldLegAllocQty.offset > 0 ? _fixPtr + fieldLegAllocQty.offset : nullptr;
     case FieldLegAllocAcctIDSource::TAG : return fieldLegAllocAcctIDSource.offset > 0 ? _fixPtr + fieldLegAllocAcctIDSource.offset : nullptr;
     case FieldLegSettlCurrency::TAG : return fieldLegSettlCurrency.offset > 0 ? _fixPtr + fieldLegSettlCurrency.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupRegistDtls::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldRegistDtls::TAG : return fieldRegistDtls.offset > 0 ? _fixPtr + fieldRegistDtls.offset : nullptr;
     case FieldRegistEmail::TAG : return fieldRegistEmail.offset > 0 ? _fixPtr + fieldRegistEmail.offset : nullptr;
     case FieldMailingDtls::TAG : return fieldMailingDtls.offset > 0 ? _fixPtr + fieldMailingDtls.offset : nullptr;
     case FieldMailingInst::TAG : return fieldMailingInst.offset > 0 ? _fixPtr + fieldMailingInst.offset : nullptr;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0 ? _fixPtr + fieldNoNestedPartyIDs.offset : nullptr;
     case FieldOwnerType::TAG : return fieldOwnerType.offset > 0 ? _fixPtr + fieldOwnerType.offset : nullptr;
     case FieldDateOfBirth::TAG : return fieldDateOfBirth.offset > 0 ? _fixPtr + fieldDateOfBirth.offset : nullptr;
     case FieldInvestorCountryOfResidence::TAG : return fieldInvestorCountryOfResidence.offset > 0 ? _fixPtr + fieldInvestorCountryOfResidence.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupContAmts::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldContAmtType::TAG : return fieldContAmtType.offset > 0 ? _fixPtr + fieldContAmtType.offset : nullptr;
     case FieldContAmtValue::TAG : return fieldContAmtValue.offset > 0 ? _fixPtr + fieldContAmtValue.offset : nullptr;
     case FieldContAmtCurr::TAG : return fieldContAmtCurr.offset > 0 ? _fixPtr + fieldContAmtCurr.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupMDEntries::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldMDEntryType::TAG : return fieldMDEntryType.offset > 0 ? _fixPtr + fieldMDEntryType.offset : nullptr;
     case FieldMDEntryPx::TAG : return fieldMDEntryPx.offset > 0 ? _fixPtr + fieldMDEntryPx.offset : nullptr;
     case FieldCurrency::TAG : return fieldCurrency.offset > 0 ? _fixPtr + fieldCurrency.offset : nullptr;
     case FieldMDEntrySize::TAG : return fieldMDEntrySize.offset > 0 ? _fixPtr + fieldMDEntrySize.offset : nullptr;
     case FieldMDEntryDate::TAG : return fieldMDEntryDate.offset > 0 ? _fixPtr + fieldMDEntryDate.offset : nullptr;
     case FieldMDEntryTime::TAG : return fieldMDEntryTime.offset > 0 ? _fixPtr + fieldMDEntryTime.offset : nullptr;
     case FieldTickDirection::TAG : return fieldTickDirection.offset > 0 ? _fixPtr + fieldTickDirection.offset : nullptr;
     case FieldMDMkt::TAG : return fieldMDMkt.offset > 0 ? _fixPtr + fieldMDMkt.offset : nullptr;
     case FieldTradingSessionID::TAG : return fieldTradingSessionID.offset > 0 ? _fixPtr + fieldTradingSessionID.offset : nullptr;
     case FieldTradingSessionSubID::TAG : return fieldTradingSessionSubID.offset > 0 ? _fixPtr + fieldTradingSessionSubID.offset : nullptr;
     case FieldQuoteCondition::TAG : return fieldQuoteCondition.offset > 0 ? _fixPtr + fieldQuoteCondition.offset : nullptr;
     case FieldTradeCondition::TAG : return fieldTradeCondition.offset > 0 ? _fixPtr + fieldTradeCondition.offset : nullptr;
     case FieldMDEntryOriginator::TAG : return fieldMDEntryOriginator.offset > 0 ? _fixPtr + fieldMDEntryOriginator.offset : nullptr;
     case FieldLocationID::TAG : return fieldLocationID.offset > 0 ? _fixPtr + fieldLocationID.offset : nullptr;
     case FieldDeskID::TAG : return fieldDeskID.offset > 0 ? _fixPtr + fieldDeskID.offset : nullptr;
     case FieldOpenCloseSettlFlag::TAG : return fieldOpenCloseSettlFlag.offset > 0 ? _fixPtr + fieldOpenCloseSettlFlag.offset : nullptr;
     case FieldTimeInForce::TAG : return fieldTimeInForce.offset > 0 ? _fixPtr + fieldTimeInForce.offset : nullptr;
     case FieldExpireDate::TAG : return fieldExpireDate.offset > 0 ? _fixPtr + fieldExpireDate.offset : nullptr;
     case FieldExpireTime::TAG : return fieldExpireTime.offset > 0 ? _fixPtr + fieldExpireTime.offset : nullptr;
     case FieldMinQty::TAG : return fieldMinQty.offset > 0 ? _fixPtr + fieldMinQty.offset : nullptr;
     case FieldExecInst::TAG : return fieldExecInst.offset > 0 ? _fixPtr + fieldExecInst.offset : nullptr;
     case FieldSellerDays::TAG : return fieldSellerDays.offset > 0 ? _fixPtr + fieldSellerDays.offset : nullptr;
     case FieldOrderID::TAG : return fieldOrderID.offset > 0 ? _fixPtr + fieldOrderID.offset : nullptr;
     case FieldQuoteEntryID::TAG : return fieldQuoteEntryID.offset > 0 ? _fixPtr + fieldQuoteEntryID.offset : nullptr;
     case FieldMDEntryBuyer::TAG : return fieldMDEntryBuyer.offset > 0 ? _fixPtr + fieldMDEntryBuyer.offset : nullptr;
     case FieldMDEntrySeller::TAG : return fieldMDEntrySeller.offset > 0 ? _fixPtr + fieldMDEntrySeller.offset : nullptr;
     case FieldNumberOfOrders::TAG : return fieldNumberOfOrders.offset > 0 ? _fixPtr + fieldNumberOfOrders.offset : nullptr;
     case FieldMDEntryPositionNo::TAG : return fieldMDEntryPositionNo.offset > 0 ? _fixPtr + fieldMDEntryPositionNo.offset : nullptr;
     case FieldScope::TAG : return fieldScope.offset > 0 ? _fixPtr + fieldScope.offset : nullptr;
     case FieldPriceDelta::TAG : return fieldPriceDelta.offset > 0 ? _fixPtr + fieldPriceDelta.offset : nullptr;
     case FieldText::TAG : return fieldText.offset > 0 ? _fixPtr + fieldText.offset : nullptr;
     case FieldEncodedTextLen::TAG : return fieldEncodedTextLen.offset > 0 ? _fixPtr + fieldEncodedTextLen.offset : nullptr;
     case FieldEncodedText::TAG : return fieldEncodedText.offset > 0 ? _fixPtr + fieldEncodedText.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}


// ---------------------------------- findBadGroup ---------------------------------

const char * GroupLegStipulations::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupEvents::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupLegSecurityAltID::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupCapacities::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNested3PartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupPartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNested2PartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNested2PartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNested2PartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNested2PartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNested2PartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNested2PartySubIDs.offset - 1 - FieldNoNested2PartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupHops::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupCollInquiryQualifier::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupPartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoPartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoPartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoPartySubIDs.offset - 1 - FieldNoPartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupAllocs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupTradingSessions::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupSecurityAltID::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupUnderlyingSecurityAltID::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupUnderlyingStips::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupUnderlyings::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoUnderlyingSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyingSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyingSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyingSecurityAltID.offset - 1 - FieldNoUnderlyingSecurityAltID::tagWidth(); }
   }
   if( fieldNoUnderlyingStips.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyingStips.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyingStips ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyingStips.offset - 1 - FieldNoUnderlyingStips::tagWidth(); }
   }
   return nullptr;
}

const char * GroupStipulations::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupOrders::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth(); }
   }
   if( fieldNoAllocs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoAllocs.offset );
     unsigned received = 0;
     for( auto & g : groupsAllocs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoAllocs.offset - 1 - FieldNoAllocs::tagWidth(); }
   }
   if( fieldNoTradingSessions.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoTradingSessions.offset );
     unsigned received = 0;
     for( auto & g : groupsTradingSessions ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoTradingSessions.offset - 1 - FieldNoTradingSessions::tagWidth(); }
   }
   if( fieldNoSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth(); }
   }
   if( fieldNoEvents.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoEvents.offset );
     unsigned received = 0;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth(); }
   }
   if( fieldNoUnderlyings.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyings.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyings ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyings.offset - 1 - FieldNoUnderlyings::tagWidth(); }
   }
   if( fieldNoStipulations.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoStipulations.offset );
     unsigned received = 0;
     for( auto & g : groupsStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoStipulations.offset - 1 - FieldNoStipulations::tagWidth(); }
   }
   return nullptr;
}

const char * GroupSettlPartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupSettlPartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoSettlPartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSettlPartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsSettlPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSettlPartySubIDs.offset - 1 - FieldNoSettlPartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupDlvyInst::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoSettlPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSettlPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsSettlPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSettlPartyIDs.offset - 1 - FieldNoSettlPartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupClearingInstructions::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupLegs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoLegSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoLegSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsLegSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoLegSecurityAltID.offset - 1 - FieldNoLegSecurityAltID::tagWidth(); }
   }
   if( fieldNoLegStipulations.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoLegStipulations.offset );
     unsigned received = 0;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth(); }
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupQuoteEntries::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth(); }
   }
   if( fieldNoEvents.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoEvents.offset );
     unsigned received = 0;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth(); }
   }
   if( fieldNoUnderlyings.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyings.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyings ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyings.offset - 1 - FieldNoUnderlyings::tagWidth(); }
   }
   if( fieldNoLegs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoLegs.offset );
     unsigned received = 0;
     for( auto & g : groupsLegs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoLegs.offset - 1 - FieldNoLegs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupQuoteSets::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoUnderlyingSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyingSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyingSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyingSecurityAltID.offset - 1 - FieldNoUnderlyingSecurityAltID::tagWidth(); }
   }
   if( fieldNoUnderlyingStips.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoUnderlyingStips.offset );
     unsigned received = 0;
     for( auto & g : groupsUnderlyingStips ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoUnderlyingStips.offset - 1 - FieldNoUnderlyingStips::tagWidth(); }
   }
   if( fieldNoQuoteEntries.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoQuoteEntries.offset );
     unsigned received = 0;
     for( auto & g : groupsQuoteEntries ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoQuoteEntries.offset - 1 - FieldNoQuoteEntries::tagWidth(); }
   }
   return nullptr;
}

const char * GroupSecurityTypes::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNested3PartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNested3PartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNested3PartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNested3PartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNested3PartySubIDs.offset - 1 - FieldNoNested3PartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupPositions::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupAffectedOrders::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupExecs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupMsgTypes::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupBidComponents::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupSettlInst::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth(); }
   }
   if( fieldNoDlvyInst.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoDlvyInst.offset );
     unsigned received = 0;
     for( auto & g : groupsDlvyInst ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoDlvyInst.offset - 1 - FieldNoDlvyInst::tagWidth(); }
   }
   return nullptr;
}

const char * GroupInstrAttrib::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupMiscFees::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupQuoteQualifiers::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupDistribInsts::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupTrdRegTimestamps::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupAltMDSource::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupSides::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupRoutingIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupPosAmt::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupLinesOfText::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupIOIQualifiers::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupDates::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupMDEntryTypes::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupRelatedSym::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth(); }
   }
   if( fieldNoEvents.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoEvents.offset );
     unsigned received = 0;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth(); }
   }
   return nullptr;
}

const char * GroupContraBrokers::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupTrades::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupStrikes::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoSecurityAltID.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoSecurityAltID.offset );
     unsigned received = 0;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth(); }
   }
   if( fieldNoEvents.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoEvents.offset );
     unsigned received = 0;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth(); }
   }
   return nullptr;
}

const char * GroupBidDescriptors::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupCompIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupLegAllocs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNested2PartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNested2PartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNested2PartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNested2PartyIDs.offset - 1 - FieldNoNested2PartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupRegistDtls::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupContAmts::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupMDEntries::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}


// ---------------------------------- findBadField ---------------------------------

const char * GroupLegStipulations::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegStipulationValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStipulationValue.offset - 1 - FieldLegStipulationValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStipulationValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupEvents::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldEventDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEventDate.offset - 1 - FieldEventDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEventDate.offset] == 1 ) return tagPtr;
   }
   if( fieldEventPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEventPx.offset - 1 - FieldEventPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEventPx.offset] == 1 ) return tagPtr;
   }
   if( fieldEventText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEventText.offset - 1 - FieldEventText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEventText.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupLegSecurityAltID::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegSecurityAltIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityAltIDSource.offset - 1 - FieldLegSecurityAltIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityAltIDSource.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupCapacities::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldOrderRestrictions.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderRestrictions.offset - 1 - FieldOrderRestrictions::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderRestrictions.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderCapacityQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderCapacityQty.offset - 1 - FieldOrderCapacityQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderCapacityQty.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNested3PartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNested3PartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested3PartySubIDType.offset - 1 - FieldNested3PartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested3PartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupPartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldPartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPartySubIDType.offset - 1 - FieldPartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNested2PartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNested2PartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested2PartySubIDType.offset - 1 - FieldNested2PartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested2PartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNested2PartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNested2PartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested2PartyIDSource.offset - 1 - FieldNested2PartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested2PartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNested2PartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested2PartyRole.offset - 1 - FieldNested2PartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested2PartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNested2PartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNested2PartySubIDs.offset - 1 - FieldNoNested2PartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNested2PartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNested2PartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupHops::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldHopSendingTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldHopSendingTime.offset - 1 - FieldHopSendingTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldHopSendingTime.offset] == 1 ) return tagPtr;
   }
   if( fieldHopRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldHopRefID.offset - 1 - FieldHopRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldHopRefID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupCollInquiryQualifier::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupPartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldPartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPartyIDSource.offset - 1 - FieldPartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldPartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPartyRole.offset - 1 - FieldPartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoPartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoPartySubIDs.offset - 1 - FieldNoPartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoPartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupAllocs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldAllocAcctIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAllocAcctIDSource.offset - 1 - FieldAllocAcctIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAllocAcctIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldAllocPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAllocPrice.offset - 1 - FieldAllocPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAllocPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldIndividualAllocID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIndividualAllocID.offset - 1 - FieldIndividualAllocID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIndividualAllocID.offset] == 1 ) return tagPtr;
   }
   if( fieldIndividualAllocRejCode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIndividualAllocRejCode.offset - 1 - FieldIndividualAllocRejCode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIndividualAllocRejCode.offset] == 1 ) return tagPtr;
   }
   if( fieldAllocText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAllocText.offset - 1 - FieldAllocText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAllocText.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedAllocTextLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedAllocTextLen.offset - 1 - FieldEncodedAllocTextLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedAllocTextLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedAllocText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedAllocText.offset - 1 - FieldEncodedAllocText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedAllocText.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupTradingSessions::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldTradingSessionSubID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradingSessionSubID.offset - 1 - FieldTradingSessionSubID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradingSessionSubID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupSecurityAltID::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSecurityAltIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityAltIDSource.offset - 1 - FieldSecurityAltIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityAltIDSource.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupUnderlyingSecurityAltID::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldUnderlyingSecurityAltIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityAltIDSource.offset - 1 - FieldUnderlyingSecurityAltIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityAltIDSource.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupUnderlyingStips::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldUnderlyingStipValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStipValue.offset - 1 - FieldUnderlyingStipValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStipValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupUnderlyings::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldUnderlyingSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSymbolSfx.offset - 1 - FieldUnderlyingSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityID.offset - 1 - FieldUnderlyingSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityIDSource.offset - 1 - FieldUnderlyingSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyingSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyingSecurityAltID.offset - 1 - FieldNoUnderlyingSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyingSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyingSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldUnderlyingProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingProduct.offset - 1 - FieldUnderlyingProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCFICode.offset - 1 - FieldUnderlyingCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityType.offset - 1 - FieldUnderlyingSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecuritySubType.offset - 1 - FieldUnderlyingSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingMaturityMonthYear.offset - 1 - FieldUnderlyingMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingMaturityDate.offset - 1 - FieldUnderlyingMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingPutOrCall.offset - 1 - FieldUnderlyingPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCouponPaymentDate.offset - 1 - FieldUnderlyingCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingIssueDate.offset - 1 - FieldUnderlyingIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepoCollateralSecurityType.offset - 1 - FieldUnderlyingRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepurchaseTerm.offset - 1 - FieldUnderlyingRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepurchaseRate.offset - 1 - FieldUnderlyingRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingFactor.offset - 1 - FieldUnderlyingFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCreditRating.offset - 1 - FieldUnderlyingCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingInstrRegistry.offset - 1 - FieldUnderlyingInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCountryOfIssue.offset - 1 - FieldUnderlyingCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStateOrProvinceOfIssue.offset - 1 - FieldUnderlyingStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingLocaleOfIssue.offset - 1 - FieldUnderlyingLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRedemptionDate.offset - 1 - FieldUnderlyingRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStrikePrice.offset - 1 - FieldUnderlyingStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStrikeCurrency.offset - 1 - FieldUnderlyingStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingOptAttribute.offset - 1 - FieldUnderlyingOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingContractMultiplier.offset - 1 - FieldUnderlyingContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCouponRate.offset - 1 - FieldUnderlyingCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityExchange.offset - 1 - FieldUnderlyingSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingIssuer.offset - 1 - FieldUnderlyingIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingIssuerLen.offset - 1 - FieldEncodedUnderlyingIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingIssuer.offset - 1 - FieldEncodedUnderlyingIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityDesc.offset - 1 - FieldUnderlyingSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingSecurityDescLen.offset - 1 - FieldEncodedUnderlyingSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingSecurityDesc.offset - 1 - FieldEncodedUnderlyingSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCPProgram.offset - 1 - FieldUnderlyingCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCPRegType.offset - 1 - FieldUnderlyingCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCurrency.offset - 1 - FieldUnderlyingCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingQty.offset - 1 - FieldUnderlyingQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingQty.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingPx.offset - 1 - FieldUnderlyingPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingPx.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingDirtyPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingDirtyPrice.offset - 1 - FieldUnderlyingDirtyPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingDirtyPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingEndPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingEndPrice.offset - 1 - FieldUnderlyingEndPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingEndPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStartValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStartValue.offset - 1 - FieldUnderlyingStartValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStartValue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCurrentValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCurrentValue.offset - 1 - FieldUnderlyingCurrentValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCurrentValue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingEndValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingEndValue.offset - 1 - FieldUnderlyingEndValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingEndValue.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyingStips.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyingStips.offset - 1 - FieldNoUnderlyingStips::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyingStips.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyingStips ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldUnderlyingSettlPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSettlPrice.offset - 1 - FieldUnderlyingSettlPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSettlPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSettlPriceType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSettlPriceType.offset - 1 - FieldUnderlyingSettlPriceType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSettlPriceType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupStipulations::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldStipulationValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStipulationValue.offset - 1 - FieldStipulationValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStipulationValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupOrders::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSecondaryClOrdID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecondaryClOrdID.offset - 1 - FieldSecondaryClOrdID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecondaryClOrdID.offset] == 1 ) return tagPtr;
   }
   if( fieldListSeqNo.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldListSeqNo.offset - 1 - FieldListSeqNo::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldListSeqNo.offset] == 1 ) return tagPtr;
   }
   if( fieldClOrdLinkID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldClOrdLinkID.offset - 1 - FieldClOrdLinkID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldClOrdLinkID.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlInstMode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlInstMode.offset - 1 - FieldSettlInstMode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlInstMode.offset] == 1 ) return tagPtr;
   }
   if( fieldNoPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldTradeOriginationDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradeOriginationDate.offset - 1 - FieldTradeOriginationDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradeOriginationDate.offset] == 1 ) return tagPtr;
   }
   if( fieldTradeDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradeDate.offset - 1 - FieldTradeDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradeDate.offset] == 1 ) return tagPtr;
   }
   if( fieldAccount.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAccount.offset - 1 - FieldAccount::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAccount.offset] == 1 ) return tagPtr;
   }
   if( fieldAcctIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAcctIDSource.offset - 1 - FieldAcctIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAcctIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldAccountType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAccountType.offset - 1 - FieldAccountType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAccountType.offset] == 1 ) return tagPtr;
   }
   if( fieldDayBookingInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDayBookingInst.offset - 1 - FieldDayBookingInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDayBookingInst.offset] == 1 ) return tagPtr;
   }
   if( fieldBookingUnit.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBookingUnit.offset - 1 - FieldBookingUnit::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBookingUnit.offset] == 1 ) return tagPtr;
   }
   if( fieldAllocID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAllocID.offset - 1 - FieldAllocID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAllocID.offset] == 1 ) return tagPtr;
   }
   if( fieldPreallocMethod.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPreallocMethod.offset - 1 - FieldPreallocMethod::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPreallocMethod.offset] == 1 ) return tagPtr;
   }
   if( fieldNoAllocs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoAllocs.offset - 1 - FieldNoAllocs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoAllocs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsAllocs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldSettlType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlType.offset - 1 - FieldSettlType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlType.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlDate.offset - 1 - FieldSettlDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlDate.offset] == 1 ) return tagPtr;
   }
   if( fieldCashMargin.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashMargin.offset - 1 - FieldCashMargin::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashMargin.offset] == 1 ) return tagPtr;
   }
   if( fieldClearingFeeIndicator.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldClearingFeeIndicator.offset - 1 - FieldClearingFeeIndicator::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldClearingFeeIndicator.offset] == 1 ) return tagPtr;
   }
   if( fieldHandlInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldHandlInst.offset - 1 - FieldHandlInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldHandlInst.offset] == 1 ) return tagPtr;
   }
   if( fieldExecInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExecInst.offset - 1 - FieldExecInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExecInst.offset] == 1 ) return tagPtr;
   }
   if( fieldMinQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMinQty.offset - 1 - FieldMinQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMinQty.offset] == 1 ) return tagPtr;
   }
   if( fieldMaxFloor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaxFloor.offset - 1 - FieldMaxFloor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaxFloor.offset] == 1 ) return tagPtr;
   }
   if( fieldExDestination.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExDestination.offset - 1 - FieldExDestination::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExDestination.offset] == 1 ) return tagPtr;
   }
   if( fieldNoTradingSessions.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoTradingSessions.offset - 1 - FieldNoTradingSessions::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoTradingSessions.offset] == 1 ) return tagPtr;
     for( auto & g : groupsTradingSessions ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldProcessCode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProcessCode.offset - 1 - FieldProcessCode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProcessCode.offset] == 1 ) return tagPtr;
   }
   if( fieldSymbol.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSymbol.offset - 1 - FieldSymbol::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSymbol.offset] == 1 ) return tagPtr;
   }
   if( fieldSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSymbolSfx.offset - 1 - FieldSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityID.offset - 1 - FieldSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityIDSource.offset - 1 - FieldSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityType.offset - 1 - FieldSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecuritySubType.offset - 1 - FieldSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityMonthYear.offset - 1 - FieldMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityDate.offset - 1 - FieldMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPutOrCall.offset - 1 - FieldPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponPaymentDate.offset - 1 - FieldCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssueDate.offset - 1 - FieldIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepoCollateralSecurityType.offset - 1 - FieldRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseTerm.offset - 1 - FieldRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseRate.offset - 1 - FieldRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFactor.offset - 1 - FieldFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCreditRating.offset - 1 - FieldCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInstrRegistry.offset - 1 - FieldInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCountryOfIssue.offset - 1 - FieldCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStateOrProvinceOfIssue.offset - 1 - FieldStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocaleOfIssue.offset - 1 - FieldLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRedemptionDate.offset - 1 - FieldRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikePrice.offset - 1 - FieldStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikeCurrency.offset - 1 - FieldStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOptAttribute.offset - 1 - FieldOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractMultiplier.offset - 1 - FieldContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponRate.offset - 1 - FieldCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityExchange.offset - 1 - FieldSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssuer.offset - 1 - FieldIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuerLen.offset - 1 - FieldEncodedIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuer.offset - 1 - FieldEncodedIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityDesc.offset - 1 - FieldSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDescLen.offset - 1 - FieldEncodedSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDesc.offset - 1 - FieldEncodedSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldPool.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPool.offset - 1 - FieldPool::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPool.offset] == 1 ) return tagPtr;
   }
   if( fieldContractSettlMonth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractSettlMonth.offset - 1 - FieldContractSettlMonth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractSettlMonth.offset] == 1 ) return tagPtr;
   }
   if( fieldCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPProgram.offset - 1 - FieldCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPRegType.offset - 1 - FieldCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoEvents.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoEvents.offset] == 1 ) return tagPtr;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldDatedDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDatedDate.offset - 1 - FieldDatedDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDatedDate.offset] == 1 ) return tagPtr;
   }
   if( fieldInterestAccrualDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInterestAccrualDate.offset - 1 - FieldInterestAccrualDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInterestAccrualDate.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyings.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyings.offset - 1 - FieldNoUnderlyings::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyings.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyings ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldPrevClosePx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPrevClosePx.offset - 1 - FieldPrevClosePx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPrevClosePx.offset] == 1 ) return tagPtr;
   }
   if( fieldSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSide.offset - 1 - FieldSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSide.offset] == 1 ) return tagPtr;
   }
   if( fieldSideValueInd.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSideValueInd.offset - 1 - FieldSideValueInd::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSideValueInd.offset] == 1 ) return tagPtr;
   }
   if( fieldLocateReqd.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocateReqd.offset - 1 - FieldLocateReqd::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocateReqd.offset] == 1 ) return tagPtr;
   }
   if( fieldTransactTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTransactTime.offset - 1 - FieldTransactTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTransactTime.offset] == 1 ) return tagPtr;
   }
   if( fieldNoStipulations.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoStipulations.offset - 1 - FieldNoStipulations::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoStipulations.offset] == 1 ) return tagPtr;
     for( auto & g : groupsStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldQtyType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldQtyType.offset - 1 - FieldQtyType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldQtyType.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderQty.offset - 1 - FieldOrderQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderQty.offset] == 1 ) return tagPtr;
   }
   if( fieldCashOrderQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashOrderQty.offset - 1 - FieldCashOrderQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashOrderQty.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderPercent.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderPercent.offset - 1 - FieldOrderPercent::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderPercent.offset] == 1 ) return tagPtr;
   }
   if( fieldRoundingDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRoundingDirection.offset - 1 - FieldRoundingDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRoundingDirection.offset] == 1 ) return tagPtr;
   }
   if( fieldRoundingModulus.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRoundingModulus.offset - 1 - FieldRoundingModulus::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRoundingModulus.offset] == 1 ) return tagPtr;
   }
   if( fieldOrdType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrdType.offset - 1 - FieldOrdType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrdType.offset] == 1 ) return tagPtr;
   }
   if( fieldPriceType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPriceType.offset - 1 - FieldPriceType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPriceType.offset] == 1 ) return tagPtr;
   }
   if( fieldPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPrice.offset - 1 - FieldPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldStopPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStopPx.offset - 1 - FieldStopPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStopPx.offset] == 1 ) return tagPtr;
   }
   if( fieldSpread.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSpread.offset - 1 - FieldSpread::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSpread.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkCurveCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkCurveCurrency.offset - 1 - FieldBenchmarkCurveCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkCurveCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkCurveName.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkCurveName.offset - 1 - FieldBenchmarkCurveName::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkCurveName.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkCurvePoint.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkCurvePoint.offset - 1 - FieldBenchmarkCurvePoint::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkCurvePoint.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkPrice.offset - 1 - FieldBenchmarkPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkPriceType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkPriceType.offset - 1 - FieldBenchmarkPriceType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkPriceType.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkSecurityID.offset - 1 - FieldBenchmarkSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldBenchmarkSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBenchmarkSecurityIDSource.offset - 1 - FieldBenchmarkSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBenchmarkSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldYieldType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYieldType.offset - 1 - FieldYieldType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYieldType.offset] == 1 ) return tagPtr;
   }
   if( fieldYield.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYield.offset - 1 - FieldYield::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYield.offset] == 1 ) return tagPtr;
   }
   if( fieldYieldCalcDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYieldCalcDate.offset - 1 - FieldYieldCalcDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYieldCalcDate.offset] == 1 ) return tagPtr;
   }
   if( fieldYieldRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYieldRedemptionDate.offset - 1 - FieldYieldRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYieldRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldYieldRedemptionPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYieldRedemptionPrice.offset - 1 - FieldYieldRedemptionPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYieldRedemptionPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldYieldRedemptionPriceType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldYieldRedemptionPriceType.offset - 1 - FieldYieldRedemptionPriceType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldYieldRedemptionPriceType.offset] == 1 ) return tagPtr;
   }
   if( fieldCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCurrency.offset - 1 - FieldCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldComplianceID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldComplianceID.offset - 1 - FieldComplianceID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldComplianceID.offset] == 1 ) return tagPtr;
   }
   if( fieldSolicitedFlag.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSolicitedFlag.offset - 1 - FieldSolicitedFlag::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSolicitedFlag.offset] == 1 ) return tagPtr;
   }
   if( fieldIOIID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIOIID.offset - 1 - FieldIOIID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIOIID.offset] == 1 ) return tagPtr;
   }
   if( fieldQuoteID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldQuoteID.offset - 1 - FieldQuoteID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldQuoteID.offset] == 1 ) return tagPtr;
   }
   if( fieldTimeInForce.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTimeInForce.offset - 1 - FieldTimeInForce::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTimeInForce.offset] == 1 ) return tagPtr;
   }
   if( fieldEffectiveTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEffectiveTime.offset - 1 - FieldEffectiveTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEffectiveTime.offset] == 1 ) return tagPtr;
   }
   if( fieldExpireDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExpireDate.offset - 1 - FieldExpireDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExpireDate.offset] == 1 ) return tagPtr;
   }
   if( fieldExpireTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExpireTime.offset - 1 - FieldExpireTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExpireTime.offset] == 1 ) return tagPtr;
   }
   if( fieldGTBookingInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldGTBookingInst.offset - 1 - FieldGTBookingInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldGTBookingInst.offset] == 1 ) return tagPtr;
   }
   if( fieldCommission.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCommission.offset - 1 - FieldCommission::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCommission.offset] == 1 ) return tagPtr;
   }
   if( fieldCommType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCommType.offset - 1 - FieldCommType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCommType.offset] == 1 ) return tagPtr;
   }
   if( fieldCommCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCommCurrency.offset - 1 - FieldCommCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCommCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldFundRenewWaiv.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFundRenewWaiv.offset - 1 - FieldFundRenewWaiv::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFundRenewWaiv.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderCapacity.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderCapacity.offset - 1 - FieldOrderCapacity::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderCapacity.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderRestrictions.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderRestrictions.offset - 1 - FieldOrderRestrictions::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderRestrictions.offset] == 1 ) return tagPtr;
   }
   if( fieldCustOrderCapacity.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCustOrderCapacity.offset - 1 - FieldCustOrderCapacity::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCustOrderCapacity.offset] == 1 ) return tagPtr;
   }
   if( fieldForexReq.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldForexReq.offset - 1 - FieldForexReq::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldForexReq.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlCurrency.offset - 1 - FieldSettlCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldBookingType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBookingType.offset - 1 - FieldBookingType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBookingType.offset] == 1 ) return tagPtr;
   }
   if( fieldText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldText.offset - 1 - FieldText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldText.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedTextLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedTextLen.offset - 1 - FieldEncodedTextLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedTextLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedText.offset - 1 - FieldEncodedText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedText.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlDate2.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlDate2.offset - 1 - FieldSettlDate2::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlDate2.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderQty2.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderQty2.offset - 1 - FieldOrderQty2::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderQty2.offset] == 1 ) return tagPtr;
   }
   if( fieldPrice2.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPrice2.offset - 1 - FieldPrice2::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPrice2.offset] == 1 ) return tagPtr;
   }
   if( fieldPositionEffect.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPositionEffect.offset - 1 - FieldPositionEffect::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPositionEffect.offset] == 1 ) return tagPtr;
   }
   if( fieldCoveredOrUncovered.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCoveredOrUncovered.offset - 1 - FieldCoveredOrUncovered::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCoveredOrUncovered.offset] == 1 ) return tagPtr;
   }
   if( fieldMaxShow.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaxShow.offset - 1 - FieldMaxShow::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaxShow.offset] == 1 ) return tagPtr;
   }
   if( fieldPegOffsetValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegOffsetValue.offset - 1 - FieldPegOffsetValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegOffsetValue.offset] == 1 ) return tagPtr;
   }
   if( fieldPegMoveType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegMoveType.offset - 1 - FieldPegMoveType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegMoveType.offset] == 1 ) return tagPtr;
   }
   if( fieldPegOffsetType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegOffsetType.offset - 1 - FieldPegOffsetType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegOffsetType.offset] == 1 ) return tagPtr;
   }
   if( fieldPegLimitType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegLimitType.offset - 1 - FieldPegLimitType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegLimitType.offset] == 1 ) return tagPtr;
   }
   if( fieldPegRoundDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegRoundDirection.offset - 1 - FieldPegRoundDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegRoundDirection.offset] == 1 ) return tagPtr;
   }
   if( fieldPegScope.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPegScope.offset - 1 - FieldPegScope::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPegScope.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionInst.offset - 1 - FieldDiscretionInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionInst.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionOffsetValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionOffsetValue.offset - 1 - FieldDiscretionOffsetValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionOffsetValue.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionMoveType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionMoveType.offset - 1 - FieldDiscretionMoveType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionMoveType.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionOffsetType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionOffsetType.offset - 1 - FieldDiscretionOffsetType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionOffsetType.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionLimitType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionLimitType.offset - 1 - FieldDiscretionLimitType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionLimitType.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionRoundDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionRoundDirection.offset - 1 - FieldDiscretionRoundDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionRoundDirection.offset] == 1 ) return tagPtr;
   }
   if( fieldDiscretionScope.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDiscretionScope.offset - 1 - FieldDiscretionScope::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDiscretionScope.offset] == 1 ) return tagPtr;
   }
   if( fieldTargetStrategy.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTargetStrategy.offset - 1 - FieldTargetStrategy::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTargetStrategy.offset] == 1 ) return tagPtr;
   }
   if( fieldTargetStrategyParameters.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTargetStrategyParameters.offset - 1 - FieldTargetStrategyParameters::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTargetStrategyParameters.offset] == 1 ) return tagPtr;
   }
   if( fieldParticipationRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldParticipationRate.offset - 1 - FieldParticipationRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldParticipationRate.offset] == 1 ) return tagPtr;
   }
   if( fieldDesignation.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDesignation.offset - 1 - FieldDesignation::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDesignation.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupSettlPartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSettlPartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlPartySubIDType.offset - 1 - FieldSettlPartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlPartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupSettlPartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSettlPartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlPartyIDSource.offset - 1 - FieldSettlPartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlPartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlPartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlPartyRole.offset - 1 - FieldSettlPartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlPartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSettlPartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSettlPartySubIDs.offset - 1 - FieldNoSettlPartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSettlPartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSettlPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupDlvyInst::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldDlvyInstType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDlvyInstType.offset - 1 - FieldDlvyInstType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDlvyInstType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSettlPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSettlPartyIDs.offset - 1 - FieldNoSettlPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSettlPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSettlPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupClearingInstructions::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartySubIDType.offset - 1 - FieldNestedPartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyIDSource.offset - 1 - FieldNestedPartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNestedPartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyRole.offset - 1 - FieldNestedPartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupLegs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSymbolSfx.offset - 1 - FieldLegSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityID.offset - 1 - FieldLegSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityIDSource.offset - 1 - FieldLegSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoLegSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoLegSecurityAltID.offset - 1 - FieldNoLegSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoLegSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsLegSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegProduct.offset - 1 - FieldLegProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCFICode.offset - 1 - FieldLegCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityType.offset - 1 - FieldLegSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecuritySubType.offset - 1 - FieldLegSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldLegMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegMaturityMonthYear.offset - 1 - FieldLegMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldLegMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegMaturityDate.offset - 1 - FieldLegMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCouponPaymentDate.offset - 1 - FieldLegCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegIssueDate.offset - 1 - FieldLegIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRepoCollateralSecurityType.offset - 1 - FieldLegRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldLegRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRepurchaseTerm.offset - 1 - FieldLegRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldLegRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRepurchaseRate.offset - 1 - FieldLegRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegFactor.offset - 1 - FieldLegFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCreditRating.offset - 1 - FieldLegCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldLegInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegInstrRegistry.offset - 1 - FieldLegInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCountryOfIssue.offset - 1 - FieldLegCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLegStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStateOrProvinceOfIssue.offset - 1 - FieldLegStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLegLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegLocaleOfIssue.offset - 1 - FieldLegLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLegRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRedemptionDate.offset - 1 - FieldLegRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStrikePrice.offset - 1 - FieldLegStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldLegStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStrikeCurrency.offset - 1 - FieldLegStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldLegOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegOptAttribute.offset - 1 - FieldLegOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldLegContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegContractMultiplier.offset - 1 - FieldLegContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCouponRate.offset - 1 - FieldLegCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityExchange.offset - 1 - FieldLegSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldLegIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegIssuer.offset - 1 - FieldLegIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedLegIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedLegIssuerLen.offset - 1 - FieldEncodedLegIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedLegIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedLegIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedLegIssuer.offset - 1 - FieldEncodedLegIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedLegIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSecurityDesc.offset - 1 - FieldLegSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedLegSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedLegSecurityDescLen.offset - 1 - FieldEncodedLegSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedLegSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedLegSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedLegSecurityDesc.offset - 1 - FieldEncodedLegSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedLegSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldLegRatioQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRatioQty.offset - 1 - FieldLegRatioQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRatioQty.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSide.offset - 1 - FieldLegSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSide.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCurrency.offset - 1 - FieldLegCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldLegPool.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPool.offset - 1 - FieldLegPool::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPool.offset] == 1 ) return tagPtr;
   }
   if( fieldLegDatedDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegDatedDate.offset - 1 - FieldLegDatedDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegDatedDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegContractSettlMonth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegContractSettlMonth.offset - 1 - FieldLegContractSettlMonth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegContractSettlMonth.offset] == 1 ) return tagPtr;
   }
   if( fieldLegInterestAccrualDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegInterestAccrualDate.offset - 1 - FieldLegInterestAccrualDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegInterestAccrualDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegQty.offset - 1 - FieldLegQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegQty.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSwapType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSwapType.offset - 1 - FieldLegSwapType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSwapType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoLegStipulations.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoLegStipulations.offset] == 1 ) return tagPtr;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegPositionEffect.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPositionEffect.offset - 1 - FieldLegPositionEffect::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPositionEffect.offset] == 1 ) return tagPtr;
   }
   if( fieldLegCoveredOrUncovered.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegCoveredOrUncovered.offset - 1 - FieldLegCoveredOrUncovered::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegCoveredOrUncovered.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRefID.offset - 1 - FieldLegRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRefID.offset] == 1 ) return tagPtr;
   }
   if( fieldLegPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPrice.offset - 1 - FieldLegPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSettlType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSettlType.offset - 1 - FieldLegSettlType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSettlType.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSettlDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSettlDate.offset - 1 - FieldLegSettlDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSettlDate.offset] == 1 ) return tagPtr;
   }
   if( fieldLegLastPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegLastPx.offset - 1 - FieldLegLastPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegLastPx.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupQuoteEntries::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSymbolSfx.offset - 1 - FieldSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityID.offset - 1 - FieldSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityIDSource.offset - 1 - FieldSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityType.offset - 1 - FieldSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecuritySubType.offset - 1 - FieldSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityMonthYear.offset - 1 - FieldMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityDate.offset - 1 - FieldMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPutOrCall.offset - 1 - FieldPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponPaymentDate.offset - 1 - FieldCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssueDate.offset - 1 - FieldIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepoCollateralSecurityType.offset - 1 - FieldRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseTerm.offset - 1 - FieldRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseRate.offset - 1 - FieldRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFactor.offset - 1 - FieldFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCreditRating.offset - 1 - FieldCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInstrRegistry.offset - 1 - FieldInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCountryOfIssue.offset - 1 - FieldCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStateOrProvinceOfIssue.offset - 1 - FieldStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocaleOfIssue.offset - 1 - FieldLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRedemptionDate.offset - 1 - FieldRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikePrice.offset - 1 - FieldStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikeCurrency.offset - 1 - FieldStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOptAttribute.offset - 1 - FieldOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractMultiplier.offset - 1 - FieldContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponRate.offset - 1 - FieldCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityExchange.offset - 1 - FieldSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssuer.offset - 1 - FieldIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuerLen.offset - 1 - FieldEncodedIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuer.offset - 1 - FieldEncodedIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityDesc.offset - 1 - FieldSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDescLen.offset - 1 - FieldEncodedSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDesc.offset - 1 - FieldEncodedSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldPool.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPool.offset - 1 - FieldPool::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPool.offset] == 1 ) return tagPtr;
   }
   if( fieldContractSettlMonth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractSettlMonth.offset - 1 - FieldContractSettlMonth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractSettlMonth.offset] == 1 ) return tagPtr;
   }
   if( fieldCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPProgram.offset - 1 - FieldCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPRegType.offset - 1 - FieldCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoEvents.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoEvents.offset] == 1 ) return tagPtr;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldDatedDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDatedDate.offset - 1 - FieldDatedDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDatedDate.offset] == 1 ) return tagPtr;
   }
   if( fieldInterestAccrualDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInterestAccrualDate.offset - 1 - FieldInterestAccrualDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInterestAccrualDate.offset] == 1 ) return tagPtr;
   }
   if( fieldAgreementDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAgreementDesc.offset - 1 - FieldAgreementDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAgreementDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldAgreementID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAgreementID.offset - 1 - FieldAgreementID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAgreementID.offset] == 1 ) return tagPtr;
   }
   if( fieldAgreementDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAgreementDate.offset - 1 - FieldAgreementDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAgreementDate.offset] == 1 ) return tagPtr;
   }
   if( fieldAgreementCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAgreementCurrency.offset - 1 - FieldAgreementCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAgreementCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldTerminationType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTerminationType.offset - 1 - FieldTerminationType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTerminationType.offset] == 1 ) return tagPtr;
   }
   if( fieldStartDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStartDate.offset - 1 - FieldStartDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStartDate.offset] == 1 ) return tagPtr;
   }
   if( fieldEndDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEndDate.offset - 1 - FieldEndDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEndDate.offset] == 1 ) return tagPtr;
   }
   if( fieldDeliveryType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDeliveryType.offset - 1 - FieldDeliveryType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDeliveryType.offset] == 1 ) return tagPtr;
   }
   if( fieldMarginRatio.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMarginRatio.offset - 1 - FieldMarginRatio::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMarginRatio.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyings.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyings.offset - 1 - FieldNoUnderlyings::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyings.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyings ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldNoLegs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoLegs.offset - 1 - FieldNoLegs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoLegs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsLegs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupQuoteSets::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldUnderlyingSymbol.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSymbol.offset - 1 - FieldUnderlyingSymbol::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSymbol.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSymbolSfx.offset - 1 - FieldUnderlyingSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityID.offset - 1 - FieldUnderlyingSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityIDSource.offset - 1 - FieldUnderlyingSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyingSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyingSecurityAltID.offset - 1 - FieldNoUnderlyingSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyingSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyingSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldUnderlyingProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingProduct.offset - 1 - FieldUnderlyingProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCFICode.offset - 1 - FieldUnderlyingCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityType.offset - 1 - FieldUnderlyingSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecuritySubType.offset - 1 - FieldUnderlyingSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingMaturityMonthYear.offset - 1 - FieldUnderlyingMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingMaturityDate.offset - 1 - FieldUnderlyingMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingPutOrCall.offset - 1 - FieldUnderlyingPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCouponPaymentDate.offset - 1 - FieldUnderlyingCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingIssueDate.offset - 1 - FieldUnderlyingIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepoCollateralSecurityType.offset - 1 - FieldUnderlyingRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepurchaseTerm.offset - 1 - FieldUnderlyingRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRepurchaseRate.offset - 1 - FieldUnderlyingRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingFactor.offset - 1 - FieldUnderlyingFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCreditRating.offset - 1 - FieldUnderlyingCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingInstrRegistry.offset - 1 - FieldUnderlyingInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCountryOfIssue.offset - 1 - FieldUnderlyingCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStateOrProvinceOfIssue.offset - 1 - FieldUnderlyingStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingLocaleOfIssue.offset - 1 - FieldUnderlyingLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingRedemptionDate.offset - 1 - FieldUnderlyingRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStrikePrice.offset - 1 - FieldUnderlyingStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStrikeCurrency.offset - 1 - FieldUnderlyingStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingOptAttribute.offset - 1 - FieldUnderlyingOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingContractMultiplier.offset - 1 - FieldUnderlyingContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCouponRate.offset - 1 - FieldUnderlyingCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityExchange.offset - 1 - FieldUnderlyingSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingIssuer.offset - 1 - FieldUnderlyingIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingIssuerLen.offset - 1 - FieldEncodedUnderlyingIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingIssuer.offset - 1 - FieldEncodedUnderlyingIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingSecurityDesc.offset - 1 - FieldUnderlyingSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingSecurityDescLen.offset - 1 - FieldEncodedUnderlyingSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedUnderlyingSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedUnderlyingSecurityDesc.offset - 1 - FieldEncodedUnderlyingSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedUnderlyingSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCPProgram.offset - 1 - FieldUnderlyingCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCPRegType.offset - 1 - FieldUnderlyingCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCurrency.offset - 1 - FieldUnderlyingCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingQty.offset - 1 - FieldUnderlyingQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingQty.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingPx.offset - 1 - FieldUnderlyingPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingPx.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingDirtyPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingDirtyPrice.offset - 1 - FieldUnderlyingDirtyPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingDirtyPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingEndPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingEndPrice.offset - 1 - FieldUnderlyingEndPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingEndPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingStartValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingStartValue.offset - 1 - FieldUnderlyingStartValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingStartValue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingCurrentValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingCurrentValue.offset - 1 - FieldUnderlyingCurrentValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingCurrentValue.offset] == 1 ) return tagPtr;
   }
   if( fieldUnderlyingEndValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldUnderlyingEndValue.offset - 1 - FieldUnderlyingEndValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldUnderlyingEndValue.offset] == 1 ) return tagPtr;
   }
   if( fieldNoUnderlyingStips.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoUnderlyingStips.offset - 1 - FieldNoUnderlyingStips::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoUnderlyingStips.offset] == 1 ) return tagPtr;
     for( auto & g : groupsUnderlyingStips ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldTotNoQuoteEntries.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTotNoQuoteEntries.offset - 1 - FieldTotNoQuoteEntries::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTotNoQuoteEntries.offset] == 1 ) return tagPtr;
   }
   if( fieldLastFragment.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLastFragment.offset - 1 - FieldLastFragment::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLastFragment.offset] == 1 ) return tagPtr;
   }
   if( fieldNoQuoteEntries.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoQuoteEntries.offset - 1 - FieldNoQuoteEntries::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoQuoteEntries.offset] == 1 ) return tagPtr;
     for( auto & g : groupsQuoteEntries ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupSecurityTypes::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecuritySubType.offset - 1 - FieldSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNested3PartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNested3PartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested3PartyIDSource.offset - 1 - FieldNested3PartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested3PartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNested3PartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNested3PartyRole.offset - 1 - FieldNested3PartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNested3PartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNested3PartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNested3PartySubIDs.offset - 1 - FieldNoNested3PartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNested3PartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNested3PartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupPositions::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLongQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLongQty.offset - 1 - FieldLongQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLongQty.offset] == 1 ) return tagPtr;
   }
   if( fieldShortQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldShortQty.offset - 1 - FieldShortQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldShortQty.offset] == 1 ) return tagPtr;
   }
   if( fieldPosQtyStatus.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPosQtyStatus.offset - 1 - FieldPosQtyStatus::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPosQtyStatus.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupAffectedOrders::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldAffectedOrderID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAffectedOrderID.offset - 1 - FieldAffectedOrderID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAffectedOrderID.offset] == 1 ) return tagPtr;
   }
   if( fieldAffectedSecondaryOrderID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAffectedSecondaryOrderID.offset - 1 - FieldAffectedSecondaryOrderID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAffectedSecondaryOrderID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupExecs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldExecID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExecID.offset - 1 - FieldExecID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExecID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecondaryExecID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecondaryExecID.offset - 1 - FieldSecondaryExecID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecondaryExecID.offset] == 1 ) return tagPtr;
   }
   if( fieldLastPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLastPx.offset - 1 - FieldLastPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLastPx.offset] == 1 ) return tagPtr;
   }
   if( fieldLastParPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLastParPx.offset - 1 - FieldLastParPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLastParPx.offset] == 1 ) return tagPtr;
   }
   if( fieldLastCapacity.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLastCapacity.offset - 1 - FieldLastCapacity::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLastCapacity.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupMsgTypes::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldMsgDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMsgDirection.offset - 1 - FieldMsgDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMsgDirection.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupBidComponents::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSide.offset - 1 - FieldSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSide.offset] == 1 ) return tagPtr;
   }
   if( fieldTradingSessionID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradingSessionID.offset - 1 - FieldTradingSessionID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradingSessionID.offset] == 1 ) return tagPtr;
   }
   if( fieldTradingSessionSubID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradingSessionSubID.offset - 1 - FieldTradingSessionSubID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradingSessionSubID.offset] == 1 ) return tagPtr;
   }
   if( fieldNetGrossInd.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNetGrossInd.offset - 1 - FieldNetGrossInd::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNetGrossInd.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlType.offset - 1 - FieldSettlType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlType.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlDate.offset - 1 - FieldSettlDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlDate.offset] == 1 ) return tagPtr;
   }
   if( fieldAccount.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAccount.offset - 1 - FieldAccount::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAccount.offset] == 1 ) return tagPtr;
   }
   if( fieldAcctIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldAcctIDSource.offset - 1 - FieldAcctIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldAcctIDSource.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupSettlInst::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSettlInstTransType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlInstTransType.offset - 1 - FieldSettlInstTransType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlInstTransType.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlInstRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlInstRefID.offset - 1 - FieldSettlInstRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlInstRefID.offset] == 1 ) return tagPtr;
   }
   if( fieldNoPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSide.offset - 1 - FieldSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSide.offset] == 1 ) return tagPtr;
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityType.offset - 1 - FieldSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldEffectiveTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEffectiveTime.offset - 1 - FieldEffectiveTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEffectiveTime.offset] == 1 ) return tagPtr;
   }
   if( fieldExpireTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExpireTime.offset - 1 - FieldExpireTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExpireTime.offset] == 1 ) return tagPtr;
   }
   if( fieldLastUpdateTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLastUpdateTime.offset - 1 - FieldLastUpdateTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLastUpdateTime.offset] == 1 ) return tagPtr;
   }
   if( fieldSettlDeliveryType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSettlDeliveryType.offset - 1 - FieldSettlDeliveryType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSettlDeliveryType.offset] == 1 ) return tagPtr;
   }
   if( fieldStandInstDbType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStandInstDbType.offset - 1 - FieldStandInstDbType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStandInstDbType.offset] == 1 ) return tagPtr;
   }
   if( fieldStandInstDbName.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStandInstDbName.offset - 1 - FieldStandInstDbName::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStandInstDbName.offset] == 1 ) return tagPtr;
   }
   if( fieldStandInstDbID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStandInstDbID.offset - 1 - FieldStandInstDbID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStandInstDbID.offset] == 1 ) return tagPtr;
   }
   if( fieldNoDlvyInst.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoDlvyInst.offset - 1 - FieldNoDlvyInst::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoDlvyInst.offset] == 1 ) return tagPtr;
     for( auto & g : groupsDlvyInst ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldPaymentMethod.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPaymentMethod.offset - 1 - FieldPaymentMethod::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPaymentMethod.offset] == 1 ) return tagPtr;
   }
   if( fieldPaymentRef.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPaymentRef.offset - 1 - FieldPaymentRef::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPaymentRef.offset] == 1 ) return tagPtr;
   }
   if( fieldCardHolderName.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCardHolderName.offset - 1 - FieldCardHolderName::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCardHolderName.offset] == 1 ) return tagPtr;
   }
   if( fieldCardNumber.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCardNumber.offset - 1 - FieldCardNumber::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCardNumber.offset] == 1 ) return tagPtr;
   }
   if( fieldCardStartDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCardStartDate.offset - 1 - FieldCardStartDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCardStartDate.offset] == 1 ) return tagPtr;
   }
   if( fieldCardExpDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCardExpDate.offset - 1 - FieldCardExpDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCardExpDate.offset] == 1 ) return tagPtr;
   }
   if( fieldCardIssNum.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCardIssNum.offset - 1 - FieldCardIssNum::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCardIssNum.offset] == 1 ) return tagPtr;
   }
   if( fieldPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPaymentDate.offset - 1 - FieldPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldPaymentRemitterID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPaymentRemitterID.offset - 1 - FieldPaymentRemitterID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPaymentRemitterID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupInstrAttrib::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldInstrAttribValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInstrAttribValue.offset - 1 - FieldInstrAttribValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInstrAttribValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupMiscFees::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldMiscFeeCurr.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMiscFeeCurr.offset - 1 - FieldMiscFeeCurr::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMiscFeeCurr.offset] == 1 ) return tagPtr;
   }
   if( fieldMiscFeeType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMiscFeeType.offset - 1 - FieldMiscFeeType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMiscFeeType.offset] == 1 ) return tagPtr;
   }
   if( fieldMiscFeeBasis.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMiscFeeBasis.offset - 1 - FieldMiscFeeBasis::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMiscFeeBasis.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupQuoteQualifiers::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupDistribInsts::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldDistribPercentage.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDistribPercentage.offset - 1 - FieldDistribPercentage::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDistribPercentage.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribCurr.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribCurr.offset - 1 - FieldCashDistribCurr::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribCurr.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribAgentName.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribAgentName.offset - 1 - FieldCashDistribAgentName::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribAgentName.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribAgentCode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribAgentCode.offset - 1 - FieldCashDistribAgentCode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribAgentCode.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribAgentAcctNumber.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribAgentAcctNumber.offset - 1 - FieldCashDistribAgentAcctNumber::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribAgentAcctNumber.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribPayRef.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribPayRef.offset - 1 - FieldCashDistribPayRef::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribPayRef.offset] == 1 ) return tagPtr;
   }
   if( fieldCashDistribAgentAcctName.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashDistribAgentAcctName.offset - 1 - FieldCashDistribAgentAcctName::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashDistribAgentAcctName.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupTrdRegTimestamps::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldTrdRegTimestampType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTrdRegTimestampType.offset - 1 - FieldTrdRegTimestampType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTrdRegTimestampType.offset] == 1 ) return tagPtr;
   }
   if( fieldTrdRegTimestampOrigin.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTrdRegTimestampOrigin.offset - 1 - FieldTrdRegTimestampOrigin::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTrdRegTimestampOrigin.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupAltMDSource::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupSides::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldOrigClOrdID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrigClOrdID.offset - 1 - FieldOrigClOrdID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrigClOrdID.offset] == 1 ) return tagPtr;
   }
   if( fieldClOrdID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldClOrdID.offset - 1 - FieldClOrdID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldClOrdID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecondaryClOrdID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecondaryClOrdID.offset - 1 - FieldSecondaryClOrdID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecondaryClOrdID.offset] == 1 ) return tagPtr;
   }
   if( fieldClOrdLinkID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldClOrdLinkID.offset - 1 - FieldClOrdLinkID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldClOrdLinkID.offset] == 1 ) return tagPtr;
   }
   if( fieldOrigOrdModTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrigOrdModTime.offset - 1 - FieldOrigOrdModTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrigOrdModTime.offset] == 1 ) return tagPtr;
   }
   if( fieldNoPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoPartyIDs.offset - 1 - FieldNoPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldTradeOriginationDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradeOriginationDate.offset - 1 - FieldTradeOriginationDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradeOriginationDate.offset] == 1 ) return tagPtr;
   }
   if( fieldTradeDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradeDate.offset - 1 - FieldTradeDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradeDate.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderQty.offset - 1 - FieldOrderQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderQty.offset] == 1 ) return tagPtr;
   }
   if( fieldCashOrderQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCashOrderQty.offset - 1 - FieldCashOrderQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCashOrderQty.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderPercent.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderPercent.offset - 1 - FieldOrderPercent::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderPercent.offset] == 1 ) return tagPtr;
   }
   if( fieldRoundingDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRoundingDirection.offset - 1 - FieldRoundingDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRoundingDirection.offset] == 1 ) return tagPtr;
   }
   if( fieldRoundingModulus.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRoundingModulus.offset - 1 - FieldRoundingModulus::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRoundingModulus.offset] == 1 ) return tagPtr;
   }
   if( fieldComplianceID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldComplianceID.offset - 1 - FieldComplianceID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldComplianceID.offset] == 1 ) return tagPtr;
   }
   if( fieldText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldText.offset - 1 - FieldText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldText.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedTextLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedTextLen.offset - 1 - FieldEncodedTextLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedTextLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedText.offset - 1 - FieldEncodedText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedText.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupRoutingIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldRoutingID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRoutingID.offset - 1 - FieldRoutingID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRoutingID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupPosAmt::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldPosAmt.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPosAmt.offset - 1 - FieldPosAmt::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPosAmt.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupLinesOfText::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldEncodedTextLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedTextLen.offset - 1 - FieldEncodedTextLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedTextLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedText.offset - 1 - FieldEncodedText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedText.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupIOIQualifiers::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupDates::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldTransactTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTransactTime.offset - 1 - FieldTransactTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTransactTime.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupMDEntryTypes::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupRelatedSym::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSymbolSfx.offset - 1 - FieldSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityID.offset - 1 - FieldSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityIDSource.offset - 1 - FieldSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityType.offset - 1 - FieldSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecuritySubType.offset - 1 - FieldSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityMonthYear.offset - 1 - FieldMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityDate.offset - 1 - FieldMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPutOrCall.offset - 1 - FieldPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponPaymentDate.offset - 1 - FieldCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssueDate.offset - 1 - FieldIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepoCollateralSecurityType.offset - 1 - FieldRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseTerm.offset - 1 - FieldRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseRate.offset - 1 - FieldRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFactor.offset - 1 - FieldFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCreditRating.offset - 1 - FieldCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInstrRegistry.offset - 1 - FieldInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCountryOfIssue.offset - 1 - FieldCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStateOrProvinceOfIssue.offset - 1 - FieldStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocaleOfIssue.offset - 1 - FieldLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRedemptionDate.offset - 1 - FieldRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikePrice.offset - 1 - FieldStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikeCurrency.offset - 1 - FieldStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOptAttribute.offset - 1 - FieldOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractMultiplier.offset - 1 - FieldContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponRate.offset - 1 - FieldCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityExchange.offset - 1 - FieldSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssuer.offset - 1 - FieldIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuerLen.offset - 1 - FieldEncodedIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuer.offset - 1 - FieldEncodedIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityDesc.offset - 1 - FieldSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDescLen.offset - 1 - FieldEncodedSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDesc.offset - 1 - FieldEncodedSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldPool.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPool.offset - 1 - FieldPool::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPool.offset] == 1 ) return tagPtr;
   }
   if( fieldContractSettlMonth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractSettlMonth.offset - 1 - FieldContractSettlMonth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractSettlMonth.offset] == 1 ) return tagPtr;
   }
   if( fieldCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPProgram.offset - 1 - FieldCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPRegType.offset - 1 - FieldCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoEvents.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoEvents.offset] == 1 ) return tagPtr;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldDatedDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDatedDate.offset - 1 - FieldDatedDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDatedDate.offset] == 1 ) return tagPtr;
   }
   if( fieldInterestAccrualDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInterestAccrualDate.offset - 1 - FieldInterestAccrualDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInterestAccrualDate.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupContraBrokers::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldContraTrader.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContraTrader.offset - 1 - FieldContraTrader::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContraTrader.offset] == 1 ) return tagPtr;
   }
   if( fieldContraTradeQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContraTradeQty.offset - 1 - FieldContraTradeQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContraTradeQty.offset] == 1 ) return tagPtr;
   }
   if( fieldContraTradeTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContraTradeTime.offset - 1 - FieldContraTradeTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContraTradeTime.offset] == 1 ) return tagPtr;
   }
   if( fieldContraLegRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContraLegRefID.offset - 1 - FieldContraLegRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContraLegRefID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupTrades::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSecondaryTradeReportID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecondaryTradeReportID.offset - 1 - FieldSecondaryTradeReportID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecondaryTradeReportID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupStrikes::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldSymbolSfx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSymbolSfx.offset - 1 - FieldSymbolSfx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSymbolSfx.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityID.offset - 1 - FieldSecurityID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityID.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityIDSource.offset - 1 - FieldSecurityIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNoSecurityAltID.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoSecurityAltID.offset - 1 - FieldNoSecurityAltID::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoSecurityAltID.offset] == 1 ) return tagPtr;
     for( auto & g : groupsSecurityAltID ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldProduct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldProduct.offset - 1 - FieldProduct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldProduct.offset] == 1 ) return tagPtr;
   }
   if( fieldCFICode.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCFICode.offset - 1 - FieldCFICode::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCFICode.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityType.offset - 1 - FieldSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldSecuritySubType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecuritySubType.offset - 1 - FieldSecuritySubType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecuritySubType.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityMonthYear.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityMonthYear.offset - 1 - FieldMaturityMonthYear::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityMonthYear.offset] == 1 ) return tagPtr;
   }
   if( fieldMaturityDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMaturityDate.offset - 1 - FieldMaturityDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMaturityDate.offset] == 1 ) return tagPtr;
   }
   if( fieldPutOrCall.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPutOrCall.offset - 1 - FieldPutOrCall::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPutOrCall.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponPaymentDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponPaymentDate.offset - 1 - FieldCouponPaymentDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponPaymentDate.offset] == 1 ) return tagPtr;
   }
   if( fieldIssueDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssueDate.offset - 1 - FieldIssueDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssueDate.offset] == 1 ) return tagPtr;
   }
   if( fieldRepoCollateralSecurityType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepoCollateralSecurityType.offset - 1 - FieldRepoCollateralSecurityType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepoCollateralSecurityType.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseTerm.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseTerm.offset - 1 - FieldRepurchaseTerm::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseTerm.offset] == 1 ) return tagPtr;
   }
   if( fieldRepurchaseRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRepurchaseRate.offset - 1 - FieldRepurchaseRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRepurchaseRate.offset] == 1 ) return tagPtr;
   }
   if( fieldFactor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFactor.offset - 1 - FieldFactor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFactor.offset] == 1 ) return tagPtr;
   }
   if( fieldCreditRating.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCreditRating.offset - 1 - FieldCreditRating::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCreditRating.offset] == 1 ) return tagPtr;
   }
   if( fieldInstrRegistry.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInstrRegistry.offset - 1 - FieldInstrRegistry::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInstrRegistry.offset] == 1 ) return tagPtr;
   }
   if( fieldCountryOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCountryOfIssue.offset - 1 - FieldCountryOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCountryOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldStateOrProvinceOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStateOrProvinceOfIssue.offset - 1 - FieldStateOrProvinceOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStateOrProvinceOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldLocaleOfIssue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocaleOfIssue.offset - 1 - FieldLocaleOfIssue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocaleOfIssue.offset] == 1 ) return tagPtr;
   }
   if( fieldRedemptionDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRedemptionDate.offset - 1 - FieldRedemptionDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRedemptionDate.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikePrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikePrice.offset - 1 - FieldStrikePrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikePrice.offset] == 1 ) return tagPtr;
   }
   if( fieldStrikeCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldStrikeCurrency.offset - 1 - FieldStrikeCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldStrikeCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldOptAttribute.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOptAttribute.offset - 1 - FieldOptAttribute::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOptAttribute.offset] == 1 ) return tagPtr;
   }
   if( fieldContractMultiplier.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractMultiplier.offset - 1 - FieldContractMultiplier::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractMultiplier.offset] == 1 ) return tagPtr;
   }
   if( fieldCouponRate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCouponRate.offset - 1 - FieldCouponRate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCouponRate.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityExchange.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityExchange.offset - 1 - FieldSecurityExchange::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityExchange.offset] == 1 ) return tagPtr;
   }
   if( fieldIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldIssuer.offset - 1 - FieldIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuerLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuerLen.offset - 1 - FieldEncodedIssuerLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuerLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedIssuer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedIssuer.offset - 1 - FieldEncodedIssuer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedIssuer.offset] == 1 ) return tagPtr;
   }
   if( fieldSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSecurityDesc.offset - 1 - FieldSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDescLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDescLen.offset - 1 - FieldEncodedSecurityDescLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDescLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedSecurityDesc.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedSecurityDesc.offset - 1 - FieldEncodedSecurityDesc::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedSecurityDesc.offset] == 1 ) return tagPtr;
   }
   if( fieldPool.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPool.offset - 1 - FieldPool::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPool.offset] == 1 ) return tagPtr;
   }
   if( fieldContractSettlMonth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContractSettlMonth.offset - 1 - FieldContractSettlMonth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContractSettlMonth.offset] == 1 ) return tagPtr;
   }
   if( fieldCPProgram.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPProgram.offset - 1 - FieldCPProgram::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPProgram.offset] == 1 ) return tagPtr;
   }
   if( fieldCPRegType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCPRegType.offset - 1 - FieldCPRegType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCPRegType.offset] == 1 ) return tagPtr;
   }
   if( fieldNoEvents.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoEvents.offset - 1 - FieldNoEvents::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoEvents.offset] == 1 ) return tagPtr;
     for( auto & g : groupsEvents ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldDatedDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDatedDate.offset - 1 - FieldDatedDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDatedDate.offset] == 1 ) return tagPtr;
   }
   if( fieldInterestAccrualDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInterestAccrualDate.offset - 1 - FieldInterestAccrualDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInterestAccrualDate.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupBidDescriptors::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldBidDescriptor.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldBidDescriptor.offset - 1 - FieldBidDescriptor::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldBidDescriptor.offset] == 1 ) return tagPtr;
   }
   if( fieldSideValueInd.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSideValueInd.offset - 1 - FieldSideValueInd::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSideValueInd.offset] == 1 ) return tagPtr;
   }
   if( fieldLiquidityValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLiquidityValue.offset - 1 - FieldLiquidityValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLiquidityValue.offset] == 1 ) return tagPtr;
   }
   if( fieldLiquidityNumSecurities.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLiquidityNumSecurities.offset - 1 - FieldLiquidityNumSecurities::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLiquidityNumSecurities.offset] == 1 ) return tagPtr;
   }
   if( fieldLiquidityPctLow.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLiquidityPctLow.offset - 1 - FieldLiquidityPctLow::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLiquidityPctLow.offset] == 1 ) return tagPtr;
   }
   if( fieldLiquidityPctHigh.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLiquidityPctHigh.offset - 1 - FieldLiquidityPctHigh::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLiquidityPctHigh.offset] == 1 ) return tagPtr;
   }
   if( fieldEFPTrackingError.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEFPTrackingError.offset - 1 - FieldEFPTrackingError::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEFPTrackingError.offset] == 1 ) return tagPtr;
   }
   if( fieldFairValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldFairValue.offset - 1 - FieldFairValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldFairValue.offset] == 1 ) return tagPtr;
   }
   if( fieldOutsideIndexPct.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOutsideIndexPct.offset - 1 - FieldOutsideIndexPct::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOutsideIndexPct.offset] == 1 ) return tagPtr;
   }
   if( fieldValueOfFutures.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldValueOfFutures.offset - 1 - FieldValueOfFutures::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldValueOfFutures.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupCompIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldRefSubID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRefSubID.offset - 1 - FieldRefSubID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRefSubID.offset] == 1 ) return tagPtr;
   }
   if( fieldLocationID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocationID.offset - 1 - FieldLocationID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocationID.offset] == 1 ) return tagPtr;
   }
   if( fieldDeskID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDeskID.offset - 1 - FieldDeskID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDeskID.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupLegAllocs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegIndividualAllocID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegIndividualAllocID.offset - 1 - FieldLegIndividualAllocID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegIndividualAllocID.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNested2PartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNested2PartyIDs.offset - 1 - FieldNoNested2PartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNested2PartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNested2PartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegAllocQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegAllocQty.offset - 1 - FieldLegAllocQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegAllocQty.offset] == 1 ) return tagPtr;
   }
   if( fieldLegAllocAcctIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegAllocAcctIDSource.offset - 1 - FieldLegAllocAcctIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegAllocAcctIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldLegSettlCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSettlCurrency.offset - 1 - FieldLegSettlCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSettlCurrency.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupRegistDtls::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldRegistEmail.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldRegistEmail.offset - 1 - FieldRegistEmail::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldRegistEmail.offset] == 1 ) return tagPtr;
   }
   if( fieldMailingDtls.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMailingDtls.offset - 1 - FieldMailingDtls::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMailingDtls.offset] == 1 ) return tagPtr;
   }
   if( fieldMailingInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMailingInst.offset - 1 - FieldMailingInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMailingInst.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldOwnerType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOwnerType.offset - 1 - FieldOwnerType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOwnerType.offset] == 1 ) return tagPtr;
   }
   if( fieldDateOfBirth.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDateOfBirth.offset - 1 - FieldDateOfBirth::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDateOfBirth.offset] == 1 ) return tagPtr;
   }
   if( fieldInvestorCountryOfResidence.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldInvestorCountryOfResidence.offset - 1 - FieldInvestorCountryOfResidence::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldInvestorCountryOfResidence.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupContAmts::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldContAmtValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContAmtValue.offset - 1 - FieldContAmtValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContAmtValue.offset] == 1 ) return tagPtr;
   }
   if( fieldContAmtCurr.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldContAmtCurr.offset - 1 - FieldContAmtCurr::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldContAmtCurr.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupMDEntries::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldMDEntryPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryPx.offset - 1 - FieldMDEntryPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryPx.offset] == 1 ) return tagPtr;
   }
   if( fieldCurrency.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldCurrency.offset - 1 - FieldCurrency::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldCurrency.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntrySize.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntrySize.offset - 1 - FieldMDEntrySize::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntrySize.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntryDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryDate.offset - 1 - FieldMDEntryDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryDate.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntryTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryTime.offset - 1 - FieldMDEntryTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryTime.offset] == 1 ) return tagPtr;
   }
   if( fieldTickDirection.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTickDirection.offset - 1 - FieldTickDirection::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTickDirection.offset] == 1 ) return tagPtr;
   }
   if( fieldMDMkt.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDMkt.offset - 1 - FieldMDMkt::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDMkt.offset] == 1 ) return tagPtr;
   }
   if( fieldTradingSessionID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradingSessionID.offset - 1 - FieldTradingSessionID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradingSessionID.offset] == 1 ) return tagPtr;
   }
   if( fieldTradingSessionSubID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradingSessionSubID.offset - 1 - FieldTradingSessionSubID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradingSessionSubID.offset] == 1 ) return tagPtr;
   }
   if( fieldQuoteCondition.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldQuoteCondition.offset - 1 - FieldQuoteCondition::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldQuoteCondition.offset] == 1 ) return tagPtr;
   }
   if( fieldTradeCondition.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTradeCondition.offset - 1 - FieldTradeCondition::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTradeCondition.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntryOriginator.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryOriginator.offset - 1 - FieldMDEntryOriginator::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryOriginator.offset] == 1 ) return tagPtr;
   }
   if( fieldLocationID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLocationID.offset - 1 - FieldLocationID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLocationID.offset] == 1 ) return tagPtr;
   }
   if( fieldDeskID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldDeskID.offset - 1 - FieldDeskID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldDeskID.offset] == 1 ) return tagPtr;
   }
   if( fieldOpenCloseSettlFlag.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOpenCloseSettlFlag.offset - 1 - FieldOpenCloseSettlFlag::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOpenCloseSettlFlag.offset] == 1 ) return tagPtr;
   }
   if( fieldTimeInForce.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldTimeInForce.offset - 1 - FieldTimeInForce::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldTimeInForce.offset] == 1 ) return tagPtr;
   }
   if( fieldExpireDate.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExpireDate.offset - 1 - FieldExpireDate::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExpireDate.offset] == 1 ) return tagPtr;
   }
   if( fieldExpireTime.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExpireTime.offset - 1 - FieldExpireTime::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExpireTime.offset] == 1 ) return tagPtr;
   }
   if( fieldMinQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMinQty.offset - 1 - FieldMinQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMinQty.offset] == 1 ) return tagPtr;
   }
   if( fieldExecInst.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldExecInst.offset - 1 - FieldExecInst::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldExecInst.offset] == 1 ) return tagPtr;
   }
   if( fieldSellerDays.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldSellerDays.offset - 1 - FieldSellerDays::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldSellerDays.offset] == 1 ) return tagPtr;
   }
   if( fieldOrderID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldOrderID.offset - 1 - FieldOrderID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldOrderID.offset] == 1 ) return tagPtr;
   }
   if( fieldQuoteEntryID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldQuoteEntryID.offset - 1 - FieldQuoteEntryID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldQuoteEntryID.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntryBuyer.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryBuyer.offset - 1 - FieldMDEntryBuyer::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryBuyer.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntrySeller.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntrySeller.offset - 1 - FieldMDEntrySeller::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntrySeller.offset] == 1 ) return tagPtr;
   }
   if( fieldNumberOfOrders.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNumberOfOrders.offset - 1 - FieldNumberOfOrders::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNumberOfOrders.offset] == 1 ) return tagPtr;
   }
   if( fieldMDEntryPositionNo.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldMDEntryPositionNo.offset - 1 - FieldMDEntryPositionNo::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldMDEntryPositionNo.offset] == 1 ) return tagPtr;
   }
   if( fieldScope.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldScope.offset - 1 - FieldScope::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldScope.offset] == 1 ) return tagPtr;
   }
   if( fieldPriceDelta.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldPriceDelta.offset - 1 - FieldPriceDelta::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldPriceDelta.offset] == 1 ) return tagPtr;
   }
   if( fieldText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldText.offset - 1 - FieldText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldText.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedTextLen.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedTextLen.offset - 1 - FieldEncodedTextLen::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedTextLen.offset] == 1 ) return tagPtr;
   }
   if( fieldEncodedText.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldEncodedText.offset - 1 - FieldEncodedText::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldEncodedText.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}


// ---------------------------------- getKnownFields ---------------------------------
namespace {

const std::vector<unsigned> LegStipulations_knownFields = { FieldLegStipulationType::TAG
, FieldLegStipulationValue::TAG
};

const std::vector<unsigned> Events_knownFields = { FieldEventType::TAG
, FieldEventDate::TAG
, FieldEventPx::TAG
, FieldEventText::TAG
};

const std::vector<unsigned> LegSecurityAltID_knownFields = { FieldLegSecurityAltID::TAG
, FieldLegSecurityAltIDSource::TAG
};

const std::vector<unsigned> Capacities_knownFields = { FieldOrderCapacity::TAG
, FieldOrderRestrictions::TAG
, FieldOrderCapacityQty::TAG
};

const std::vector<unsigned> Nested3PartySubIDs_knownFields = { FieldNested3PartySubID::TAG
, FieldNested3PartySubIDType::TAG
};

const std::vector<unsigned> PartySubIDs_knownFields = { FieldPartySubID::TAG
, FieldPartySubIDType::TAG
};

const std::vector<unsigned> Nested2PartySubIDs_knownFields = { FieldNested2PartySubID::TAG
, FieldNested2PartySubIDType::TAG
};

const std::vector<unsigned> Nested2PartyIDs_knownFields = { FieldNested2PartyID::TAG
, FieldNested2PartyIDSource::TAG
, FieldNested2PartyRole::TAG
, FieldNoNested2PartySubIDs::TAG
};

const std::vector<unsigned> Hops_knownFields = { FieldHopCompID::TAG
, FieldHopSendingTime::TAG
, FieldHopRefID::TAG
};

const std::vector<unsigned> CollInquiryQualifier_knownFields = { FieldCollInquiryQualifier::TAG
};

const std::vector<unsigned> PartyIDs_knownFields = { FieldPartyID::TAG
, FieldPartyIDSource::TAG
, FieldPartyRole::TAG
, FieldNoPartySubIDs::TAG
};

const std::vector<unsigned> Allocs_knownFields = { FieldAllocAccount::TAG
, FieldAllocAcctIDSource::TAG
, FieldAllocPrice::TAG
, FieldIndividualAllocID::TAG
, FieldIndividualAllocRejCode::TAG
, FieldAllocText::TAG
, FieldEncodedAllocTextLen::TAG
, FieldEncodedAllocText::TAG
};

const std::vector<unsigned> TradingSessions_knownFields = { FieldTradingSessionID::TAG
, FieldTradingSessionSubID::TAG
};

const std::vector<unsigned> SecurityAltID_knownFields = { FieldSecurityAltID::TAG
, FieldSecurityAltIDSource::TAG
};

const std::vector<unsigned> UnderlyingSecurityAltID_knownFields = { FieldUnderlyingSecurityAltID::TAG
, FieldUnderlyingSecurityAltIDSource::TAG
};

const std::vector<unsigned> UnderlyingStips_knownFields = { FieldUnderlyingStipType::TAG
, FieldUnderlyingStipValue::TAG
};

const std::vector<unsigned> Underlyings_knownFields = { FieldUnderlyingSymbol::TAG
, FieldUnderlyingSymbolSfx::TAG
, FieldUnderlyingSecurityID::TAG
, FieldUnderlyingSecurityIDSource::TAG
, FieldNoUnderlyingSecurityAltID::TAG
, FieldUnderlyingProduct::TAG
, FieldUnderlyingCFICode::TAG
, FieldUnderlyingSecurityType::TAG
, FieldUnderlyingSecuritySubType::TAG
, FieldUnderlyingMaturityMonthYear::TAG
, FieldUnderlyingMaturityDate::TAG
, FieldUnderlyingPutOrCall::TAG
, FieldUnderlyingCouponPaymentDate::TAG
, FieldUnderlyingIssueDate::TAG
, FieldUnderlyingRepoCollateralSecurityType::TAG
, FieldUnderlyingRepurchaseTerm::TAG
, FieldUnderlyingRepurchaseRate::TAG
, FieldUnderlyingFactor::TAG
, FieldUnderlyingCreditRating::TAG
, FieldUnderlyingInstrRegistry::TAG
, FieldUnderlyingCountryOfIssue::TAG
, FieldUnderlyingStateOrProvinceOfIssue::TAG
, FieldUnderlyingLocaleOfIssue::TAG
, FieldUnderlyingRedemptionDate::TAG
, FieldUnderlyingStrikePrice::TAG
, FieldUnderlyingStrikeCurrency::TAG
, FieldUnderlyingOptAttribute::TAG
, FieldUnderlyingContractMultiplier::TAG
, FieldUnderlyingCouponRate::TAG
, FieldUnderlyingSecurityExchange::TAG
, FieldUnderlyingIssuer::TAG
, FieldEncodedUnderlyingIssuerLen::TAG
, FieldEncodedUnderlyingIssuer::TAG
, FieldUnderlyingSecurityDesc::TAG
, FieldEncodedUnderlyingSecurityDescLen::TAG
, FieldEncodedUnderlyingSecurityDesc::TAG
, FieldUnderlyingCPProgram::TAG
, FieldUnderlyingCPRegType::TAG
, FieldUnderlyingCurrency::TAG
, FieldUnderlyingQty::TAG
, FieldUnderlyingPx::TAG
, FieldUnderlyingDirtyPrice::TAG
, FieldUnderlyingEndPrice::TAG
, FieldUnderlyingStartValue::TAG
, FieldUnderlyingCurrentValue::TAG
, FieldUnderlyingEndValue::TAG
, FieldNoUnderlyingStips::TAG
, FieldUnderlyingSettlPrice::TAG
, FieldUnderlyingSettlPriceType::TAG
};

const std::vector<unsigned> Stipulations_knownFields = { FieldStipulationType::TAG
, FieldStipulationValue::TAG
};

const std::vector<unsigned> Orders_knownFields = { FieldClOrdID::TAG
, FieldSecondaryClOrdID::TAG
, FieldListSeqNo::TAG
, FieldClOrdLinkID::TAG
, FieldSettlInstMode::TAG
, FieldNoPartyIDs::TAG
, FieldTradeOriginationDate::TAG
, FieldTradeDate::TAG
, FieldAccount::TAG
, FieldAcctIDSource::TAG
, FieldAccountType::TAG
, FieldDayBookingInst::TAG
, FieldBookingUnit::TAG
, FieldAllocID::TAG
, FieldPreallocMethod::TAG
, FieldNoAllocs::TAG
, FieldSettlType::TAG
, FieldSettlDate::TAG
, FieldCashMargin::TAG
, FieldClearingFeeIndicator::TAG
, FieldHandlInst::TAG
, FieldExecInst::TAG
, FieldMinQty::TAG
, FieldMaxFloor::TAG
, FieldExDestination::TAG
, FieldNoTradingSessions::TAG
, FieldProcessCode::TAG
, FieldSymbol::TAG
, FieldSymbolSfx::TAG
, FieldSecurityID::TAG
, FieldSecurityIDSource::TAG
, FieldNoSecurityAltID::TAG
, FieldProduct::TAG
, FieldCFICode::TAG
, FieldSecurityType::TAG
, FieldSecuritySubType::TAG
, FieldMaturityMonthYear::TAG
, FieldMaturityDate::TAG
, FieldPutOrCall::TAG
, FieldCouponPaymentDate::TAG
, FieldIssueDate::TAG
, FieldRepoCollateralSecurityType::TAG
, FieldRepurchaseTerm::TAG
, FieldRepurchaseRate::TAG
, FieldFactor::TAG
, FieldCreditRating::TAG
, FieldInstrRegistry::TAG
, FieldCountryOfIssue::TAG
, FieldStateOrProvinceOfIssue::TAG
, FieldLocaleOfIssue::TAG
, FieldRedemptionDate::TAG
, FieldStrikePrice::TAG
, FieldStrikeCurrency::TAG
, FieldOptAttribute::TAG
, FieldContractMultiplier::TAG
, FieldCouponRate::TAG
, FieldSecurityExchange::TAG
, FieldIssuer::TAG
, FieldEncodedIssuerLen::TAG
, FieldEncodedIssuer::TAG
, FieldSecurityDesc::TAG
, FieldEncodedSecurityDescLen::TAG
, FieldEncodedSecurityDesc::TAG
, FieldPool::TAG
, FieldContractSettlMonth::TAG
, FieldCPProgram::TAG
, FieldCPRegType::TAG
, FieldNoEvents::TAG
, FieldDatedDate::TAG
, FieldInterestAccrualDate::TAG
, FieldNoUnderlyings::TAG
, FieldPrevClosePx::TAG
, FieldSide::TAG
, FieldSideValueInd::TAG
, FieldLocateReqd::TAG
, FieldTransactTime::TAG
, FieldNoStipulations::TAG
, FieldQtyType::TAG
, FieldOrderQty::TAG
, FieldCashOrderQty::TAG
, FieldOrderPercent::TAG
, FieldRoundingDirection::TAG
, FieldRoundingModulus::TAG
, FieldOrdType::TAG
, FieldPriceType::TAG
, FieldPrice::TAG
, FieldStopPx::TAG
, FieldSpread::TAG
, FieldBenchmarkCurveCurrency::TAG
, FieldBenchmarkCurveName::TAG
, FieldBenchmarkCurvePoint::TAG
, FieldBenchmarkPrice::TAG
, FieldBenchmarkPriceType::TAG
, FieldBenchmarkSecurityID::TAG
, FieldBenchmarkSecurityIDSource::TAG
, FieldYieldType::TAG
, FieldYield::TAG
, FieldYieldCalcDate::TAG
, FieldYieldRedemptionDate::TAG
, FieldYieldRedemptionPrice::TAG
, FieldYieldRedemptionPriceType::TAG
, FieldCurrency::TAG
, FieldComplianceID::TAG
, FieldSolicitedFlag::TAG
, FieldIOIID::TAG
, FieldQuoteID::TAG
, FieldTimeInForce::TAG
, FieldEffectiveTime::TAG
, FieldExpireDate::TAG
, FieldExpireTime::TAG
, FieldGTBookingInst::TAG
, FieldCommission::TAG
, FieldCommType::TAG
, FieldCommCurrency::TAG
, FieldFundRenewWaiv::TAG
, FieldOrderCapacity::TAG
, FieldOrderRestrictions::TAG
, FieldCustOrderCapacity::TAG
, FieldForexReq::TAG
, FieldSettlCurrency::TAG
, FieldBookingType::TAG
, FieldText::TAG
, FieldEncodedTextLen::TAG
, FieldEncodedText::TAG
, FieldSettlDate2::TAG
, FieldOrderQty2::TAG
, FieldPrice2::TAG
, FieldPositionEffect::TAG
, FieldCoveredOrUncovered::TAG
, FieldMaxShow::TAG
, FieldPegOffsetValue::TAG
, FieldPegMoveType::TAG
, FieldPegOffsetType::TAG
, FieldPegLimitType::TAG
, FieldPegRoundDirection::TAG
, FieldPegScope::TAG
, FieldDiscretionInst::TAG
, FieldDiscretionOffsetValue::TAG
, FieldDiscretionMoveType::TAG
, FieldDiscretionOffsetType::TAG
, FieldDiscretionLimitType::TAG
, FieldDiscretionRoundDirection::TAG
, FieldDiscretionScope::TAG
, FieldTargetStrategy::TAG
, FieldTargetStrategyParameters::TAG
, FieldParticipationRate::TAG
, FieldDesignation::TAG
};

const std::vector<unsigned> SettlPartySubIDs_knownFields = { FieldSettlPartySubID::TAG
, FieldSettlPartySubIDType::TAG
};

const std::vector<unsigned> SettlPartyIDs_knownFields = { FieldSettlPartyID::TAG
, FieldSettlPartyIDSource::TAG
, FieldSettlPartyRole::TAG
, FieldNoSettlPartySubIDs::TAG
};

const std::vector<unsigned> DlvyInst_knownFields = { FieldSettlInstSource::TAG
, FieldDlvyInstType::TAG
, FieldNoSettlPartyIDs::TAG
};

const std::vector<unsigned> ClearingInstructions_knownFields = { FieldClearingInstruction::TAG
};

const std::vector<unsigned> NestedPartySubIDs_knownFields = { FieldNestedPartySubID::TAG
, FieldNestedPartySubIDType::TAG
};

const std::vector<unsigned> NestedPartyIDs_knownFields = { FieldNestedPartyID::TAG
, FieldNestedPartyIDSource::TAG
, FieldNestedPartyRole::TAG
, FieldNoNestedPartySubIDs::TAG
};

const std::vector<unsigned> Legs_knownFields = { FieldLegSymbol::TAG
, FieldLegSymbolSfx::TAG
, FieldLegSecurityID::TAG
, FieldLegSecurityIDSource::TAG
, FieldNoLegSecurityAltID::TAG
, FieldLegProduct::TAG
, FieldLegCFICode::TAG
, FieldLegSecurityType::TAG
, FieldLegSecuritySubType::TAG
, FieldLegMaturityMonthYear::TAG
, FieldLegMaturityDate::TAG
, FieldLegCouponPaymentDate::TAG
, FieldLegIssueDate::TAG
, FieldLegRepoCollateralSecurityType::TAG
, FieldLegRepurchaseTerm::TAG
, FieldLegRepurchaseRate::TAG
, FieldLegFactor::TAG
, FieldLegCreditRating::TAG
, FieldLegInstrRegistry::TAG
, FieldLegCountryOfIssue::TAG
, FieldLegStateOrProvinceOfIssue::TAG
, FieldLegLocaleOfIssue::TAG
, FieldLegRedemptionDate::TAG
, FieldLegStrikePrice::TAG
, FieldLegStrikeCurrency::TAG
, FieldLegOptAttribute::TAG
, FieldLegContractMultiplier::TAG
, FieldLegCouponRate::TAG
, FieldLegSecurityExchange::TAG
, FieldLegIssuer::TAG
, FieldEncodedLegIssuerLen::TAG
, FieldEncodedLegIssuer::TAG
, FieldLegSecurityDesc::TAG
, FieldEncodedLegSecurityDescLen::TAG
, FieldEncodedLegSecurityDesc::TAG
, FieldLegRatioQty::TAG
, FieldLegSide::TAG
, FieldLegCurrency::TAG
, FieldLegPool::TAG
, FieldLegDatedDate::TAG
, FieldLegContractSettlMonth::TAG
, FieldLegInterestAccrualDate::TAG
, FieldLegQty::TAG
, FieldLegSwapType::TAG
, FieldNoLegStipulations::TAG
, FieldLegPositionEffect::TAG
, FieldLegCoveredOrUncovered::TAG
, FieldNoNestedPartyIDs::TAG
, FieldLegRefID::TAG
, FieldLegPrice::TAG
, FieldLegSettlType::TAG
, FieldLegSettlDate::TAG
, FieldLegLastPx::TAG
};

const std::vector<unsigned> QuoteEntries_knownFields = { FieldSymbol::TAG
, FieldSymbolSfx::TAG
, FieldSecurityID::TAG
, FieldSecurityIDSource::TAG
, FieldNoSecurityAltID::TAG
, FieldProduct::TAG
, FieldCFICode::TAG
, FieldSecurityType::TAG
, FieldSecuritySubType::TAG
, FieldMaturityMonthYear::TAG
, FieldMaturityDate::TAG
, FieldPutOrCall::TAG
, FieldCouponPaymentDate::TAG
, FieldIssueDate::TAG
, FieldRepoCollateralSecurityType::TAG
, FieldRepurchaseTerm::TAG
, FieldRepurchaseRate::TAG
, FieldFactor::TAG
, FieldCreditRating::TAG
, FieldInstrRegistry::TAG
, FieldCountryOfIssue::TAG
, FieldStateOrProvinceOfIssue::TAG
, FieldLocaleOfIssue::TAG
, FieldRedemptionDate::TAG
, FieldStrikePrice::TAG
, FieldStrikeCurrency::TAG
, FieldOptAttribute::TAG
, FieldContractMultiplier::TAG
, FieldCouponRate::TAG
, FieldSecurityExchange::TAG
, FieldIssuer::TAG
, FieldEncodedIssuerLen::TAG
, FieldEncodedIssuer::TAG
, FieldSecurityDesc::TAG
, FieldEncodedSecurityDescLen::TAG
, FieldEncodedSecurityDesc::TAG
, FieldPool::TAG
, FieldContractSettlMonth::TAG
, FieldCPProgram::TAG
, FieldCPRegType::TAG
, FieldNoEvents::TAG
, FieldDatedDate::TAG
, FieldInterestAccrualDate::TAG
, FieldAgreementDesc::TAG
, FieldAgreementID::TAG
, FieldAgreementDate::TAG
, FieldAgreementCurrency::TAG
, FieldTerminationType::TAG
, FieldStartDate::TAG
, FieldEndDate::TAG
, FieldDeliveryType::TAG
, FieldMarginRatio::TAG
, FieldNoUnderlyings::TAG
, FieldNoLegs::TAG
};

const std::vector<unsigned> QuoteSets_knownFields = { FieldQuoteSetID::TAG
, FieldUnderlyingSymbol::TAG
, FieldUnderlyingSymbolSfx::TAG
, FieldUnderlyingSecurityID::TAG
, FieldUnderlyingSecurityIDSource::TAG
, FieldNoUnderlyingSecurityAltID::TAG
, FieldUnderlyingProduct::TAG
, FieldUnderlyingCFICode::TAG
, FieldUnderlyingSecurityType::TAG
, FieldUnderlyingSecuritySubType::TAG
, FieldUnderlyingMaturityMonthYear::TAG
, FieldUnderlyingMaturityDate::TAG
, FieldUnderlyingPutOrCall::TAG
, FieldUnderlyingCouponPaymentDate::TAG
, FieldUnderlyingIssueDate::TAG
, FieldUnderlyingRepoCollateralSecurityType::TAG
, FieldUnderlyingRepurchaseTerm::TAG
, FieldUnderlyingRepurchaseRate::TAG
, FieldUnderlyingFactor::TAG
, FieldUnderlyingCreditRating::TAG
, FieldUnderlyingInstrRegistry::TAG
, FieldUnderlyingCountryOfIssue::TAG
, FieldUnderlyingStateOrProvinceOfIssue::TAG
, FieldUnderlyingLocaleOfIssue::TAG
, FieldUnderlyingRedemptionDate::TAG
, FieldUnderlyingStrikePrice::TAG
, FieldUnderlyingStrikeCurrency::TAG
, FieldUnderlyingOptAttribute::TAG
, FieldUnderlyingContractMultiplier::TAG
, FieldUnderlyingCouponRate::TAG
, FieldUnderlyingSecurityExchange::TAG
, FieldUnderlyingIssuer::TAG
, FieldEncodedUnderlyingIssuerLen::TAG
, FieldEncodedUnderlyingIssuer::TAG
, FieldUnderlyingSecurityDesc::TAG
, FieldEncodedUnderlyingSecurityDescLen::TAG
, FieldEncodedUnderlyingSecurityDesc::TAG
, FieldUnderlyingCPProgram::TAG
, FieldUnderlyingCPRegType::TAG
, FieldUnderlyingCurrency::TAG
, FieldUnderlyingQty::TAG
, FieldUnderlyingPx::TAG
, FieldUnderlyingDirtyPrice::TAG
, FieldUnderlyingEndPrice::TAG
, FieldUnderlyingStartValue::TAG
, FieldUnderlyingCurrentValue::TAG
, FieldUnderlyingEndValue::TAG
, FieldNoUnderlyingStips::TAG
, FieldTotNoQuoteEntries::TAG
, FieldLastFragment::TAG
, FieldNoQuoteEntries::TAG
};

const std::vector<unsigned> SecurityTypes_knownFields = { FieldSecurityType::TAG
, FieldSecuritySubType::TAG
, FieldProduct::TAG
, FieldCFICode::TAG
};

const std::vector<unsigned> Nested3PartyIDs_knownFields = { FieldNested3PartyID::TAG
, FieldNested3PartyIDSource::TAG
, FieldNested3PartyRole::TAG
, FieldNoNested3PartySubIDs::TAG
};

const std::vector<unsigned> Positions_knownFields = { FieldPosType::TAG
, FieldLongQty::TAG
, FieldShortQty::TAG
, FieldPosQtyStatus::TAG
, FieldNoNestedPartyIDs::TAG
};

const std::vector<unsigned> AffectedOrders_knownFields = { FieldOrigClOrdID::TAG
, FieldAffectedOrderID::TAG
, FieldAffectedSecondaryOrderID::TAG
};

const std::vector<unsigned> Execs_knownFields = { FieldLastQty::TAG
, FieldExecID::TAG
, FieldSecondaryExecID::TAG
, FieldLastPx::TAG
, FieldLastParPx::TAG
, FieldLastCapacity::TAG
};

const std::vector<unsigned> MsgTypes_knownFields = { FieldRefMsgType::TAG
, FieldMsgDirection::TAG
};

const std::vector<unsigned> BidComponents_knownFields = { FieldListID::TAG
, FieldSide::TAG
, FieldTradingSessionID::TAG
, FieldTradingSessionSubID::TAG
, FieldNetGrossInd::TAG
, FieldSettlType::TAG
, FieldSettlDate::TAG
, FieldAccount::TAG
, FieldAcctIDSource::TAG
};

const std::vector<unsigned> SettlInst_knownFields = { FieldSettlInstID::TAG
, FieldSettlInstTransType::TAG
, FieldSettlInstRefID::TAG
, FieldNoPartyIDs::TAG
, FieldSide::TAG
, FieldProduct::TAG
, FieldSecurityType::TAG
, FieldCFICode::TAG
, FieldEffectiveTime::TAG
, FieldExpireTime::TAG
, FieldLastUpdateTime::TAG
, FieldSettlDeliveryType::TAG
, FieldStandInstDbType::TAG
, FieldStandInstDbName::TAG
, FieldStandInstDbID::TAG
, FieldNoDlvyInst::TAG
, FieldPaymentMethod::TAG
, FieldPaymentRef::TAG
, FieldCardHolderName::TAG
, FieldCardNumber::TAG
, FieldCardStartDate::TAG
, FieldCardExpDate::TAG
, FieldCardIssNum::TAG
, FieldPaymentDate::TAG
, FieldPaymentRemitterID::TAG
};

const std::vector<unsigned> InstrAttrib_knownFields = { FieldInstrAttribType::TAG
, FieldInstrAttribValue::TAG
};

const std::vector<unsigned> MiscFees_knownFields = { FieldMiscFeeAmt::TAG
, FieldMiscFeeCurr::TAG
, FieldMiscFeeType::TAG
, FieldMiscFeeBasis::TAG
};

const std::vector<unsigned> QuoteQualifiers_knownFields = { FieldQuoteQualifier::TAG
};

const std::vector<unsigned> DistribInsts_knownFields = { FieldDistribPaymentMethod::TAG
, FieldDistribPercentage::TAG
, FieldCashDistribCurr::TAG
, FieldCashDistribAgentName::TAG
, FieldCashDistribAgentCode::TAG
, FieldCashDistribAgentAcctNumber::TAG
, FieldCashDistribPayRef::TAG
, FieldCashDistribAgentAcctName::TAG
};

const std::vector<unsigned> TrdRegTimestamps_knownFields = { FieldTrdRegTimestamp::TAG
, FieldTrdRegTimestampType::TAG
, FieldTrdRegTimestampOrigin::TAG
};

const std::vector<unsigned> AltMDSource_knownFields = { FieldAltMDSourceID::TAG
};

const std::vector<unsigned> Sides_knownFields = { FieldSide::TAG
, FieldOrigClOrdID::TAG
, FieldClOrdID::TAG
, FieldSecondaryClOrdID::TAG
, FieldClOrdLinkID::TAG
, FieldOrigOrdModTime::TAG
, FieldNoPartyIDs::TAG
, FieldTradeOriginationDate::TAG
, FieldTradeDate::TAG
, FieldOrderQty::TAG
, FieldCashOrderQty::TAG
, FieldOrderPercent::TAG
, FieldRoundingDirection::TAG
, FieldRoundingModulus::TAG
, FieldComplianceID::TAG
, FieldText::TAG
, FieldEncodedTextLen::TAG
, FieldEncodedText::TAG
};

const std::vector<unsigned> RoutingIDs_knownFields = { FieldRoutingType::TAG
, FieldRoutingID::TAG
};

const std::vector<unsigned> PosAmt_knownFields = { FieldPosAmtType::TAG
, FieldPosAmt::TAG
};

const std::vector<unsigned> LinesOfText_knownFields = { FieldText::TAG
, FieldEncodedTextLen::TAG
, FieldEncodedText::TAG
};

const std::vector<unsigned> IOIQualifiers_knownFields = { FieldIOIQualifier::TAG
};

const std::vector<unsigned> Dates_knownFields = { FieldTradeDate::TAG
, FieldTransactTime::TAG
};

const std::vector<unsigned> MDEntryTypes_knownFields = { FieldMDEntryType::TAG
};

const std::vector<unsigned> RelatedSym_knownFields = { FieldSymbol::TAG
, FieldSymbolSfx::TAG
, FieldSecurityID::TAG
, FieldSecurityIDSource::TAG
, FieldNoSecurityAltID::TAG
, FieldProduct::TAG
, FieldCFICode::TAG
, FieldSecurityType::TAG
, FieldSecuritySubType::TAG
, FieldMaturityMonthYear::TAG
, FieldMaturityDate::TAG
, FieldPutOrCall::TAG
, FieldCouponPaymentDate::TAG
, FieldIssueDate::TAG
, FieldRepoCollateralSecurityType::TAG
, FieldRepurchaseTerm::TAG
, FieldRepurchaseRate::TAG
, FieldFactor::TAG
, FieldCreditRating::TAG
, FieldInstrRegistry::TAG
, FieldCountryOfIssue::TAG
, FieldStateOrProvinceOfIssue::TAG
, FieldLocaleOfIssue::TAG
, FieldRedemptionDate::TAG
, FieldStrikePrice::TAG
, FieldStrikeCurrency::TAG
, FieldOptAttribute::TAG
, FieldContractMultiplier::TAG
, FieldCouponRate::TAG
, FieldSecurityExchange::TAG
, FieldIssuer::TAG
, FieldEncodedIssuerLen::TAG
, FieldEncodedIssuer::TAG
, FieldSecurityDesc::TAG
, FieldEncodedSecurityDescLen::TAG
, FieldEncodedSecurityDesc::TAG
, FieldPool::TAG
, FieldContractSettlMonth::TAG
, FieldCPProgram::TAG
, FieldCPRegType::TAG
, FieldNoEvents::TAG
, FieldDatedDate::TAG
, FieldInterestAccrualDate::TAG
};

const std::vector<unsigned> ContraBrokers_knownFields = { FieldContraBroker::TAG
, FieldContraTrader::TAG
, FieldContraTradeQty::TAG
, FieldContraTradeTime::TAG
, FieldContraLegRefID::TAG
};

const std::vector<unsigned> Trades_knownFields = { FieldTradeReportID::TAG
, FieldSecondaryTradeReportID::TAG
};

const std::vector<unsigned> Strikes_knownFields = { FieldSymbol::TAG
, FieldSymbolSfx::TAG
, FieldSecurityID::TAG
, FieldSecurityIDSource::TAG
, FieldNoSecurityAltID::TAG
, FieldProduct::TAG
, FieldCFICode::TAG
, FieldSecurityType::TAG
, FieldSecuritySubType::TAG
, FieldMaturityMonthYear::TAG
, FieldMaturityDate::TAG
, FieldPutOrCall::TAG
, FieldCouponPaymentDate::TAG
, FieldIssueDate::TAG
, FieldRepoCollateralSecurityType::TAG
, FieldRepurchaseTerm::TAG
, FieldRepurchaseRate::TAG
, FieldFactor::TAG
, FieldCreditRating::TAG
, FieldInstrRegistry::TAG
, FieldCountryOfIssue::TAG
, FieldStateOrProvinceOfIssue::TAG
, FieldLocaleOfIssue::TAG
, FieldRedemptionDate::TAG
, FieldStrikePrice::TAG
, FieldStrikeCurrency::TAG
, FieldOptAttribute::TAG
, FieldContractMultiplier::TAG
, FieldCouponRate::TAG
, FieldSecurityExchange::TAG
, FieldIssuer::TAG
, FieldEncodedIssuerLen::TAG
, FieldEncodedIssuer::TAG
, FieldSecurityDesc::TAG
, FieldEncodedSecurityDescLen::TAG
, FieldEncodedSecurityDesc::TAG
, FieldPool::TAG
, FieldContractSettlMonth::TAG
, FieldCPProgram::TAG
, FieldCPRegType::TAG
, FieldNoEvents::TAG
, FieldDatedDate::TAG
, FieldInterestAccrualDate::TAG
};

const std::vector<unsigned> BidDescriptors_knownFields = { FieldBidDescriptorType::TAG
, FieldBidDescriptor::TAG
, FieldSideValueInd::TAG
, FieldLiquidityValue::TAG
, FieldLiquidityNumSecurities::TAG
, FieldLiquidityPctLow::TAG
, FieldLiquidityPctHigh::TAG
, FieldEFPTrackingError::TAG
, FieldFairValue::TAG
, FieldOutsideIndexPct::TAG
, FieldValueOfFutures::TAG
};

const std::vector<unsigned> CompIDs_knownFields = { FieldRefCompID::TAG
, FieldRefSubID::TAG
, FieldLocationID::TAG
, FieldDeskID::TAG
};

const std::vector<unsigned> LegAllocs_knownFields = { FieldLegAllocAccount::TAG
, FieldLegIndividualAllocID::TAG
, FieldNoNested2PartyIDs::TAG
, FieldLegAllocQty::TAG
, FieldLegAllocAcctIDSource::TAG
, FieldLegSettlCurrency::TAG
};

const std::vector<unsigned> RegistDtls_knownFields = { FieldRegistDtls::TAG
, FieldRegistEmail::TAG
, FieldMailingDtls::TAG
, FieldMailingInst::TAG
, FieldNoNestedPartyIDs::TAG
, FieldOwnerType::TAG
, FieldDateOfBirth::TAG
, FieldInvestorCountryOfResidence::TAG
};

const std::vector<unsigned> ContAmts_knownFields = { FieldContAmtType::TAG
, FieldContAmtValue::TAG
, FieldContAmtCurr::TAG
};

const std::vector<unsigned> MDEntries_knownFields = { FieldMDEntryType::TAG
, FieldMDEntryPx::TAG
, FieldCurrency::TAG
, FieldMDEntrySize::TAG
, FieldMDEntryDate::TAG
, FieldMDEntryTime::TAG
, FieldTickDirection::TAG
, FieldMDMkt::TAG
, FieldTradingSessionID::TAG
, FieldTradingSessionSubID::TAG
, FieldQuoteCondition::TAG
, FieldTradeCondition::TAG
, FieldMDEntryOriginator::TAG
, FieldLocationID::TAG
, FieldDeskID::TAG
, FieldOpenCloseSettlFlag::TAG
, FieldTimeInForce::TAG
, FieldExpireDate::TAG
, FieldExpireTime::TAG
, FieldMinQty::TAG
, FieldExecInst::TAG
, FieldSellerDays::TAG
, FieldOrderID::TAG
, FieldQuoteEntryID::TAG
, FieldMDEntryBuyer::TAG
, FieldMDEntrySeller::TAG
, FieldNumberOfOrders::TAG
, FieldMDEntryPositionNo::TAG
, FieldScope::TAG
, FieldPriceDelta::TAG
, FieldText::TAG
, FieldEncodedTextLen::TAG
, FieldEncodedText::TAG
};

}


const std::vector<unsigned> & GroupLegStipulations::getKnownFields(){ return LegStipulations_knownFields; }

const std::vector<unsigned> & GroupEvents::getKnownFields(){ return Events_knownFields; }

const std::vector<unsigned> & GroupLegSecurityAltID::getKnownFields(){ return LegSecurityAltID_knownFields; }

const std::vector<unsigned> & GroupCapacities::getKnownFields(){ return Capacities_knownFields; }

const std::vector<unsigned> & GroupNested3PartySubIDs::getKnownFields(){ return Nested3PartySubIDs_knownFields; }

const std::vector<unsigned> & GroupPartySubIDs::getKnownFields(){ return PartySubIDs_knownFields; }

const std::vector<unsigned> & GroupNested2PartySubIDs::getKnownFields(){ return Nested2PartySubIDs_knownFields; }

const std::vector<unsigned> & GroupNested2PartyIDs::getKnownFields(){ return Nested2PartyIDs_knownFields; }

const std::vector<unsigned> & GroupHops::getKnownFields(){ return Hops_knownFields; }

const std::vector<unsigned> & GroupCollInquiryQualifier::getKnownFields(){ return CollInquiryQualifier_knownFields; }

const std::vector<unsigned> & GroupPartyIDs::getKnownFields(){ return PartyIDs_knownFields; }

const std::vector<unsigned> & GroupAllocs::getKnownFields(){ return Allocs_knownFields; }

const std::vector<unsigned> & GroupTradingSessions::getKnownFields(){ return TradingSessions_knownFields; }

const std::vector<unsigned> & GroupSecurityAltID::getKnownFields(){ return SecurityAltID_knownFields; }

const std::vector<unsigned> & GroupUnderlyingSecurityAltID::getKnownFields(){ return UnderlyingSecurityAltID_knownFields; }

const std::vector<unsigned> & GroupUnderlyingStips::getKnownFields(){ return UnderlyingStips_knownFields; }

const std::vector<unsigned> & GroupUnderlyings::getKnownFields(){ return Underlyings_knownFields; }

const std::vector<unsigned> & GroupStipulations::getKnownFields(){ return Stipulations_knownFields; }

const std::vector<unsigned> & GroupOrders::getKnownFields(){ return Orders_knownFields; }

const std::vector<unsigned> & GroupSettlPartySubIDs::getKnownFields(){ return SettlPartySubIDs_knownFields; }

const std::vector<unsigned> & GroupSettlPartyIDs::getKnownFields(){ return SettlPartyIDs_knownFields; }

const std::vector<unsigned> & GroupDlvyInst::getKnownFields(){ return DlvyInst_knownFields; }

const std::vector<unsigned> & GroupClearingInstructions::getKnownFields(){ return ClearingInstructions_knownFields; }

const std::vector<unsigned> & GroupNestedPartySubIDs::getKnownFields(){ return NestedPartySubIDs_knownFields; }

const std::vector<unsigned> & GroupNestedPartyIDs::getKnownFields(){ return NestedPartyIDs_knownFields; }

const std::vector<unsigned> & GroupLegs::getKnownFields(){ return Legs_knownFields; }

const std::vector<unsigned> & GroupQuoteEntries::getKnownFields(){ return QuoteEntries_knownFields; }

const std::vector<unsigned> & GroupQuoteSets::getKnownFields(){ return QuoteSets_knownFields; }

const std::vector<unsigned> & GroupSecurityTypes::getKnownFields(){ return SecurityTypes_knownFields; }

const std::vector<unsigned> & GroupNested3PartyIDs::getKnownFields(){ return Nested3PartyIDs_knownFields; }

const std::vector<unsigned> & GroupPositions::getKnownFields(){ return Positions_knownFields; }

const std::vector<unsigned> & GroupAffectedOrders::getKnownFields(){ return AffectedOrders_knownFields; }

const std::vector<unsigned> & GroupExecs::getKnownFields(){ return Execs_knownFields; }

const std::vector<unsigned> & GroupMsgTypes::getKnownFields(){ return MsgTypes_knownFields; }

const std::vector<unsigned> & GroupBidComponents::getKnownFields(){ return BidComponents_knownFields; }

const std::vector<unsigned> & GroupSettlInst::getKnownFields(){ return SettlInst_knownFields; }

const std::vector<unsigned> & GroupInstrAttrib::getKnownFields(){ return InstrAttrib_knownFields; }

const std::vector<unsigned> & GroupMiscFees::getKnownFields(){ return MiscFees_knownFields; }

const std::vector<unsigned> & GroupQuoteQualifiers::getKnownFields(){ return QuoteQualifiers_knownFields; }

const std::vector<unsigned> & GroupDistribInsts::getKnownFields(){ return DistribInsts_knownFields; }

const std::vector<unsigned> & GroupTrdRegTimestamps::getKnownFields(){ return TrdRegTimestamps_knownFields; }

const std::vector<unsigned> & GroupAltMDSource::getKnownFields(){ return AltMDSource_knownFields; }

const std::vector<unsigned> & GroupSides::getKnownFields(){ return Sides_knownFields; }

const std::vector<unsigned> & GroupRoutingIDs::getKnownFields(){ return RoutingIDs_knownFields; }

const std::vector<unsigned> & GroupPosAmt::getKnownFields(){ return PosAmt_knownFields; }

const std::vector<unsigned> & GroupLinesOfText::getKnownFields(){ return LinesOfText_knownFields; }

const std::vector<unsigned> & GroupIOIQualifiers::getKnownFields(){ return IOIQualifiers_knownFields; }

const std::vector<unsigned> & GroupDates::getKnownFields(){ return Dates_knownFields; }

const std::vector<unsigned> & GroupMDEntryTypes::getKnownFields(){ return MDEntryTypes_knownFields; }

const std::vector<unsigned> & GroupRelatedSym::getKnownFields(){ return RelatedSym_knownFields; }

const std::vector<unsigned> & GroupContraBrokers::getKnownFields(){ return ContraBrokers_knownFields; }

const std::vector<unsigned> & GroupTrades::getKnownFields(){ return Trades_knownFields; }

const std::vector<unsigned> & GroupStrikes::getKnownFields(){ return Strikes_knownFields; }

const std::vector<unsigned> & GroupBidDescriptors::getKnownFields(){ return BidDescriptors_knownFields; }

const std::vector<unsigned> & GroupCompIDs::getKnownFields(){ return CompIDs_knownFields; }

const std::vector<unsigned> & GroupLegAllocs::getKnownFields(){ return LegAllocs_knownFields; }

const std::vector<unsigned> & GroupRegistDtls::getKnownFields(){ return RegistDtls_knownFields; }

const std::vector<unsigned> & GroupContAmts::getKnownFields(){ return ContAmts_knownFields; }

const std::vector<unsigned> & GroupMDEntries::getKnownFields(){ return MDEntries_knownFields; }


// -------------------------------------- reset ----------------------------------------

void GroupLegStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegStipulationValue.offset = -1;
}

void GroupEvents::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldEventDate.offset = -1;
     fieldEventPx.offset = -1;
     fieldEventText.offset = -1;
}

void GroupLegSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSecurityAltIDSource.offset = -1;
}

void GroupCapacities::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldOrderRestrictions.offset = -1;
     fieldOrderCapacityQty.offset = -1;
}

void GroupNested3PartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested3PartySubIDType.offset = -1;
}

void GroupPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPartySubIDType.offset = -1;
}

void GroupNested2PartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested2PartySubIDType.offset = -1;
}

void GroupNested2PartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested2PartyIDSource.offset = -1;
     fieldNested2PartyRole.offset = -1;
     for( auto g = groupsNested2PartySubIDs.begin(); g != groupsNested2PartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupHops::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldHopSendingTime.offset = -1;
     fieldHopRefID.offset = -1;
}

void GroupCollInquiryQualifier::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPartyIDSource.offset = -1;
     fieldPartyRole.offset = -1;
     for( auto g = groupsPartySubIDs.begin(); g != groupsPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupAllocs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldAllocAcctIDSource.offset = -1;
     fieldAllocPrice.offset = -1;
     fieldIndividualAllocID.offset = -1;
     fieldIndividualAllocRejCode.offset = -1;
     fieldAllocText.offset = -1;
     fieldEncodedAllocTextLen.offset = -1;
     fieldEncodedAllocText.offset = -1;
}

void GroupTradingSessions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTradingSessionSubID.offset = -1;
}

void GroupSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecurityAltIDSource.offset = -1;
}

void GroupUnderlyingSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSecurityAltIDSource.offset = -1;
}

void GroupUnderlyingStips::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingStipValue.offset = -1;
}

void GroupUnderlyings::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSymbolSfx.offset = -1;
     fieldUnderlyingSecurityID.offset = -1;
     fieldUnderlyingSecurityIDSource.offset = -1;
     for( auto g = groupsUnderlyingSecurityAltID.begin(); g != groupsUnderlyingSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingProduct.offset = -1;
     fieldUnderlyingCFICode.offset = -1;
     fieldUnderlyingSecurityType.offset = -1;
     fieldUnderlyingSecuritySubType.offset = -1;
     fieldUnderlyingMaturityMonthYear.offset = -1;
     fieldUnderlyingMaturityDate.offset = -1;
     fieldUnderlyingPutOrCall.offset = -1;
     fieldUnderlyingCouponPaymentDate.offset = -1;
     fieldUnderlyingIssueDate.offset = -1;
     fieldUnderlyingRepoCollateralSecurityType.offset = -1;
     fieldUnderlyingRepurchaseTerm.offset = -1;
     fieldUnderlyingRepurchaseRate.offset = -1;
     fieldUnderlyingFactor.offset = -1;
     fieldUnderlyingCreditRating.offset = -1;
     fieldUnderlyingInstrRegistry.offset = -1;
     fieldUnderlyingCountryOfIssue.offset = -1;
     fieldUnderlyingStateOrProvinceOfIssue.offset = -1;
     fieldUnderlyingLocaleOfIssue.offset = -1;
     fieldUnderlyingRedemptionDate.offset = -1;
     fieldUnderlyingStrikePrice.offset = -1;
     fieldUnderlyingStrikeCurrency.offset = -1;
     fieldUnderlyingOptAttribute.offset = -1;
     fieldUnderlyingContractMultiplier.offset = -1;
     fieldUnderlyingCouponRate.offset = -1;
     fieldUnderlyingSecurityExchange.offset = -1;
     fieldUnderlyingIssuer.offset = -1;
     fieldEncodedUnderlyingIssuerLen.offset = -1;
     fieldEncodedUnderlyingIssuer.offset = -1;
     fieldUnderlyingSecurityDesc.offset = -1;
     fieldEncodedUnderlyingSecurityDescLen.offset = -1;
     fieldEncodedUnderlyingSecurityDesc.offset = -1;
     fieldUnderlyingCPProgram.offset = -1;
     fieldUnderlyingCPRegType.offset = -1;
     fieldUnderlyingCurrency.offset = -1;
     fieldUnderlyingQty.offset = -1;
     fieldUnderlyingPx.offset = -1;
     fieldUnderlyingDirtyPrice.offset = -1;
     fieldUnderlyingEndPrice.offset = -1;
     fieldUnderlyingStartValue.offset = -1;
     fieldUnderlyingCurrentValue.offset = -1;
     fieldUnderlyingEndValue.offset = -1;
     for( auto g = groupsUnderlyingStips.begin(); g != groupsUnderlyingStips.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingSettlPrice.offset = -1;
     fieldUnderlyingSettlPriceType.offset = -1;
}

void GroupStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldStipulationValue.offset = -1;
}

void GroupOrders::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecondaryClOrdID.offset = -1;
     fieldListSeqNo.offset = -1;
     fieldClOrdLinkID.offset = -1;
     fieldSettlInstMode.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTradeOriginationDate.offset = -1;
     fieldTradeDate.offset = -1;
     fieldAccount.offset = -1;
     fieldAcctIDSource.offset = -1;
     fieldAccountType.offset = -1;
     fieldDayBookingInst.offset = -1;
     fieldBookingUnit.offset = -1;
     fieldAllocID.offset = -1;
     fieldPreallocMethod.offset = -1;
     for( auto g = groupsAllocs.begin(); g != groupsAllocs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldSettlType.offset = -1;
     fieldSettlDate.offset = -1;
     fieldCashMargin.offset = -1;
     fieldClearingFeeIndicator.offset = -1;
     fieldHandlInst.offset = -1;
     fieldExecInst.offset = -1;
     fieldMinQty.offset = -1;
     fieldMaxFloor.offset = -1;
     fieldExDestination.offset = -1;
     for( auto g = groupsTradingSessions.begin(); g != groupsTradingSessions.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProcessCode.offset = -1;
     fieldSymbol.offset = -1;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
     for( auto g = groupsUnderlyings.begin(); g != groupsUnderlyings.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldPrevClosePx.offset = -1;
     fieldSide.offset = -1;
     fieldSideValueInd.offset = -1;
     fieldLocateReqd.offset = -1;
     fieldTransactTime.offset = -1;
     for( auto g = groupsStipulations.begin(); g != groupsStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldQtyType.offset = -1;
     fieldOrderQty.offset = -1;
     fieldCashOrderQty.offset = -1;
     fieldOrderPercent.offset = -1;
     fieldRoundingDirection.offset = -1;
     fieldRoundingModulus.offset = -1;
     fieldOrdType.offset = -1;
     fieldPriceType.offset = -1;
     fieldPrice.offset = -1;
     fieldStopPx.offset = -1;
     fieldSpread.offset = -1;
     fieldBenchmarkCurveCurrency.offset = -1;
     fieldBenchmarkCurveName.offset = -1;
     fieldBenchmarkCurvePoint.offset = -1;
     fieldBenchmarkPrice.offset = -1;
     fieldBenchmarkPriceType.offset = -1;
     fieldBenchmarkSecurityID.offset = -1;
     fieldBenchmarkSecurityIDSource.offset = -1;
     fieldYieldType.offset = -1;
     fieldYield.offset = -1;
     fieldYieldCalcDate.offset = -1;
     fieldYieldRedemptionDate.offset = -1;
     fieldYieldRedemptionPrice.offset = -1;
     fieldYieldRedemptionPriceType.offset = -1;
     fieldCurrency.offset = -1;
     fieldComplianceID.offset = -1;
     fieldSolicitedFlag.offset = -1;
     fieldIOIID.offset = -1;
     fieldQuoteID.offset = -1;
     fieldTimeInForce.offset = -1;
     fieldEffectiveTime.offset = -1;
     fieldExpireDate.offset = -1;
     fieldExpireTime.offset = -1;
     fieldGTBookingInst.offset = -1;
     fieldCommission.offset = -1;
     fieldCommType.offset = -1;
     fieldCommCurrency.offset = -1;
     fieldFundRenewWaiv.offset = -1;
     fieldOrderCapacity.offset = -1;
     fieldOrderRestrictions.offset = -1;
     fieldCustOrderCapacity.offset = -1;
     fieldForexReq.offset = -1;
     fieldSettlCurrency.offset = -1;
     fieldBookingType.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
     fieldSettlDate2.offset = -1;
     fieldOrderQty2.offset = -1;
     fieldPrice2.offset = -1;
     fieldPositionEffect.offset = -1;
     fieldCoveredOrUncovered.offset = -1;
     fieldMaxShow.offset = -1;
     fieldPegOffsetValue.offset = -1;
     fieldPegMoveType.offset = -1;
     fieldPegOffsetType.offset = -1;
     fieldPegLimitType.offset = -1;
     fieldPegRoundDirection.offset = -1;
     fieldPegScope.offset = -1;
     fieldDiscretionInst.offset = -1;
     fieldDiscretionOffsetValue.offset = -1;
     fieldDiscretionMoveType.offset = -1;
     fieldDiscretionOffsetType.offset = -1;
     fieldDiscretionLimitType.offset = -1;
     fieldDiscretionRoundDirection.offset = -1;
     fieldDiscretionScope.offset = -1;
     fieldTargetStrategy.offset = -1;
     fieldTargetStrategyParameters.offset = -1;
     fieldParticipationRate.offset = -1;
     fieldDesignation.offset = -1;
}

void GroupSettlPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlPartySubIDType.offset = -1;
}

void GroupSettlPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlPartyIDSource.offset = -1;
     fieldSettlPartyRole.offset = -1;
     for( auto g = groupsSettlPartySubIDs.begin(); g != groupsSettlPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupDlvyInst::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldDlvyInstType.offset = -1;
     for( auto g = groupsSettlPartyIDs.begin(); g != groupsSettlPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupClearingInstructions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupNestedPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartySubIDType.offset = -1;
}

void GroupNestedPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartyIDSource.offset = -1;
     fieldNestedPartyRole.offset = -1;
     for( auto g = groupsNestedPartySubIDs.begin(); g != groupsNestedPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupLegs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSymbolSfx.offset = -1;
     fieldLegSecurityID.offset = -1;
     fieldLegSecurityIDSource.offset = -1;
     for( auto g = groupsLegSecurityAltID.begin(); g != groupsLegSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegProduct.offset = -1;
     fieldLegCFICode.offset = -1;
     fieldLegSecurityType.offset = -1;
     fieldLegSecuritySubType.offset = -1;
     fieldLegMaturityMonthYear.offset = -1;
     fieldLegMaturityDate.offset = -1;
     fieldLegCouponPaymentDate.offset = -1;
     fieldLegIssueDate.offset = -1;
     fieldLegRepoCollateralSecurityType.offset = -1;
     fieldLegRepurchaseTerm.offset = -1;
     fieldLegRepurchaseRate.offset = -1;
     fieldLegFactor.offset = -1;
     fieldLegCreditRating.offset = -1;
     fieldLegInstrRegistry.offset = -1;
     fieldLegCountryOfIssue.offset = -1;
     fieldLegStateOrProvinceOfIssue.offset = -1;
     fieldLegLocaleOfIssue.offset = -1;
     fieldLegRedemptionDate.offset = -1;
     fieldLegStrikePrice.offset = -1;
     fieldLegStrikeCurrency.offset = -1;
     fieldLegOptAttribute.offset = -1;
     fieldLegContractMultiplier.offset = -1;
     fieldLegCouponRate.offset = -1;
     fieldLegSecurityExchange.offset = -1;
     fieldLegIssuer.offset = -1;
     fieldEncodedLegIssuerLen.offset = -1;
     fieldEncodedLegIssuer.offset = -1;
     fieldLegSecurityDesc.offset = -1;
     fieldEncodedLegSecurityDescLen.offset = -1;
     fieldEncodedLegSecurityDesc.offset = -1;
     fieldLegRatioQty.offset = -1;
     fieldLegSide.offset = -1;
     fieldLegCurrency.offset = -1;
     fieldLegPool.offset = -1;
     fieldLegDatedDate.offset = -1;
     fieldLegContractSettlMonth.offset = -1;
     fieldLegInterestAccrualDate.offset = -1;
     fieldLegQty.offset = -1;
     fieldLegSwapType.offset = -1;
     for( auto g = groupsLegStipulations.begin(); g != groupsLegStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegPositionEffect.offset = -1;
     fieldLegCoveredOrUncovered.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegRefID.offset = -1;
     fieldLegPrice.offset = -1;
     fieldLegSettlType.offset = -1;
     fieldLegSettlDate.offset = -1;
     fieldLegLastPx.offset = -1;
}

void GroupQuoteEntries::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
     fieldAgreementDesc.offset = -1;
     fieldAgreementID.offset = -1;
     fieldAgreementDate.offset = -1;
     fieldAgreementCurrency.offset = -1;
     fieldTerminationType.offset = -1;
     fieldStartDate.offset = -1;
     fieldEndDate.offset = -1;
     fieldDeliveryType.offset = -1;
     fieldMarginRatio.offset = -1;
     for( auto g = groupsUnderlyings.begin(); g != groupsUnderlyings.end() and g->getMessageBuffer(); ++g ) g->reset();
     for( auto g = groupsLegs.begin(); g != groupsLegs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupQuoteSets::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSymbol.offset = -1;
     fieldUnderlyingSymbolSfx.offset = -1;
     fieldUnderlyingSecurityID.offset = -1;
     fieldUnderlyingSecurityIDSource.offset = -1;
     for( auto g = groupsUnderlyingSecurityAltID.begin(); g != groupsUnderlyingSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingProduct.offset = -1;
     fieldUnderlyingCFICode.offset = -1;
     fieldUnderlyingSecurityType.offset = -1;
     fieldUnderlyingSecuritySubType.offset = -1;
     fieldUnderlyingMaturityMonthYear.offset = -1;
     fieldUnderlyingMaturityDate.offset = -1;
     fieldUnderlyingPutOrCall.offset = -1;
     fieldUnderlyingCouponPaymentDate.offset = -1;
     fieldUnderlyingIssueDate.offset = -1;
     fieldUnderlyingRepoCollateralSecurityType.offset = -1;
     fieldUnderlyingRepurchaseTerm.offset = -1;
     fieldUnderlyingRepurchaseRate.offset = -1;
     fieldUnderlyingFactor.offset = -1;
     fieldUnderlyingCreditRating.offset = -1;
     fieldUnderlyingInstrRegistry.offset = -1;
     fieldUnderlyingCountryOfIssue.offset = -1;
     fieldUnderlyingStateOrProvinceOfIssue.offset = -1;
     fieldUnderlyingLocaleOfIssue.offset = -1;
     fieldUnderlyingRedemptionDate.offset = -1;
     fieldUnderlyingStrikePrice.offset = -1;
     fieldUnderlyingStrikeCurrency.offset = -1;
     fieldUnderlyingOptAttribute.offset = -1;
     fieldUnderlyingContractMultiplier.offset = -1;
     fieldUnderlyingCouponRate.offset = -1;
     fieldUnderlyingSecurityExchange.offset = -1;
     fieldUnderlyingIssuer.offset = -1;
     fieldEncodedUnderlyingIssuerLen.offset = -1;
     fieldEncodedUnderlyingIssuer.offset = -1;
     fieldUnderlyingSecurityDesc.offset = -1;
     fieldEncodedUnderlyingSecurityDescLen.offset = -1;
     fieldEncodedUnderlyingSecurityDesc.offset = -1;
     fieldUnderlyingCPProgram.offset = -1;
     fieldUnderlyingCPRegType.offset = -1;
     fieldUnderlyingCurrency.offset = -1;
     fieldUnderlyingQty.offset = -1;
     fieldUnderlyingPx.offset = -1;
     fieldUnderlyingDirtyPrice.offset = -1;
     fieldUnderlyingEndPrice.offset = -1;
     fieldUnderlyingStartValue.offset = -1;
     fieldUnderlyingCurrentValue.offset = -1;
     fieldUnderlyingEndValue.offset = -1;
     for( auto g = groupsUnderlyingStips.begin(); g != groupsUnderlyingStips.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTotNoQuoteEntries.offset = -1;
     fieldLastFragment.offset = -1;
     for( auto g = groupsQuoteEntries.begin(); g != groupsQuoteEntries.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupSecurityTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecuritySubType.offset = -1;
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
}

void GroupNested3PartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested3PartyIDSource.offset = -1;
     fieldNested3PartyRole.offset = -1;
     for( auto g = groupsNested3PartySubIDs.begin(); g != groupsNested3PartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupPositions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLongQty.offset = -1;
     fieldShortQty.offset = -1;
     fieldPosQtyStatus.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupAffectedOrders::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldAffectedOrderID.offset = -1;
     fieldAffectedSecondaryOrderID.offset = -1;
}

void GroupExecs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldExecID.offset = -1;
     fieldSecondaryExecID.offset = -1;
     fieldLastPx.offset = -1;
     fieldLastParPx.offset = -1;
     fieldLastCapacity.offset = -1;
}

void GroupMsgTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMsgDirection.offset = -1;
}

void GroupBidComponents::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSide.offset = -1;
     fieldTradingSessionID.offset = -1;
     fieldTradingSessionSubID.offset = -1;
     fieldNetGrossInd.offset = -1;
     fieldSettlType.offset = -1;
     fieldSettlDate.offset = -1;
     fieldAccount.offset = -1;
     fieldAcctIDSource.offset = -1;
}

void GroupSettlInst::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlInstTransType.offset = -1;
     fieldSettlInstRefID.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldSide.offset = -1;
     fieldProduct.offset = -1;
     fieldSecurityType.offset = -1;
     fieldCFICode.offset = -1;
     fieldEffectiveTime.offset = -1;
     fieldExpireTime.offset = -1;
     fieldLastUpdateTime.offset = -1;
     fieldSettlDeliveryType.offset = -1;
     fieldStandInstDbType.offset = -1;
     fieldStandInstDbName.offset = -1;
     fieldStandInstDbID.offset = -1;
     for( auto g = groupsDlvyInst.begin(); g != groupsDlvyInst.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldPaymentMethod.offset = -1;
     fieldPaymentRef.offset = -1;
     fieldCardHolderName.offset = -1;
     fieldCardNumber.offset = -1;
     fieldCardStartDate.offset = -1;
     fieldCardExpDate.offset = -1;
     fieldCardIssNum.offset = -1;
     fieldPaymentDate.offset = -1;
     fieldPaymentRemitterID.offset = -1;
}

void GroupInstrAttrib::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldInstrAttribValue.offset = -1;
}

void GroupMiscFees::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMiscFeeCurr.offset = -1;
     fieldMiscFeeType.offset = -1;
     fieldMiscFeeBasis.offset = -1;
}

void GroupQuoteQualifiers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupDistribInsts::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldDistribPercentage.offset = -1;
     fieldCashDistribCurr.offset = -1;
     fieldCashDistribAgentName.offset = -1;
     fieldCashDistribAgentCode.offset = -1;
     fieldCashDistribAgentAcctNumber.offset = -1;
     fieldCashDistribPayRef.offset = -1;
     fieldCashDistribAgentAcctName.offset = -1;
}

void GroupTrdRegTimestamps::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTrdRegTimestampType.offset = -1;
     fieldTrdRegTimestampOrigin.offset = -1;
}

void GroupAltMDSource::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupSides::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldOrigClOrdID.offset = -1;
     fieldClOrdID.offset = -1;
     fieldSecondaryClOrdID.offset = -1;
     fieldClOrdLinkID.offset = -1;
     fieldOrigOrdModTime.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTradeOriginationDate.offset = -1;
     fieldTradeDate.offset = -1;
     fieldOrderQty.offset = -1;
     fieldCashOrderQty.offset = -1;
     fieldOrderPercent.offset = -1;
     fieldRoundingDirection.offset = -1;
     fieldRoundingModulus.offset = -1;
     fieldComplianceID.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}

void GroupRoutingIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRoutingID.offset = -1;
}

void GroupPosAmt::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPosAmt.offset = -1;
}

void GroupLinesOfText::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}

void GroupIOIQualifiers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupDates::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTransactTime.offset = -1;
}

void GroupMDEntryTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupRelatedSym::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
}

void GroupContraBrokers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldContraTrader.offset = -1;
     fieldContraTradeQty.offset = -1;
     fieldContraTradeTime.offset = -1;
     fieldContraLegRefID.offset = -1;
}

void GroupTrades::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecondaryTradeReportID.offset = -1;
}

void GroupStrikes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
}

void GroupBidDescriptors::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldBidDescriptor.offset = -1;
     fieldSideValueInd.offset = -1;
     fieldLiquidityValue.offset = -1;
     fieldLiquidityNumSecurities.offset = -1;
     fieldLiquidityPctLow.offset = -1;
     fieldLiquidityPctHigh.offset = -1;
     fieldEFPTrackingError.offset = -1;
     fieldFairValue.offset = -1;
     fieldOutsideIndexPct.offset = -1;
     fieldValueOfFutures.offset = -1;
}

void GroupCompIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRefSubID.offset = -1;
     fieldLocationID.offset = -1;
     fieldDeskID.offset = -1;
}

void GroupLegAllocs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegIndividualAllocID.offset = -1;
     for( auto g = groupsNested2PartyIDs.begin(); g != groupsNested2PartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegAllocQty.offset = -1;
     fieldLegAllocAcctIDSource.offset = -1;
     fieldLegSettlCurrency.offset = -1;
}

void GroupRegistDtls::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRegistEmail.offset = -1;
     fieldMailingDtls.offset = -1;
     fieldMailingInst.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldOwnerType.offset = -1;
     fieldDateOfBirth.offset = -1;
     fieldInvestorCountryOfResidence.offset = -1;
}

void GroupContAmts::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldContAmtValue.offset = -1;
     fieldContAmtCurr.offset = -1;
}

void GroupMDEntries::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMDEntryPx.offset = -1;
     fieldCurrency.offset = -1;
     fieldMDEntrySize.offset = -1;
     fieldMDEntryDate.offset = -1;
     fieldMDEntryTime.offset = -1;
     fieldTickDirection.offset = -1;
     fieldMDMkt.offset = -1;
     fieldTradingSessionID.offset = -1;
     fieldTradingSessionSubID.offset = -1;
     fieldQuoteCondition.offset = -1;
     fieldTradeCondition.offset = -1;
     fieldMDEntryOriginator.offset = -1;
     fieldLocationID.offset = -1;
     fieldDeskID.offset = -1;
     fieldOpenCloseSettlFlag.offset = -1;
     fieldTimeInForce.offset = -1;
     fieldExpireDate.offset = -1;
     fieldExpireTime.offset = -1;
     fieldMinQty.offset = -1;
     fieldExecInst.offset = -1;
     fieldSellerDays.offset = -1;
     fieldOrderID.offset = -1;
     fieldQuoteEntryID.offset = -1;
     fieldMDEntryBuyer.offset = -1;
     fieldMDEntrySeller.offset = -1;
     fieldNumberOfOrders.offset = -1;
     fieldMDEntryPositionNo.offset = -1;
     fieldScope.offset = -1;
     fieldPriceDelta.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}
// end of Groups.cxx

} // namespace fix44
